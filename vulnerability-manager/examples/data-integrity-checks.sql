-- =============================================================================
-- DATA INTEGRITY VERIFICATION SCRIPT
-- SentinelCore - Check for data consistency issues
-- Run this script to identify data inconsistencies in the database
-- =============================================================================

-- =============================================================================
-- SECTION 1: SOFT DELETE INCONSISTENCIES
-- =============================================================================

-- 1.1: Vulnerabilities marked as deleted but with active status
SELECT 
    'SOFT_DELETE_INCONSISTENCY' as check_type,
    COUNT(*) as issue_count,
    'Vulnerabilities with deleted_at set but active status' as description
FROM vulnerabilities 
WHERE deleted_at IS NOT NULL 
AND status IN ('open', 'in_progress');

-- 1.2: Teams marked as deleted but with active vulnerabilities
SELECT 
    'SOFT_DELETE_CASCADE_MISSING' as check_type,
    COUNT(*) as issue_count,
    'Vulnerabilities of soft-deleted teams' as description
FROM vulnerabilities v
INNER JOIN teams t ON v.assigned_team_id = t.id
WHERE t.deleted_at IS NOT NULL 
AND v.deleted_at IS NULL;

-- 1.3: Assets marked as deleted but with active vulnerabilities
SELECT 
    'SOFT_DELETE_CASCADE_MISSING' as check_type,
    COUNT(*) as issue_count,
    'Vulnerabilities of soft-deleted assets' as description
FROM vulnerabilities v
INNER JOIN assets a ON v.asset_id = a.id
WHERE a.deleted_at IS NOT NULL 
AND v.deleted_at IS NULL;

-- =============================================================================
-- SECTION 2: ORPHANED REFERENCES
-- =============================================================================

-- 2.1: Vulnerabilities with non-existent assets (broken foreign key)
SELECT 
    'ORPHANED_ASSET_REFERENCE' as check_type,
    COUNT(*) as issue_count,
    'Vulnerabilities with asset_id pointing to non-existent assets' as description
FROM vulnerabilities v
LEFT JOIN assets a ON v.asset_id = a.id
WHERE v.asset_id IS NOT NULL
AND a.id IS NULL;

-- 2.2: Vulnerabilities with non-existent teams
SELECT 
    'ORPHANED_TEAM_REFERENCE' as check_type,
    COUNT(*) as issue_count,
    'Vulnerabilities assigned to non-existent teams' as description
FROM vulnerabilities v
LEFT JOIN teams t ON v.assigned_team_id = t.id
WHERE v.assigned_team_id IS NOT NULL
AND t.id IS NULL;

-- 2.3: Vulnerabilities assigned to deleted teams
SELECT 
    'DELETED_TEAM_REFERENCE' as check_type,
    COUNT(*) as issue_count,
    'Vulnerabilities assigned to soft-deleted teams' as description
FROM vulnerabilities v
LEFT JOIN teams t ON v.assigned_team_id = t.id
WHERE v.assigned_team_id IS NOT NULL
AND t.deleted_at IS NOT NULL;

-- 2.4: Vulnerabilities assigned to non-existent users
SELECT 
    'ORPHANED_USER_REFERENCE' as check_type,
    COUNT(*) as issue_count,
    'Vulnerabilities assigned to non-existent users' as description
FROM vulnerabilities v
LEFT JOIN users u ON v.assigned_user_id = u.id
WHERE v.assigned_user_id IS NOT NULL
AND u.id IS NULL;

-- 2.5: Vulnerabilities assigned to deleted users
SELECT 
    'DELETED_USER_REFERENCE' as check_type,
    COUNT(*) as issue_count,
    'Vulnerabilities assigned to soft-deleted users' as description
FROM vulnerabilities v
LEFT JOIN users u ON v.assigned_user_id = u.id
WHERE v.assigned_user_id IS NOT NULL
AND u.deleted_at IS NOT NULL;

-- =============================================================================
-- SECTION 3: INVALID DATA VALUES
-- =============================================================================

-- 3.1: Invalid CVSS scores
SELECT 
    'INVALID_CVSS_SCORE' as check_type,
    COUNT(*) as issue_count,
    'Vulnerabilities with CVSS scores outside 0-10 range' as description
FROM vulnerabilities
WHERE cvss_score < 0 OR cvss_score > 10;

-- 3.2: Invalid EPSS scores
SELECT 
    'INVALID_EPSS_SCORE' as check_type,
    COUNT(*) as issue_count,
    'Vulnerabilities with EPSS scores outside 0-1 range' as description
FROM vulnerabilities
WHERE epss_score IS NOT NULL 
AND (epss_score < 0 OR epss_score > 1);

-- 3.3: Invalid port numbers
SELECT 
    'INVALID_PORT_NUMBER' as check_type,
    COUNT(*) as issue_count,
    'Vulnerabilities with invalid port numbers' as description
FROM vulnerabilities
WHERE port IS NOT NULL 
AND (port < 1 OR port > 65535);

-- 3.4: Invalid IP addresses (basic check)
SELECT 
    'SUSPICIOUS_IP_ADDRESS' as check_type,
    COUNT(*) as issue_count,
    'Vulnerabilities with null or empty IP addresses' as description
FROM vulnerabilities
WHERE ip_address IS NULL OR ip_address = '';

-- 3.5: Invalid CVE ID format
SELECT 
    'INVALID_CVE_FORMAT' as check_type,
    COUNT(*) as issue_count,
    'Vulnerabilities with invalid CVE ID format (should be CVE-YYYY-XXXXX)' as description
FROM vulnerabilities
WHERE cve_id IS NOT NULL 
AND cve_id NOT LIKE 'CVE-%';

-- =============================================================================
-- SECTION 4: TIMESTAMP ANOMALIES
-- =============================================================================

-- 4.1: Created after updated (impossible state)
SELECT 
    'IMPOSSIBLE_TIMESTAMP' as check_type,
    COUNT(*) as issue_count,
    'Vulnerabilities where created_at > updated_at' as description
FROM vulnerabilities
WHERE created_at > updated_at;

-- 4.2: Discovered in future (impossible)
SELECT 
    'FUTURE_DISCOVERED_DATE' as check_type,
    COUNT(*) as issue_count,
    'Vulnerabilities with discovered_at in the future' as description
FROM vulnerabilities
WHERE discovered_at > NOW();

-- 4.3: Updated but deleted before created (impossible)
SELECT 
    'IMPOSSIBLE_DELETE_TIMESTAMP' as check_type,
    COUNT(*) as issue_count,
    'Soft-deleted vulnerabilities with deleted_at < created_at' as description
FROM vulnerabilities
WHERE deleted_at IS NOT NULL 
AND deleted_at < created_at;

-- =============================================================================
-- SECTION 5: RESOLUTION INCONSISTENCIES
-- =============================================================================

-- 5.1: Resolutions for non-existent vulnerabilities
SELECT 
    'ORPHANED_RESOLUTION' as check_type,
    COUNT(*) as issue_count,
    'Resolutions pointing to non-existent vulnerabilities' as description
FROM resolutions r
LEFT JOIN vulnerabilities v ON r.vulnerability_id = v.id
WHERE v.id IS NULL;

-- 5.2: Resolutions for non-existent teams
SELECT 
    'ORPHANED_RESOLUTION_TEAM' as check_type,
    COUNT(*) as issue_count,
    'Resolutions pointing to non-existent teams' as description
FROM resolutions r
LEFT JOIN teams t ON r.team_id = t.id
WHERE t.id IS NULL;

-- 5.3: Resolutions assigned to non-existent users
SELECT 
    'ORPHANED_RESOLUTION_USER' as check_type,
    COUNT(*) as issue_count,
    'Resolutions assigned to non-existent users' as description
FROM resolutions r
LEFT JOIN users u ON r.assigned_to = u.id
WHERE r.assigned_to IS NOT NULL 
AND u.id IS NULL;

-- 5.4: Resolutions with resolved_at but status not completed
SELECT 
    'INCONSISTENT_RESOLUTION' as check_type,
    COUNT(*) as issue_count,
    'Resolutions with resolved_at set but status != completed' as description
FROM resolutions
WHERE resolved_at IS NOT NULL 
AND status != 'completed';

-- =============================================================================
-- SECTION 6: REPORT INCONSISTENCIES
-- =============================================================================

-- 6.1: Reports referencing non-existent users
SELECT 
    'ORPHANED_REPORT_USER' as check_type,
    COUNT(*) as issue_count,
    'Reports created by non-existent users' as description
FROM reports r
LEFT JOIN users u ON r.created_by = u.id
WHERE u.id IS NULL;

-- 6.2: Reports with impossible processed count
SELECT 
    'INVALID_REPORT_COUNT' as check_type,
    COUNT(*) as issue_count,
    'Reports where processed_vulns > total_vulns' as description
FROM reports
WHERE processed_vulns > total_vulns 
AND total_vulns IS NOT NULL 
AND processed_vulns IS NOT NULL;

-- =============================================================================
-- SECTION 7: AUDIT LOG INCONSISTENCIES
-- =============================================================================

-- 7.1: Audit logs for non-existent users
SELECT 
    'ORPHANED_AUDIT_USER' as check_type,
    COUNT(*) as issue_count,
    'Audit logs for non-existent users' as description
FROM audit_logs al
LEFT JOIN users u ON al.user_id = u.id
WHERE al.user_id IS NOT NULL 
AND u.id IS NULL;

-- 7.2: Audit logs for deleted entities
SELECT 
    'DELETED_ENTITY_AUDIT' as check_type,
    COUNT(*) as issue_count,
    'Audit logs referencing soft-deleted entities' as description
FROM audit_logs
WHERE entity_type = 'vulnerability' 
AND entity_id IN (SELECT id FROM vulnerabilities WHERE deleted_at IS NOT NULL);

-- =============================================================================
-- SECTION 8: DATA QUALITY METRICS
-- =============================================================================

-- 8.1: Summary of null values in critical fields
SELECT 
    'DATA_QUALITY' as check_type,
    'NULL_IP_ADDRESS' as issue,
    COUNT(*) as count
FROM vulnerabilities
WHERE ip_address IS NULL AND deleted_at IS NULL
UNION ALL
SELECT 'DATA_QUALITY', 'NULL_TITLE', COUNT(*) FROM vulnerabilities WHERE title IS NULL AND deleted_at IS NULL
UNION ALL
SELECT 'DATA_QUALITY', 'NULL_DESCRIPTION', COUNT(*) FROM vulnerabilities WHERE description IS NULL AND deleted_at IS NULL
UNION ALL
SELECT 'DATA_QUALITY', 'NULL_SOURCE', COUNT(*) FROM vulnerabilities WHERE source IS NULL AND deleted_at IS NULL;

-- 8.2: Distribution of vulnerability status
SELECT 
    'STATUS_DISTRIBUTION' as metric,
    status,
    COUNT(*) as count
FROM vulnerabilities
WHERE deleted_at IS NULL
GROUP BY status
ORDER BY count DESC;

-- 8.3: Vulnerabilities without assignment
SELECT 
    'ASSIGNMENT_STATUS' as metric,
    CASE 
        WHEN assigned_team_id IS NULL AND assigned_user_id IS NULL THEN 'Unassigned'
        WHEN assigned_team_id IS NOT NULL AND assigned_user_id IS NULL THEN 'Assigned to Team'
        WHEN assigned_team_id IS NULL AND assigned_user_id IS NOT NULL THEN 'Assigned to User'
        ELSE 'Assigned to Both'
    END as assignment_type,
    COUNT(*) as count
FROM vulnerabilities
WHERE deleted_at IS NULL
GROUP BY assignment_type;

-- =============================================================================
-- SECTION 9: TEAM MEMBER CONSISTENCY
-- =============================================================================

-- 9.1: Team members in deleted teams
SELECT 
    'DELETED_TEAM_MEMBER' as check_type,
    COUNT(*) as issue_count,
    'Team members in soft-deleted teams' as description
FROM team_members tm
INNER JOIN teams t ON tm.team_id = t.id
WHERE t.deleted_at IS NOT NULL;

-- 9.2: Team members referencing non-existent teams
SELECT 
    'ORPHANED_TEAM_MEMBER' as check_type,
    COUNT(*) as issue_count,
    'Team members referencing non-existent teams' as description
FROM team_members tm
LEFT JOIN teams t ON tm.team_id = t.id
WHERE t.id IS NULL;

-- =============================================================================
-- SECTION 10: COMPREHENSIVE SUMMARY
-- =============================================================================

-- 10.1: Count of soft-deleted records by entity type
SELECT 
    'SOFT_DELETE_SUMMARY' as metric,
    'Vulnerabilities' as entity_type,
    COUNT(*) as soft_deleted_count,
    (SELECT COUNT(*) FROM vulnerabilities) as total_count
FROM vulnerabilities
WHERE deleted_at IS NOT NULL
UNION ALL
SELECT 'SOFT_DELETE_SUMMARY', 'Teams', COUNT(*), (SELECT COUNT(*) FROM teams)
FROM teams
WHERE deleted_at IS NOT NULL
UNION ALL
SELECT 'SOFT_DELETE_SUMMARY', 'Assets', COUNT(*), (SELECT COUNT(*) FROM assets)
FROM assets
WHERE deleted_at IS NOT NULL;

-- 10.2: Overall data health score (0-100)
-- This is a simple heuristic - adjust thresholds as needed
WITH issues AS (
    SELECT COUNT(*) as total_issues FROM (
        -- All issue counts combined
        SELECT 1 FROM vulnerabilities v LEFT JOIN assets a ON v.asset_id = a.id WHERE v.asset_id IS NOT NULL AND a.id IS NULL
        UNION ALL
        SELECT 1 FROM vulnerabilities v LEFT JOIN teams t ON v.assigned_team_id = t.id WHERE v.assigned_team_id IS NOT NULL AND t.id IS NULL
        UNION ALL
        SELECT 1 FROM vulnerabilities WHERE cvss_score < 0 OR cvss_score > 10
        UNION ALL
        SELECT 1 FROM vulnerabilities WHERE created_at > updated_at
    ) subq
),
total_records AS (
    SELECT COUNT(*) as total FROM vulnerabilities WHERE deleted_at IS NULL
)
SELECT 
    CASE 
        WHEN total_records.total = 0 THEN 100
        ELSE GREATEST(0, LEAST(100, ROUND((1 - (issues.total_issues::FLOAT / total_records.total)) * 100)::INT))
    END as data_health_score_percent,
    issues.total_issues as detected_issues,
    total_records.total as total_records
FROM issues, total_records;

-- =============================================================================
-- END OF INTEGRITY CHECKS
-- =============================================================================
