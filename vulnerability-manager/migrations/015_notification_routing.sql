-- Migration 015: Notification Routing System
-- Implements intelligent notification routing with rule-based channel selection

-- Notification channels configuration
CREATE TABLE IF NOT EXISTS notification_channels (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) NOT NULL UNIQUE,
    channel_type VARCHAR(50) NOT NULL CHECK (channel_type IN ('email', 'slack', 'telegram', 'teams', 'webhook', 'pagerduty', 'opsgenie')),
    is_enabled BOOLEAN DEFAULT TRUE,
    configuration JSON NOT NULL, -- Channel-specific config (webhook URL, API key, etc.)
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Notification routing rules
CREATE TABLE IF NOT EXISTS notification_rules (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(200) NOT NULL,
    description TEXT,
    priority INTEGER DEFAULT 100, -- Lower number = higher priority
    is_enabled BOOLEAN DEFAULT TRUE,

    -- Trigger conditions (JSON with operators)
    conditions JSON NOT NULL, -- {"risk_score": {"gte": 80}, "risk_tier": {"in": ["Critical"]}}

    -- Target channels and recipients
    channels UUID[] NOT NULL, -- Array of notification_channel IDs
    email_recipients TEXT[], -- Additional email addresses
    user_ids UUID[], -- Specific user IDs to notify
    team_ids UUID[], -- Specific team IDs to notify
    role_filter VARCHAR(50), -- Notify all users with role (admin, analyst, etc.)

    -- Notification behavior
    immediate BOOLEAN DEFAULT TRUE, -- Send immediately or batch
    throttle_minutes INTEGER DEFAULT 0, -- Minimum minutes between notifications for same condition
    quiet_hours_start TIME, -- Don't send during quiet hours (e.g., 22:00)
    quiet_hours_end TIME, -- End quiet hours (e.g., 08:00)

    -- Template customization
    message_template TEXT, -- Custom message template with variables
    include_details BOOLEAN DEFAULT TRUE,

    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_by UUID REFERENCES users(id)
);

-- Notification history (audit trail)
CREATE TABLE IF NOT EXISTS notification_history (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    rule_id UUID REFERENCES notification_rules(id) ON DELETE SET NULL,
    event_type VARCHAR(100) NOT NULL, -- 'vulnerability_created', 'sla_breach', etc.
    entity_type VARCHAR(50) NOT NULL, -- 'vulnerability', 'asset', 'remediation_plan'
    entity_id UUID NOT NULL,
    channel_id UUID REFERENCES notification_channels(id) ON DELETE SET NULL,
    channel_type VARCHAR(50) NOT NULL,
    recipient TEXT NOT NULL, -- Email, Slack channel, user ID
    status VARCHAR(50) DEFAULT 'pending' CHECK (status IN ('pending', 'sent', 'failed', 'throttled')),
    error_message TEXT,
    payload JSON, -- Notification payload sent
    response JSON, -- Response from channel API
    sent_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_notification_channels_type ON notification_channels(channel_type);
CREATE INDEX idx_notification_channels_enabled ON notification_channels(is_enabled);
CREATE INDEX idx_notification_rules_enabled ON notification_rules(is_enabled);
CREATE INDEX idx_notification_rules_priority ON notification_rules(priority ASC);
CREATE INDEX idx_notification_history_entity ON notification_history(entity_type, entity_id);
CREATE INDEX idx_notification_history_status ON notification_history(status);
CREATE INDEX idx_notification_history_created_at ON notification_history(created_at DESC);
CREATE INDEX idx_notification_history_channel ON notification_history(channel_id);

-- Function: Evaluate notification rule conditions
CREATE OR REPLACE FUNCTION evaluate_rule_conditions(
    p_conditions JSON,
    p_vulnerability_data JSON
) RETURNS BOOLEAN AS $$
DECLARE
    condition_key TEXT;
    condition_value JSON;
    operator TEXT;
    target_value JSON;
    actual_value JSON;
BEGIN
    -- Iterate through each condition
    FOR condition_key, condition_value IN SELECT * FROM json_each(p_conditions)
    LOOP
        -- Get actual value from vulnerability data
        actual_value := p_vulnerability_data->condition_key;

        -- Check operator and compare
        FOR operator, target_value IN SELECT * FROM json_each(condition_value)
        LOOP
            CASE operator
                WHEN 'eq' THEN -- Equal
                    IF actual_value::TEXT != target_value::TEXT THEN
                        RETURN FALSE;
                    END IF;

                WHEN 'neq' THEN -- Not equal
                    IF actual_value::TEXT = target_value::TEXT THEN
                        RETURN FALSE;
                    END IF;

                WHEN 'gt' THEN -- Greater than
                    IF (actual_value::TEXT)::NUMERIC <= (target_value::TEXT)::NUMERIC THEN
                        RETURN FALSE;
                    END IF;

                WHEN 'gte' THEN -- Greater than or equal
                    IF (actual_value::TEXT)::NUMERIC < (target_value::TEXT)::NUMERIC THEN
                        RETURN FALSE;
                    END IF;

                WHEN 'lt' THEN -- Less than
                    IF (actual_value::TEXT)::NUMERIC >= (target_value::TEXT)::NUMERIC THEN
                        RETURN FALSE;
                    END IF;

                WHEN 'lte' THEN -- Less than or equal
                    IF (actual_value::TEXT)::NUMERIC > (target_value::TEXT)::NUMERIC THEN
                        RETURN FALSE;
                    END IF;

                WHEN 'in' THEN -- Value in array
                    IF NOT (actual_value::JSONB <@ target_value::JSONB OR
                            target_value::JSONB ? (actual_value#>>'{}')) THEN
                        RETURN FALSE;
                    END IF;

                WHEN 'contains' THEN -- String contains
                    IF position(lower(target_value#>>'{}') in lower(actual_value#>>'{}')) = 0 THEN
                        RETURN FALSE;
                    END IF;

                ELSE
                    -- Unknown operator
                    RETURN FALSE;
            END CASE;
        END LOOP;
    END LOOP;

    -- All conditions passed
    RETURN TRUE;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- Function: Get matching notification rules for event
CREATE OR REPLACE FUNCTION get_matching_rules(
    p_event_type VARCHAR,
    p_vulnerability_data JSON
) RETURNS TABLE (
    rule_id UUID,
    rule_name VARCHAR,
    channels UUID[],
    email_recipients TEXT[],
    user_ids UUID[],
    team_ids UUID[],
    role_filter VARCHAR,
    immediate BOOLEAN,
    message_template TEXT
) AS $$
DECLARE
    current_time TIME := LOCALTIME;
BEGIN
    RETURN QUERY
    SELECT
        nr.id,
        nr.name,
        nr.channels,
        nr.email_recipients,
        nr.user_ids,
        nr.team_ids,
        nr.role_filter,
        nr.immediate,
        nr.message_template
    FROM notification_rules nr
    WHERE nr.is_enabled = TRUE
      -- Check quiet hours
      AND (nr.quiet_hours_start IS NULL OR nr.quiet_hours_end IS NULL OR
           NOT (current_time BETWEEN nr.quiet_hours_start AND nr.quiet_hours_end))
      -- Check throttling
      AND (nr.throttle_minutes = 0 OR NOT EXISTS (
          SELECT 1 FROM notification_history nh
          WHERE nh.rule_id = nr.id
            AND nh.entity_id = (p_vulnerability_data->>'id')::UUID
            AND nh.created_at > NOW() - (nr.throttle_minutes || ' minutes')::INTERVAL
      ))
      -- Evaluate conditions
      AND evaluate_rule_conditions(nr.conditions, p_vulnerability_data)
    ORDER BY nr.priority ASC;
END;
$$ LANGUAGE plpgsql;

-- Insert default notification rules
INSERT INTO notification_rules (name, description, priority, conditions, channels, immediate, message_template)
VALUES
    -- Critical vulnerabilities â†’ Immediate alert
    (
        'Critical Vulnerabilities Alert',
        'Immediate notification for all Critical risk tier vulnerabilities',
        10,
        '{"risk_tier": {"eq": "Critical"}}'::JSON,
        ARRAY[]::UUID[], -- Channels will be configured by admin
        TRUE,
        'CRITICAL: {title} discovered on {hostname}. Risk Score: {risk_score}/100. SLA: {sla_days} days.'
    ),
    -- SLA breach warning (75% elapsed)
    (
        'SLA Breach Warning (75%)',
        'Warning when 75% of SLA time has elapsed',
        20,
        '{"sla_elapsed_percent": {"gte": 75}}'::JSON,
        ARRAY[]::UUID[],
        TRUE,
        'SLA WARNING: {title} approaching deadline. {sla_days_remaining} days remaining.'
    ),
    -- SLA breach (100%)
    (
        'SLA Breach Alert',
        'Alert when SLA deadline has been breached',
        5, -- Highest priority
        '{"sla_breached": {"eq": true}}'::JSON,
        ARRAY[]::UUID[],
        TRUE,
        'SLA BREACHED: {title} past deadline. Immediate action required!'
    ),
    -- High severity vulnerabilities
    (
        'High Severity Vulnerabilities',
        'Notification for High risk tier vulnerabilities',
        30,
        '{"risk_tier": {"eq": "High"}}'::JSON,
        ARRAY[]::UUID[],
        TRUE,
        'High severity: {title} on {hostname}. Risk: {risk_score}/100. Remediate within {sla_days} days.'
    ),
    -- Zero-day vulnerabilities
    (
        'Zero-Day Alert',
        'Immediate alert for zero-day vulnerabilities',
        1, -- Highest priority
        '{"is_zero_day": {"eq": true}}'::JSON,
        ARRAY[]::UUID[],
        TRUE,
        'ZERO-DAY: {title} - {cve_id}. Immediate action required!'
    ),
    -- Ransomware targeted
    (
        'Ransomware Targeted Alert',
        'Alert for vulnerabilities targeted by ransomware',
        3,
        '{"is_ransomware_targeted": {"eq": true}}'::JSON,
        ARRAY[]::UUID[],
        TRUE,
        'RANSOMWARE TARGET: {title} actively exploited by ransomware groups!'
    ),
    -- Assignment notification
    (
        'Vulnerability Assigned',
        'Notify user when vulnerability is assigned to them',
        50,
        '{"event": {"eq": "assigned"}}'::JSON,
        ARRAY[]::UUID[],
        TRUE,
        'Assigned to you: {title}. Priority: {risk_tier}. Due: {sla_deadline}'
    ),
    -- Daily digest (low priority)
    (
        'Daily Summary Digest',
        'Daily summary of medium/low vulnerabilities',
        100,
        '{"risk_tier": {"in": ["Medium", "Low"]}}'::JSON,
        ARRAY[]::UUID[],
        FALSE, -- Batch mode
        'Daily digest: {count} vulnerabilities discovered.'
    );

-- Function: Check if in quiet hours
CREATE OR REPLACE FUNCTION is_quiet_hours(
    p_quiet_start TIME,
    p_quiet_end TIME
) RETURNS BOOLEAN AS $$
DECLARE
    current_time TIME := LOCALTIME;
BEGIN
    IF p_quiet_start IS NULL OR p_quiet_end IS NULL THEN
        RETURN FALSE;
    END IF;

    -- Handle cases where quiet hours cross midnight
    IF p_quiet_start < p_quiet_end THEN
        RETURN current_time BETWEEN p_quiet_start AND p_quiet_end;
    ELSE
        RETURN current_time >= p_quiet_start OR current_time <= p_quiet_end;
    END IF;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- Comments
COMMENT ON TABLE notification_channels IS 'Notification delivery channels (email, Slack, Telegram, etc.)';
COMMENT ON TABLE notification_rules IS 'Rule-based notification routing with conditions and targets';
COMMENT ON TABLE notification_history IS 'Audit trail of all sent notifications';
COMMENT ON COLUMN notification_rules.conditions IS 'JSON conditions: {"field": {"operator": "value"}}. Operators: eq, neq, gt, gte, lt, lte, in, contains';
COMMENT ON COLUMN notification_rules.throttle_minutes IS 'Minimum minutes between notifications for same condition (anti-spam)';
COMMENT ON COLUMN notification_rules.quiet_hours_start IS 'Start of quiet hours (no notifications), e.g. 22:00';
COMMENT ON FUNCTION evaluate_rule_conditions IS 'Evaluates rule conditions against vulnerability data. Returns TRUE if all conditions match';
COMMENT ON FUNCTION get_matching_rules IS 'Returns all enabled rules that match the event and vulnerability data, ordered by priority';
COMMENT ON FUNCTION is_quiet_hours IS 'Returns TRUE if current time is within quiet hours range';
