-- Migration 104: Create vulnerability_timeline table
-- Tracks all state changes and actions on vulnerabilities

CREATE TABLE IF NOT EXISTS vulnerability_timeline (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    vulnerability_id UUID NOT NULL REFERENCES vulnerabilities(id) ON DELETE CASCADE,

    -- Event details
    event_type VARCHAR(50) NOT NULL,  -- 'created', 'status_changed', 'assigned', 'reopened', 'resolved', 'comment_added', etc.
    old_value JSONB,                  -- Previous state (if applicable)
    new_value JSONB,                  -- New state
    message TEXT,                     -- Human-readable message
    metadata JSONB,                   -- Additional event-specific data

    -- Actor information
    actor_type VARCHAR(20) NOT NULL DEFAULT 'user',  -- 'user', 'system', 'scanner'
    actor_id UUID REFERENCES users(id) ON DELETE SET NULL,  -- NULL for system/scanner events
    actor_name VARCHAR(255),          -- Stored name for historical reference

    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Indexes for fast querying
CREATE INDEX idx_timeline_vulnerability ON vulnerability_timeline(vulnerability_id, created_at DESC);
CREATE INDEX idx_timeline_event_type ON vulnerability_timeline(event_type);
CREATE INDEX idx_timeline_actor ON vulnerability_timeline(actor_id);
CREATE INDEX idx_timeline_created_at ON vulnerability_timeline(created_at DESC);

-- Function to automatically create timeline entry when vulnerability is created
CREATE OR REPLACE FUNCTION track_vulnerability_creation()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO vulnerability_timeline (
        vulnerability_id,
        event_type,
        new_value,
        message,
        actor_type,
        actor_name
    ) VALUES (
        NEW.id,
        'created',
        to_jsonb(NEW),
        'Vulnerability discovered',
        'scanner',
        NEW.source
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Function to track status changes
CREATE OR REPLACE FUNCTION track_vulnerability_status_change()
RETURNS TRIGGER AS $$
BEGIN
    -- Only create entry if status actually changed
    IF OLD.status IS DISTINCT FROM NEW.status THEN
        INSERT INTO vulnerability_timeline (
            vulnerability_id,
            event_type,
            old_value,
            new_value,
            message,
            actor_type
        ) VALUES (
            NEW.id,
            'status_changed',
            jsonb_build_object('status', OLD.status),
            jsonb_build_object('status', NEW.status),
            format('Status changed from %s to %s', OLD.status, NEW.status),
            'system'
        );
    END IF;

    -- Track assignment changes
    IF OLD.assigned_user_id IS DISTINCT FROM NEW.assigned_user_id
       OR OLD.assigned_team_id IS DISTINCT FROM NEW.assigned_team_id THEN
        INSERT INTO vulnerability_timeline (
            vulnerability_id,
            event_type,
            old_value,
            new_value,
            message,
            actor_type
        ) VALUES (
            NEW.id,
            'assigned',
            jsonb_build_object(
                'assigned_user_id', OLD.assigned_user_id,
                'assigned_team_id', OLD.assigned_team_id
            ),
            jsonb_build_object(
                'assigned_user_id', NEW.assigned_user_id,
                'assigned_team_id', NEW.assigned_team_id
            ),
            'Assignment changed',
            'system'
        );
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Triggers
CREATE TRIGGER vulnerability_created_trigger
    AFTER INSERT ON vulnerabilities
    FOR EACH ROW
    EXECUTE FUNCTION track_vulnerability_creation();

CREATE TRIGGER vulnerability_updated_trigger
    AFTER UPDATE ON vulnerabilities
    FOR EACH ROW
    EXECUTE FUNCTION track_vulnerability_status_change();

-- Comments for documentation
COMMENT ON TABLE vulnerability_timeline IS 'Activity log for all vulnerability changes';
COMMENT ON COLUMN vulnerability_timeline.event_type IS 'Type of event: created, status_changed, assigned, reopened, resolved, comment_added';
COMMENT ON COLUMN vulnerability_timeline.actor_type IS 'Who triggered the event: user, system, or scanner';
COMMENT ON COLUMN vulnerability_timeline.metadata IS 'Additional context-specific data for the event';
