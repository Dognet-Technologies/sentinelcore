-- Migration 024: User Notifications System (In-App Notifications)
-- Persistent notifications for the bell icon in the UI

CREATE TYPE user_notification_type AS ENUM (
    'vulnerability_assigned',
    'vulnerability_reopened',
    'vulnerability_updated',
    'vulnerability_closed',
    'comment_mention',
    'sla_warning',
    'sla_breached',
    'remediation_plan_assigned',
    'team_assignment',
    'system_alert'
);

CREATE TYPE user_notification_priority AS ENUM ('low', 'normal', 'high', 'urgent');

CREATE TABLE IF NOT EXISTS user_notifications (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,

    -- Notification content
    notification_type user_notification_type NOT NULL,
    priority user_notification_priority DEFAULT 'normal',
    title VARCHAR(255) NOT NULL,
    message TEXT NOT NULL,
    action_url VARCHAR(500), -- Link to relevant page (e.g., /vulnerabilities/:id)

    -- Related entities
    vulnerability_id UUID REFERENCES vulnerabilities(id) ON DELETE CASCADE,
    team_id UUID REFERENCES teams(id) ON DELETE SET NULL,
    actor_id UUID REFERENCES users(id) ON DELETE SET NULL, -- Who triggered the notification
    actor_name VARCHAR(255), -- Display name of actor

    -- Metadata
    metadata JSONB, -- Additional data (CVE ID, severity, etc.)

    -- Status tracking
    is_read BOOLEAN DEFAULT FALSE,
    read_at TIMESTAMPTZ,
    is_dismissed BOOLEAN DEFAULT FALSE,
    dismissed_at TIMESTAMPTZ,

    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    expires_at TIMESTAMPTZ -- Auto-delete after expiration (optional)
);

-- Indexes for performance
CREATE INDEX idx_user_notif_user_id ON user_notifications(user_id);
CREATE INDEX idx_user_notif_is_read ON user_notifications(is_read) WHERE is_read = FALSE;
CREATE INDEX idx_user_notif_created_at ON user_notifications(created_at DESC);
CREATE INDEX idx_user_notif_type ON user_notifications(notification_type);
CREATE INDEX idx_user_notif_priority ON user_notifications(priority);
CREATE INDEX idx_user_notif_vuln_id ON user_notifications(vulnerability_id);

-- Function to create notification when vulnerability is assigned
CREATE OR REPLACE FUNCTION notify_vulnerability_assignment()
RETURNS TRIGGER AS $$
DECLARE
    assigned_user_id UUID;
    team_name TEXT;
    vuln_title TEXT;
    vuln_severity TEXT;
BEGIN
    -- Get vulnerability details
    vuln_title := NEW.title;
    vuln_severity := NEW.severity::TEXT;

    -- User directly assigned
    IF (OLD.assigned_to IS NULL AND NEW.assigned_to IS NOT NULL) OR
       (OLD.assigned_to IS NOT NULL AND OLD.assigned_to != NEW.assigned_to) THEN

        INSERT INTO user_notifications (
            user_id, notification_type, priority, title, message,
            action_url, vulnerability_id, metadata
        ) VALUES (
            NEW.assigned_to,
            'vulnerability_assigned',
            CASE
                WHEN NEW.severity IN ('critical') THEN 'urgent'::user_notification_priority
                WHEN NEW.severity IN ('high') THEN 'high'::user_notification_priority
                ELSE 'normal'::user_notification_priority
            END,
            format('Vulnerability Assigned: %s', SUBSTRING(vuln_title, 1, 100)),
            format('You have been assigned a %s severity vulnerability', vuln_severity),
            format('/vulnerabilities/%s', NEW.id),
            NEW.id,
            jsonb_build_object(
                'cve_id', NEW.cve_id,
                'severity', vuln_severity,
                'hostname', NEW.hostname
            )
        );
    END IF;

    -- Team assigned - notify team leader
    IF (OLD.assigned_team_id IS NULL AND NEW.assigned_team_id IS NOT NULL) OR
       (OLD.assigned_team_id IS NOT NULL AND OLD.assigned_team_id != NEW.assigned_team_id) THEN

        -- Get team name
        SELECT name INTO team_name FROM teams WHERE id = NEW.assigned_team_id;

        -- Notify all team leaders
        INSERT INTO user_notifications (
            user_id, notification_type, priority, title, message,
            action_url, vulnerability_id, team_id, metadata
        )
        SELECT
            u.id,
            'team_assignment',
            CASE
                WHEN NEW.severity IN ('critical') THEN 'urgent'::user_notification_priority
                WHEN NEW.severity IN ('high') THEN 'high'::user_notification_priority
                ELSE 'normal'::user_notification_priority
            END,
            format('Team Assignment: %s', team_name),
            format('A %s severity vulnerability has been assigned to your team', vuln_severity),
            format('/vulnerabilities/%s', NEW.id),
            NEW.id,
            NEW.assigned_team_id,
            jsonb_build_object(
                'cve_id', NEW.cve_id,
                'severity', vuln_severity,
                'hostname', NEW.hostname,
                'team_name', team_name
            )
        FROM users u
        WHERE u.role = 'team_leader'
          AND EXISTS (
              SELECT 1 FROM team_members tm
              WHERE tm.team_id = NEW.assigned_team_id
                AND tm.user_id = u.id
          );
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Function to notify when vulnerability is reopened
CREATE OR REPLACE FUNCTION notify_vulnerability_reopened()
RETURNS TRIGGER AS $$
DECLARE
    last_resolver_id UUID;
BEGIN
    -- Only trigger if status changes FROM resolved/closed TO open/in_progress
    IF (OLD.status IN ('resolved', 'closed') AND NEW.status IN ('open', 'in_progress')) THEN

        -- Find who last resolved it (from timeline or resolutions)
        SELECT actor_id INTO last_resolver_id
        FROM vulnerability_timeline
        WHERE vulnerability_id = NEW.id
          AND event_type = 'status_changed'
          AND new_value->>'status' IN ('resolved', 'closed')
        ORDER BY created_at DESC
        LIMIT 1;

        -- If we found a resolver, notify them
        IF last_resolver_id IS NOT NULL THEN
            INSERT INTO user_notifications (
                user_id, notification_type, priority, title, message,
                action_url, vulnerability_id, metadata
            ) VALUES (
                last_resolver_id,
                'vulnerability_reopened',
                'high',
                format('Vulnerability Reopened: %s', SUBSTRING(NEW.title, 1, 100)),
                format('A vulnerability you resolved has been found again during scan'),
                format('/vulnerabilities/%s', NEW.id),
                NEW.id,
                jsonb_build_object(
                    'cve_id', NEW.cve_id,
                    'severity', NEW.severity::TEXT,
                    'hostname', NEW.hostname,
                    'previous_status', OLD.status::TEXT
                )
            );
        END IF;

        -- Also notify currently assigned user/team
        IF NEW.assigned_to IS NOT NULL AND NEW.assigned_to != last_resolver_id THEN
            INSERT INTO user_notifications (
                user_id, notification_type, priority, title, message,
                action_url, vulnerability_id, metadata
            ) VALUES (
                NEW.assigned_to,
                'vulnerability_reopened',
                'high',
                format('Assigned Vulnerability Reopened: %s', SUBSTRING(NEW.title, 1, 100)),
                'A vulnerability assigned to you has been reopened',
                format('/vulnerabilities/%s', NEW.id),
                NEW.id,
                jsonb_build_object(
                    'cve_id', NEW.cve_id,
                    'severity', NEW.severity::TEXT,
                    'hostname', NEW.hostname
                )
            );
        END IF;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Apply triggers
DROP TRIGGER IF EXISTS notify_vuln_assignment_trigger ON vulnerabilities;
CREATE TRIGGER notify_vuln_assignment_trigger
    AFTER UPDATE ON vulnerabilities
    FOR EACH ROW
    EXECUTE FUNCTION notify_vulnerability_assignment();

DROP TRIGGER IF EXISTS notify_vuln_reopened_trigger ON vulnerabilities;
CREATE TRIGGER notify_vuln_reopened_trigger
    AFTER UPDATE ON vulnerabilities
    FOR EACH ROW
    EXECUTE FUNCTION notify_vulnerability_reopened();

-- Function to mark notification as read
CREATE OR REPLACE FUNCTION mark_notification_read(p_notification_id UUID, p_user_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
    UPDATE user_notifications
    SET is_read = TRUE,
        read_at = NOW()
    WHERE id = p_notification_id
      AND user_id = p_user_id
      AND is_read = FALSE;

    RETURN FOUND;
END;
$$ LANGUAGE plpgsql;

-- Function to mark all notifications as read for a user
CREATE OR REPLACE FUNCTION mark_all_notifications_read(p_user_id UUID)
RETURNS INTEGER AS $$
DECLARE
    updated_count INTEGER;
BEGIN
    UPDATE user_notifications
    SET is_read = TRUE,
        read_at = NOW()
    WHERE user_id = p_user_id
      AND is_read = FALSE;

    GET DIAGNOSTICS updated_count = ROW_COUNT;
    RETURN updated_count;
END;
$$ LANGUAGE plpgsql;

-- Function to get unread notification count
CREATE OR REPLACE FUNCTION get_unread_notification_count(p_user_id UUID)
RETURNS INTEGER AS $$
DECLARE
    unread_count INTEGER;
BEGIN
    SELECT COUNT(*)::INTEGER INTO unread_count
    FROM user_notifications
    WHERE user_id = p_user_id
      AND is_read = FALSE
      AND is_dismissed = FALSE
      AND (expires_at IS NULL OR expires_at > NOW());

    RETURN unread_count;
END;
$$ LANGUAGE plpgsql;

-- Auto-delete expired notifications (run periodically via cron/scheduler)
CREATE OR REPLACE FUNCTION cleanup_expired_notifications()
RETURNS INTEGER AS $$
DECLARE
    deleted_count INTEGER;
BEGIN
    DELETE FROM user_notifications
    WHERE expires_at IS NOT NULL
      AND expires_at < NOW();

    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;

-- Comments
COMMENT ON TABLE user_notifications IS 'Persistent in-app notifications for users (bell icon)';
COMMENT ON COLUMN user_notifications.notification_type IS 'Type of notification event';
COMMENT ON COLUMN user_notifications.priority IS 'Display priority: low, normal, high, urgent';
COMMENT ON COLUMN user_notifications.action_url IS 'Link to relevant page when notification is clicked';
COMMENT ON COLUMN user_notifications.is_read IS 'Whether user has read the notification';
COMMENT ON COLUMN user_notifications.expires_at IS 'Auto-delete notification after this timestamp';
COMMENT ON FUNCTION mark_notification_read IS 'Mark a single notification as read';
COMMENT ON FUNCTION mark_all_notifications_read IS 'Mark all notifications as read for a user';
COMMENT ON FUNCTION get_unread_notification_count IS 'Get count of unread notifications for a user';
