-- Migration 012: Device Assignment and Enhanced Tracking
-- Adds assignment, tracking, and prioritization features for network devices

-- ==========================================
-- PART 1: Device Assignment and Metadata
-- ==========================================

-- Add assignment and metadata columns to network_devices
ALTER TABLE network_devices
ADD COLUMN IF NOT EXISTS assigned_user_id UUID REFERENCES users(id) ON DELETE SET NULL,
ADD COLUMN IF NOT EXISTS assigned_team_id UUID REFERENCES teams(id) ON DELETE SET NULL,
ADD COLUMN IF NOT EXISTS owner VARCHAR(255),
ADD COLUMN IF NOT EXISTS location VARCHAR(255),
ADD COLUMN IF NOT EXISTS criticality VARCHAR(50) DEFAULT 'medium' CHECK (criticality IN ('critical', 'high', 'medium', 'low')),
ADD COLUMN IF NOT EXISTS tags TEXT[] DEFAULT '{}',
ADD COLUMN IF NOT EXISTS notes TEXT,
ADD COLUMN IF NOT EXISTS is_internet_facing BOOLEAN DEFAULT false,
ADD COLUMN IF NOT EXISTS has_public_ip BOOLEAN DEFAULT false;

-- Create indexes for better query performance
CREATE INDEX IF NOT EXISTS idx_network_devices_assigned_user ON network_devices(assigned_user_id);
CREATE INDEX IF NOT EXISTS idx_network_devices_assigned_team ON network_devices(assigned_team_id);
CREATE INDEX IF NOT EXISTS idx_network_devices_criticality ON network_devices(criticality);
CREATE INDEX IF NOT EXISTS idx_network_devices_tags ON network_devices USING gin(tags);

-- ==========================================
-- PART 2: Vulnerability Assignment History
-- ==========================================

-- Track all assignment changes for audit purposes
CREATE TABLE IF NOT EXISTS vulnerability_assignment_history (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    vulnerability_id UUID NOT NULL REFERENCES vulnerabilities(id) ON DELETE CASCADE,
    device_id UUID REFERENCES network_devices(id) ON DELETE SET NULL,
    assigned_from_user_id UUID REFERENCES users(id) ON DELETE SET NULL,  -- Who made the assignment
    assigned_to_user_id UUID REFERENCES users(id) ON DELETE SET NULL,     -- Who was assigned
    assigned_to_team_id UUID REFERENCES teams(id) ON DELETE SET NULL,
    action VARCHAR(50) NOT NULL CHECK (action IN ('assigned', 'reassigned', 'unassigned', 'completed', 'escalated')),
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_by UUID REFERENCES users(id) ON DELETE SET NULL
);

CREATE INDEX IF NOT EXISTS idx_vuln_assignment_history_vuln ON vulnerability_assignment_history(vulnerability_id);
CREATE INDEX IF NOT EXISTS idx_vuln_assignment_history_user ON vulnerability_assignment_history(assigned_to_user_id);
CREATE INDEX IF NOT EXISTS idx_vuln_assignment_history_team ON vulnerability_assignment_history(assigned_to_team_id);
CREATE INDEX IF NOT EXISTS idx_vuln_assignment_history_created_at ON vulnerability_assignment_history(created_at DESC);

-- ==========================================
-- PART 3: Remediation Plans
-- ==========================================

-- Create remediation plans for organized vulnerability fixing
CREATE TABLE IF NOT EXISTS remediation_plans (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    created_by UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    assigned_team_id UUID REFERENCES teams(id) ON DELETE SET NULL,
    status VARCHAR(50) NOT NULL DEFAULT 'draft' CHECK (status IN ('draft', 'active', 'in_progress', 'completed', 'cancelled')),
    priority INTEGER NOT NULL DEFAULT 50 CHECK (priority >= 0 AND priority <= 100),
    due_date TIMESTAMPTZ,
    started_at TIMESTAMPTZ,
    completed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Devices in remediation plans with priority order
CREATE TABLE IF NOT EXISTS remediation_plan_devices (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    plan_id UUID NOT NULL REFERENCES remediation_plans(id) ON DELETE CASCADE,
    device_id UUID NOT NULL REFERENCES network_devices(id) ON DELETE CASCADE,
    priority_order INTEGER NOT NULL DEFAULT 0,
    priority_score INTEGER NOT NULL DEFAULT 0 CHECK (priority_score >= 0 AND priority_score <= 100),
    notes TEXT,
    status VARCHAR(50) NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'in_progress', 'completed', 'skipped', 'failed')),
    assigned_user_id UUID REFERENCES users(id) ON DELETE SET NULL,
    started_at TIMESTAMPTZ,
    completed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE(plan_id, device_id)
);

CREATE INDEX IF NOT EXISTS idx_remediation_plans_status ON remediation_plans(status);
CREATE INDEX IF NOT EXISTS idx_remediation_plans_team ON remediation_plans(assigned_team_id);
CREATE INDEX IF NOT EXISTS idx_remediation_plans_created_by ON remediation_plans(created_by);
CREATE INDEX IF NOT EXISTS idx_remediation_plan_devices_plan ON remediation_plan_devices(plan_id);
CREATE INDEX IF NOT EXISTS idx_remediation_plan_devices_device ON remediation_plan_devices(device_id);
CREATE INDEX IF NOT EXISTS idx_remediation_plan_devices_status ON remediation_plan_devices(status);
CREATE INDEX IF NOT EXISTS idx_remediation_plan_devices_user ON remediation_plan_devices(assigned_user_id);

-- ==========================================
-- PART 4: User Remediation Statistics View
-- ==========================================

-- Create view for user workload and statistics
CREATE OR REPLACE VIEW user_remediation_stats AS
SELECT
    u.id as user_id,
    u.username,
    u.email,
    u.role,

    -- Device assignments
    COUNT(DISTINCT nd.id) as assigned_devices,

    -- Vulnerability assignments
    COUNT(DISTINCT v.id) as total_vulnerabilities,
    COUNT(DISTINCT v.id) FILTER (WHERE v.status = 'open') as open_vulnerabilities,
    COUNT(DISTINCT v.id) FILTER (WHERE v.status = 'in_progress') as in_progress_vulnerabilities,
    COUNT(DISTINCT v.id) FILTER (WHERE v.status = 'resolved') as resolved_vulnerabilities,
    COUNT(DISTINCT v.id) FILTER (WHERE v.status = 'closed') as closed_vulnerabilities,

    -- By severity
    COUNT(DISTINCT v.id) FILTER (WHERE v.severity = 'critical') as critical_count,
    COUNT(DISTINCT v.id) FILTER (WHERE v.severity = 'high') as high_count,
    COUNT(DISTINCT v.id) FILTER (WHERE v.severity = 'medium') as medium_count,
    COUNT(DISTINCT v.id) FILTER (WHERE v.severity = 'low') as low_count,

    -- Remediation tasks
    COUNT(DISTINCT rt.id) as total_tasks,
    COUNT(DISTINCT rt.id) FILTER (WHERE rt.status = 'completed') as completed_tasks,
    COUNT(DISTINCT rt.id) FILTER (WHERE rt.status = 'failed') as failed_tasks,

    -- Average resolution time (in hours)
    AVG(EXTRACT(EPOCH FROM (rt.completed_at - rt.started_at))/3600) FILTER (WHERE rt.status = 'completed') as avg_resolution_hours,

    -- Remediation plans
    COUNT(DISTINCT rpd.plan_id) as assigned_plans,
    COUNT(DISTINCT rpd.id) FILTER (WHERE rpd.status = 'completed') as completed_plan_devices,

    -- Last activity
    MAX(GREATEST(
        COALESCE(v.updated_at, '1970-01-01'::timestamptz),
        COALESCE(rt.completed_at, rt.started_at, rt.created_at, '1970-01-01'::timestamptz),
        COALESCE(nd.updated_at, '1970-01-01'::timestamptz)
    )) as last_activity

FROM users u
LEFT JOIN network_devices nd ON nd.assigned_user_id = u.id
LEFT JOIN vulnerabilities v ON v.assigned_user_id = u.id
LEFT JOIN remediation_tasks rt ON rt.created_by = u.id
LEFT JOIN remediation_plan_devices rpd ON rpd.assigned_user_id = u.id
WHERE u.deleted_at IS NULL
GROUP BY u.id, u.username, u.email, u.role;

-- ==========================================
-- PART 5: Team Remediation Statistics View
-- ==========================================

CREATE OR REPLACE VIEW team_remediation_stats AS
SELECT
    t.id as team_id,
    t.name as team_name,
    t.contact_email,

    -- Device assignments
    COUNT(DISTINCT nd.id) as assigned_devices,

    -- Vulnerability assignments
    COUNT(DISTINCT v.id) as total_vulnerabilities,
    COUNT(DISTINCT v.id) FILTER (WHERE v.status = 'open') as open_vulnerabilities,
    COUNT(DISTINCT v.id) FILTER (WHERE v.status = 'in_progress') as in_progress_vulnerabilities,
    COUNT(DISTINCT v.id) FILTER (WHERE v.status = 'resolved') as resolved_vulnerabilities,

    -- By severity
    COUNT(DISTINCT v.id) FILTER (WHERE v.severity = 'critical') as critical_count,
    COUNT(DISTINCT v.id) FILTER (WHERE v.severity = 'high') as high_count,
    COUNT(DISTINCT v.id) FILTER (WHERE v.severity = 'medium') as medium_count,
    COUNT(DISTINCT v.id) FILTER (WHERE v.severity = 'low') as low_count,

    -- Remediation plans
    COUNT(DISTINCT rp.id) as total_plans,
    COUNT(DISTINCT rp.id) FILTER (WHERE rp.status = 'active') as active_plans,
    COUNT(DISTINCT rp.id) FILTER (WHERE rp.status = 'completed') as completed_plans,

    -- Team members
    COUNT(DISTINCT tm.id) as team_members,

    -- Last activity
    MAX(GREATEST(
        COALESCE(v.updated_at, '1970-01-01'::timestamptz),
        COALESCE(nd.updated_at, '1970-01-01'::timestamptz),
        COALESCE(rp.updated_at, '1970-01-01'::timestamptz)
    )) as last_activity

FROM teams t
LEFT JOIN network_devices nd ON nd.assigned_team_id = t.id
LEFT JOIN vulnerabilities v ON v.assigned_team_id = t.id
LEFT JOIN remediation_plans rp ON rp.assigned_team_id = t.id
LEFT JOIN team_members tm ON tm.team_id = t.id
GROUP BY t.id, t.name, t.contact_email;

-- ==========================================
-- PART 6: Update Triggers
-- ==========================================

-- Update remediation_plans updated_at timestamp
CREATE OR REPLACE FUNCTION update_remediation_plan_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_remediation_plans_updated_at
    BEFORE UPDATE ON remediation_plans
    FOR EACH ROW
    EXECUTE FUNCTION update_remediation_plan_updated_at();

CREATE TRIGGER trigger_update_remediation_plan_devices_updated_at
    BEFORE UPDATE ON remediation_plan_devices
    FOR EACH ROW
    EXECUTE FUNCTION update_remediation_plan_updated_at();

-- ==========================================
-- PART 7: Helper Functions
-- ==========================================

-- Function to automatically correlate vulnerabilities with devices
CREATE OR REPLACE FUNCTION correlate_vulnerability_with_device(vuln_id UUID)
RETURNS void AS $$
DECLARE
    vuln_ip INET;
    device_uuid UUID;
BEGIN
    -- Get vulnerability IP
    SELECT ip_address INTO vuln_ip FROM vulnerabilities WHERE id = vuln_id;

    IF vuln_ip IS NOT NULL THEN
        -- Find matching device
        SELECT id INTO device_uuid FROM network_devices WHERE ip_address = vuln_ip LIMIT 1;

        IF device_uuid IS NOT NULL THEN
            -- Insert into device_vulnerabilities if not exists
            INSERT INTO device_vulnerabilities (device_id, vulnerability_id, discovered_at)
            VALUES (device_uuid, vuln_id, NOW())
            ON CONFLICT (device_id, vulnerability_id) DO NOTHING;
        END IF;
    END IF;
END;
$$ LANGUAGE plpgsql;

-- Function to calculate device priority score
CREATE OR REPLACE FUNCTION calculate_device_priority_score(device_uuid UUID)
RETURNS INTEGER AS $$
DECLARE
    score INTEGER := 0;
    critical_count INTEGER;
    high_count INTEGER;
    max_epss REAL;
    device_criticality VARCHAR(50);
    is_internet_facing BOOLEAN;
    is_public BOOLEAN;
BEGIN
    -- Get device metadata
    SELECT criticality, is_internet_facing, has_public_ip
    INTO device_criticality, is_internet_facing, is_public
    FROM network_devices
    WHERE id = device_uuid;

    -- Get vulnerability counts
    SELECT
        COUNT(*) FILTER (WHERE v.severity = 'critical'),
        COUNT(*) FILTER (WHERE v.severity = 'high'),
        MAX(v.epss_score)
    INTO critical_count, high_count, max_epss
    FROM device_vulnerabilities dv
    JOIN vulnerabilities v ON v.id = dv.vulnerability_id
    WHERE dv.device_id = device_uuid
    AND v.status IN ('open', 'in_progress');

    -- Calculate score (0-100)
    -- Critical vulnerabilities: 40 points (10 per critical, max 4)
    score := score + LEAST(COALESCE(critical_count, 0) * 10, 40);

    -- EPSS score: 30 points
    score := score + ROUND(COALESCE(max_epss, 0) * 30);

    -- Device criticality: 20 points
    score := score + CASE device_criticality
        WHEN 'critical' THEN 20
        WHEN 'high' THEN 15
        WHEN 'medium' THEN 10
        WHEN 'low' THEN 5
        ELSE 10
    END;

    -- Exposure: 10 points
    IF is_internet_facing THEN score := score + 5; END IF;
    IF is_public THEN score := score + 5; END IF;

    RETURN LEAST(score, 100);
END;
$$ LANGUAGE plpgsql;

-- ==========================================
-- Comments
-- ==========================================

COMMENT ON TABLE vulnerability_assignment_history IS 'Tracks all assignment changes for vulnerabilities';
COMMENT ON TABLE remediation_plans IS 'Organized plans for fixing multiple device vulnerabilities';
COMMENT ON TABLE remediation_plan_devices IS 'Devices included in remediation plans with priority order';
COMMENT ON VIEW user_remediation_stats IS 'Aggregated statistics per user for workload tracking';
COMMENT ON VIEW team_remediation_stats IS 'Aggregated statistics per team for workload tracking';
COMMENT ON FUNCTION correlate_vulnerability_with_device IS 'Automatically links vulnerabilities to devices by IP address';
COMMENT ON FUNCTION calculate_device_priority_score IS 'Calculates priority score (0-100) based on vulnerabilities and exposure';
