-- Migration 023: Vulnerability Timeline System
-- Tracks all changes and events related to vulnerabilities

CREATE TABLE IF NOT EXISTS vulnerability_timeline (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    vulnerability_id UUID NOT NULL REFERENCES vulnerabilities(id) ON DELETE CASCADE,
    event_type VARCHAR(100) NOT NULL CHECK (event_type IN (
        'discovered', 'status_changed', 'assigned', 'reassigned',
        'comment_added', 'reopened', 'updated', 'scanned', 'remediation_started',
        'remediation_completed', 'verified', 'closed'
    )),

    -- Event details
    old_value JSONB, -- Previous state (for status changes, assignments, etc.)
    new_value JSONB, -- New state
    message TEXT, -- Human-readable message
    metadata JSONB, -- Additional event-specific data

    -- Actor tracking
    actor_type VARCHAR(50) DEFAULT 'user' CHECK (actor_type IN ('user', 'system', 'scanner', 'automation')),
    actor_id UUID REFERENCES users(id) ON DELETE SET NULL, -- NULL for system/scanner actions
    actor_name VARCHAR(255), -- Display name (for deleted users or system actions)

    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_vuln_timeline_vuln_id ON vulnerability_timeline(vulnerability_id);
CREATE INDEX idx_vuln_timeline_created_at ON vulnerability_timeline(created_at DESC);
CREATE INDEX idx_vuln_timeline_event_type ON vulnerability_timeline(event_type);
CREATE INDEX idx_vuln_timeline_actor ON vulnerability_timeline(actor_type, actor_id);

-- Function to automatically create timeline entries on vulnerability changes
CREATE OR REPLACE FUNCTION track_vulnerability_changes()
RETURNS TRIGGER AS $$
BEGIN
    -- Status changed
    IF (TG_OP = 'UPDATE' AND OLD.status IS DISTINCT FROM NEW.status) THEN
        INSERT INTO vulnerability_timeline (
            vulnerability_id, event_type, old_value, new_value,
            message, actor_type, actor_name
        ) VALUES (
            NEW.id,
            'status_changed',
            jsonb_build_object('status', OLD.status::TEXT),
            jsonb_build_object('status', NEW.status::TEXT),
            format('Status changed from %s to %s', OLD.status::TEXT, NEW.status::TEXT),
            'system',
            'System'
        );
    END IF;

    -- Assignment changed
    IF (TG_OP = 'UPDATE' AND (
        OLD.assigned_to IS DISTINCT FROM NEW.assigned_to OR
        OLD.assigned_team_id IS DISTINCT FROM NEW.assigned_team_id
    )) THEN
        INSERT INTO vulnerability_timeline (
            vulnerability_id, event_type, old_value, new_value,
            message, actor_type, actor_name
        ) VALUES (
            NEW.id,
            CASE
                WHEN OLD.assigned_to IS NULL AND NEW.assigned_to IS NOT NULL THEN 'assigned'
                ELSE 'reassigned'
            END,
            jsonb_build_object(
                'assigned_to', OLD.assigned_to,
                'assigned_team_id', OLD.assigned_team_id
            ),
            jsonb_build_object(
                'assigned_to', NEW.assigned_to,
                'assigned_team_id', NEW.assigned_team_id
            ),
            'Assignment changed',
            'system',
            'System'
        );
    END IF;

    -- First discovery
    IF (TG_OP = 'INSERT') THEN
        INSERT INTO vulnerability_timeline (
            vulnerability_id, event_type, new_value,
            message, actor_type, actor_name, metadata
        ) VALUES (
            NEW.id,
            'discovered',
            jsonb_build_object(
                'severity', NEW.severity::TEXT,
                'cvss_score', NEW.cvss_score,
                'source', NEW.source
            ),
            format('Vulnerability discovered via %s', NEW.source),
            'scanner',
            NEW.source,
            jsonb_build_object(
                'cve_id', NEW.cve_id,
                'hostname', NEW.hostname,
                'ip_address', NEW.ip_address::TEXT
            )
        );
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Apply trigger to vulnerabilities table
DROP TRIGGER IF EXISTS vulnerability_changes_trigger ON vulnerabilities;
CREATE TRIGGER vulnerability_changes_trigger
    AFTER INSERT OR UPDATE ON vulnerabilities
    FOR EACH ROW
    EXECUTE FUNCTION track_vulnerability_changes();

-- Comments
COMMENT ON TABLE vulnerability_timeline IS 'Timeline of all events and changes for vulnerabilities';
COMMENT ON COLUMN vulnerability_timeline.event_type IS 'Type of event: discovered, status_changed, assigned, etc.';
COMMENT ON COLUMN vulnerability_timeline.old_value IS 'Previous state (JSONB) for comparison';
COMMENT ON COLUMN vulnerability_timeline.new_value IS 'New state (JSONB) after the event';
COMMENT ON COLUMN vulnerability_timeline.actor_type IS 'Who/what triggered the event: user, system, scanner, automation';
