-- Migration 106: Add timeline helper functions and additional features
-- Support functions for manual timeline entries and optimizations

-- Function to manually add timeline entry (for comments, manual actions, etc.)
CREATE OR REPLACE FUNCTION add_timeline_entry(
    p_vulnerability_id UUID,
    p_event_type VARCHAR(50),
    p_message TEXT,
    p_actor_id UUID DEFAULT NULL,
    p_actor_name VARCHAR(255) DEFAULT NULL,
    p_old_value JSONB DEFAULT NULL,
    p_new_value JSONB DEFAULT NULL,
    p_metadata JSONB DEFAULT NULL
)
RETURNS UUID AS $$
DECLARE
    entry_id UUID;
    resolved_actor_name VARCHAR(255);
BEGIN
    -- If actor_id provided but no actor_name, fetch from users table
    IF p_actor_id IS NOT NULL AND p_actor_name IS NULL THEN
        SELECT username INTO resolved_actor_name
        FROM users
        WHERE id = p_actor_id;
    ELSE
        resolved_actor_name := p_actor_name;
    END IF;

    -- Insert timeline entry
    INSERT INTO vulnerability_timeline (
        vulnerability_id,
        event_type,
        message,
        actor_type,
        actor_id,
        actor_name,
        old_value,
        new_value,
        metadata
    ) VALUES (
        p_vulnerability_id,
        p_event_type,
        p_message,
        CASE
            WHEN p_actor_id IS NULL THEN 'system'
            ELSE 'user'
        END,
        p_actor_id,
        resolved_actor_name,
        p_old_value,
        p_new_value,
        p_metadata
    ) RETURNING id INTO entry_id;

    RETURN entry_id;
END;
$$ LANGUAGE plpgsql;

-- Function to get timeline for a vulnerability
CREATE OR REPLACE FUNCTION get_vulnerability_timeline(
    p_vulnerability_id UUID,
    p_limit INTEGER DEFAULT 50,
    p_offset INTEGER DEFAULT 0
)
RETURNS TABLE (
    id UUID,
    event_type VARCHAR(50),
    old_value JSONB,
    new_value JSONB,
    message TEXT,
    metadata JSONB,
    actor_type VARCHAR(20),
    actor_id UUID,
    actor_name VARCHAR(255),
    created_at TIMESTAMPTZ
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        vt.id,
        vt.event_type,
        vt.old_value,
        vt.new_value,
        vt.message,
        vt.metadata,
        vt.actor_type,
        vt.actor_id,
        vt.actor_name,
        vt.created_at
    FROM vulnerability_timeline vt
    WHERE vt.vulnerability_id = p_vulnerability_id
    ORDER BY vt.created_at DESC
    LIMIT p_limit
    OFFSET p_offset;
END;
$$ LANGUAGE plpgsql STABLE;

-- Function to get timeline count for a vulnerability
CREATE OR REPLACE FUNCTION get_vulnerability_timeline_count(
    p_vulnerability_id UUID
)
RETURNS INTEGER AS $$
BEGIN
    RETURN (
        SELECT COUNT(*)::INTEGER
        FROM vulnerability_timeline
        WHERE vulnerability_id = p_vulnerability_id
    );
END;
$$ LANGUAGE plpgsql STABLE;

-- View for recent activity across all vulnerabilities (for dashboard)
CREATE OR REPLACE VIEW recent_vulnerability_activity AS
SELECT
    vt.id,
    vt.vulnerability_id,
    v.title as vulnerability_title,
    v.severity,
    v.status,
    vt.event_type,
    vt.message,
    vt.actor_type,
    vt.actor_id,
    vt.actor_name,
    vt.created_at
FROM vulnerability_timeline vt
JOIN vulnerabilities v ON vt.vulnerability_id = v.id
WHERE v.deleted_at IS NULL
ORDER BY vt.created_at DESC
LIMIT 100;

-- Add index for better performance on timeline queries by event type
CREATE INDEX IF NOT EXISTS idx_timeline_vulnerability_event
    ON vulnerability_timeline(vulnerability_id, event_type, created_at DESC);

-- Add composite index for actor queries
CREATE INDEX IF NOT EXISTS idx_timeline_actor_created
    ON vulnerability_timeline(actor_id, created_at DESC)
    WHERE actor_id IS NOT NULL;

-- Trigger to create timeline entry when vulnerability is resolved
CREATE OR REPLACE FUNCTION track_vulnerability_resolution()
RETURNS TRIGGER AS $$
BEGIN
    -- Only track when status changes to resolved or closed
    IF NEW.status IN ('resolved', 'closed')
       AND OLD.status NOT IN ('resolved', 'closed') THEN

        INSERT INTO vulnerability_timeline (
            vulnerability_id,
            event_type,
            old_value,
            new_value,
            message,
            actor_type,
            metadata
        ) VALUES (
            NEW.id,
            'resolved',
            jsonb_build_object('status', OLD.status),
            jsonb_build_object(
                'status', NEW.status,
                'resolved_at', NOW()
            ),
            format('Vulnerabilità risolta: %s → %s', OLD.status, NEW.status),
            'system',
            jsonb_build_object(
                'previous_status', OLD.status,
                'resolution_status', NEW.status
            )
        );
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add resolution tracking trigger
CREATE TRIGGER vulnerability_resolution_trigger
    AFTER UPDATE ON vulnerabilities
    FOR EACH ROW
    WHEN (NEW.status IN ('resolved', 'closed'))
    EXECUTE FUNCTION track_vulnerability_resolution();

-- Materialized view for notification statistics (can be refreshed periodically)
CREATE MATERIALIZED VIEW IF NOT EXISTS notification_stats_by_user AS
SELECT
    user_id,
    COUNT(*) as total_notifications,
    COUNT(*) FILTER (WHERE is_read = FALSE) as unread_count,
    COUNT(*) FILTER (WHERE priority = 'urgent') as urgent_count,
    COUNT(*) FILTER (WHERE priority = 'high') as high_count,
    COUNT(*) FILTER (WHERE created_at > NOW() - INTERVAL '24 hours') as notifications_24h,
    COUNT(*) FILTER (WHERE created_at > NOW() - INTERVAL '7 days') as notifications_7d,
    MAX(created_at) as last_notification_at
FROM user_notifications
WHERE is_dismissed = FALSE
GROUP BY user_id;

-- Index for materialized view
CREATE UNIQUE INDEX IF NOT EXISTS idx_notification_stats_user
    ON notification_stats_by_user(user_id);

-- Function to refresh notification stats (can be called via cron)
CREATE OR REPLACE FUNCTION refresh_notification_stats()
RETURNS VOID AS $$
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY notification_stats_by_user;
END;
$$ LANGUAGE plpgsql;

-- Enhanced function to create notification with auto-priority detection
CREATE OR REPLACE FUNCTION create_notification(
    p_user_id UUID,
    p_notification_type notification_type,
    p_title VARCHAR(255),
    p_message TEXT,
    p_vulnerability_id UUID DEFAULT NULL,
    p_team_id UUID DEFAULT NULL,
    p_related_user_id UUID DEFAULT NULL,
    p_actor_name VARCHAR(255) DEFAULT NULL,
    p_metadata JSONB DEFAULT NULL,
    p_action_url VARCHAR(500) DEFAULT NULL,
    p_priority notification_priority DEFAULT NULL
)
RETURNS UUID AS $$
DECLARE
    notification_id UUID;
    auto_priority notification_priority;
    vuln_severity VARCHAR(20);
BEGIN
    -- Auto-detect priority from vulnerability severity if not provided
    IF p_priority IS NULL AND p_vulnerability_id IS NOT NULL THEN
        SELECT severity INTO vuln_severity
        FROM vulnerabilities
        WHERE id = p_vulnerability_id;

        auto_priority := CASE
            WHEN vuln_severity = 'critical' THEN 'urgent'::notification_priority
            WHEN vuln_severity = 'high' THEN 'high'::notification_priority
            WHEN vuln_severity = 'medium' THEN 'medium'::notification_priority
            ELSE 'low'::notification_priority
        END;
    ELSE
        auto_priority := COALESCE(p_priority, 'medium'::notification_priority);
    END IF;

    -- Insert notification
    INSERT INTO user_notifications (
        user_id,
        notification_type,
        priority,
        title,
        message,
        vulnerability_id,
        team_id,
        related_user_id,
        actor_name,
        metadata,
        action_url
    ) VALUES (
        p_user_id,
        p_notification_type,
        auto_priority,
        p_title,
        p_message,
        p_vulnerability_id,
        p_team_id,
        p_related_user_id,
        p_actor_name,
        p_metadata,
        p_action_url
    ) RETURNING id INTO notification_id;

    RETURN notification_id;
END;
$$ LANGUAGE plpgsql;

-- Comments
COMMENT ON FUNCTION add_timeline_entry IS 'Manually add a timeline entry (for comments, custom actions, etc.)';
COMMENT ON FUNCTION get_vulnerability_timeline IS 'Get paginated timeline entries for a vulnerability';
COMMENT ON FUNCTION create_notification IS 'Create a notification with automatic priority detection from vulnerability severity';
COMMENT ON VIEW recent_vulnerability_activity IS 'Recent activity across all vulnerabilities for dashboard display';
COMMENT ON MATERIALIZED VIEW notification_stats_by_user IS 'Aggregated notification statistics per user (refresh periodically)';
