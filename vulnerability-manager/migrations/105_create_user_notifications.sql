-- Migration 105: Create user_notifications table
-- Persistent notifications system for the notification bell

CREATE TYPE IF NOT EXISTS notification_priority AS ENUM ('low', 'medium', 'high', 'urgent');

CREATE TYPE IF NOT EXISTS notification_type AS ENUM (
    'vulnerability_assigned',
    'vulnerability_reopened',
    'vulnerability_resolved',
    'vulnerability_comment',
    'team_assigned',
    'mention',
    'system_alert',
    'auto_assignment'
);

CREATE TABLE IF NOT EXISTS user_notifications (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,

    -- Notification content
    notification_type notification_type NOT NULL,
    priority notification_priority NOT NULL DEFAULT 'medium',
    title VARCHAR(255) NOT NULL,
    message TEXT NOT NULL,
    action_url VARCHAR(500),  -- Optional URL to navigate to (e.g., /vulnerabilities/:id)
    actor_name VARCHAR(255),  -- Name of person who triggered the action

    -- Related entities
    vulnerability_id UUID REFERENCES vulnerabilities(id) ON DELETE CASCADE,
    team_id UUID REFERENCES teams(id) ON DELETE SET NULL,
    related_user_id UUID REFERENCES users(id) ON DELETE SET NULL,  -- User who triggered the action

    -- Metadata
    metadata JSONB,  -- Additional context (e.g., old_status, new_status for reopened vulns)

    -- State
    is_read BOOLEAN NOT NULL DEFAULT FALSE,
    read_at TIMESTAMPTZ,
    is_dismissed BOOLEAN NOT NULL DEFAULT FALSE,
    dismissed_at TIMESTAMPTZ,

    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    expires_at TIMESTAMPTZ  -- Optional expiration for temporary notifications
);

-- Indexes for fast querying
CREATE INDEX idx_notifications_user_unread ON user_notifications(user_id, is_read, created_at DESC)
    WHERE is_read = FALSE;
CREATE INDEX idx_notifications_user_all ON user_notifications(user_id, created_at DESC);
CREATE INDEX idx_notifications_type ON user_notifications(notification_type);
CREATE INDEX idx_notifications_vulnerability ON user_notifications(vulnerability_id);
CREATE INDEX idx_notifications_expires ON user_notifications(expires_at)
    WHERE expires_at IS NOT NULL;

-- Function to create notification when vulnerability is assigned to user
CREATE OR REPLACE FUNCTION notify_vulnerability_assigned()
RETURNS TRIGGER AS $$
BEGIN
    -- Notify assigned user
    IF NEW.assigned_user_id IS NOT NULL
       AND (OLD.assigned_user_id IS NULL OR OLD.assigned_user_id != NEW.assigned_user_id) THEN
        INSERT INTO user_notifications (
            user_id,
            notification_type,
            priority,
            title,
            message,
            action_url,
            vulnerability_id,
            metadata
        ) VALUES (
            NEW.assigned_user_id,
            'vulnerability_assigned',
            CASE
                WHEN NEW.severity = 'critical' THEN 'urgent'::notification_priority
                WHEN NEW.severity = 'high' THEN 'high'::notification_priority
                ELSE 'medium'::notification_priority
            END,
            'Nuova vulnerabilità assegnata',
            format('Ti è stata assegnata la vulnerabilità: %s (CVSS: %s)', NEW.title, NEW.cvss_score),
            format('/vulnerabilities/%s', NEW.id),
            NEW.id,
            jsonb_build_object(
                'severity', NEW.severity,
                'cvss_score', NEW.cvss_score,
                'status', NEW.status
            )
        );
    END IF;

    -- Notify team members when assigned to team
    IF NEW.assigned_team_id IS NOT NULL
       AND (OLD.assigned_team_id IS NULL OR OLD.assigned_team_id != NEW.assigned_team_id) THEN
        -- Insert notification for all team members
        INSERT INTO user_notifications (
            user_id,
            notification_type,
            priority,
            title,
            message,
            action_url,
            vulnerability_id,
            team_id,
            metadata
        )
        SELECT
            tm.user_id,
            'team_assigned',
            CASE
                WHEN NEW.severity = 'critical' THEN 'urgent'::notification_priority
                WHEN NEW.severity = 'high' THEN 'high'::notification_priority
                ELSE 'medium'::notification_priority
            END,
            'Vulnerabilità assegnata al team',
            format('Il tuo team ha ricevuto: %s (CVSS: %s)', NEW.title, NEW.cvss_score),
            format('/vulnerabilities/%s', NEW.id),
            NEW.id,
            NEW.assigned_team_id,
            jsonb_build_object(
                'severity', NEW.severity,
                'cvss_score', NEW.cvss_score,
                'status', NEW.status
            )
        FROM team_members tm
        WHERE tm.team_id = NEW.assigned_team_id
          AND tm.removed_at IS NULL
          AND tm.user_id IS NOT NULL;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Function to notify when vulnerability is reopened
CREATE OR REPLACE FUNCTION notify_vulnerability_reopened()
RETURNS TRIGGER AS $$
DECLARE
    previous_resolver_id UUID;
BEGIN
    -- Only if status changed from resolved/closed back to open/in_progress
    IF OLD.status IN ('resolved', 'closed')
       AND NEW.status IN ('open', 'in_progress') THEN

        -- Find who resolved it last (from timeline)
        SELECT actor_id INTO previous_resolver_id
        FROM vulnerability_timeline
        WHERE vulnerability_id = NEW.id
          AND event_type = 'status_changed'
          AND new_value->>'status' IN ('resolved', 'closed')
          AND actor_id IS NOT NULL
        ORDER BY created_at DESC
        LIMIT 1;

        -- Notify the person who resolved it
        IF previous_resolver_id IS NOT NULL THEN
            INSERT INTO user_notifications (
                user_id,
                notification_type,
                priority,
                title,
                message,
                action_url,
                vulnerability_id,
                metadata
            ) VALUES (
                previous_resolver_id,
                'vulnerability_reopened',
                CASE
                    WHEN NEW.severity = 'critical' THEN 'urgent'::notification_priority
                    WHEN NEW.severity = 'high' THEN 'high'::notification_priority
                    ELSE 'medium'::notification_priority
                END,
                'Vulnerabilità riaperta',
                format('La vulnerabilità "%s" che hai risolto è stata ritrovata', NEW.title),
                format('/vulnerabilities/%s', NEW.id),
                NEW.id,
                jsonb_build_object(
                    'old_status', OLD.status,
                    'new_status', NEW.status,
                    'severity', NEW.severity,
                    'cvss_score', NEW.cvss_score
                )
            );
        END IF;

        -- Also notify current assignee if different
        IF NEW.assigned_user_id IS NOT NULL
           AND NEW.assigned_user_id != previous_resolver_id THEN
            INSERT INTO user_notifications (
                user_id,
                notification_type,
                priority,
                title,
                message,
                action_url,
                vulnerability_id,
                metadata
            ) VALUES (
                NEW.assigned_user_id,
                'vulnerability_reopened',
                CASE
                    WHEN NEW.severity = 'critical' THEN 'urgent'::notification_priority
                    WHEN NEW.severity = 'high' THEN 'high'::notification_priority
                    ELSE 'medium'::notification_priority
                END,
                'Vulnerabilità riaperta',
                format('La vulnerabilità assegnata "%s" è stata riaperta', NEW.title),
                format('/vulnerabilities/%s', NEW.id),
                NEW.id,
                jsonb_build_object(
                    'old_status', OLD.status,
                    'new_status', NEW.status,
                    'severity', NEW.severity
                )
            );
        END IF;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Triggers
CREATE TRIGGER notify_on_assignment_trigger
    AFTER UPDATE ON vulnerabilities
    FOR EACH ROW
    EXECUTE FUNCTION notify_vulnerability_assigned();

CREATE TRIGGER notify_on_reopen_trigger
    AFTER UPDATE ON vulnerabilities
    FOR EACH ROW
    EXECUTE FUNCTION notify_vulnerability_reopened();

-- Function to clean up expired notifications (run via cron)
CREATE OR REPLACE FUNCTION cleanup_expired_notifications()
RETURNS INTEGER AS $$
DECLARE
    deleted_count INTEGER;
BEGIN
    DELETE FROM user_notifications
    WHERE expires_at IS NOT NULL
      AND expires_at < NOW();

    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;

-- Helper functions for notifications
CREATE OR REPLACE FUNCTION get_unread_notification_count(p_user_id UUID)
RETURNS INTEGER AS $$
BEGIN
    RETURN (
        SELECT COUNT(*)::INTEGER
        FROM user_notifications
        WHERE user_id = p_user_id
          AND is_read = FALSE
          AND is_dismissed = FALSE
          AND (expires_at IS NULL OR expires_at > NOW())
    );
END;
$$ LANGUAGE plpgsql STABLE;

CREATE OR REPLACE FUNCTION mark_notification_read(p_notification_id UUID, p_user_id UUID)
RETURNS BOOLEAN AS $$
DECLARE
    affected_rows INTEGER;
BEGIN
    UPDATE user_notifications
    SET is_read = TRUE,
        read_at = NOW()
    WHERE id = p_notification_id
      AND user_id = p_user_id
      AND is_read = FALSE;

    GET DIAGNOSTICS affected_rows = ROW_COUNT;
    RETURN affected_rows > 0;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION mark_all_notifications_read(p_user_id UUID)
RETURNS INTEGER AS $$
DECLARE
    affected_rows INTEGER;
BEGIN
    UPDATE user_notifications
    SET is_read = TRUE,
        read_at = NOW()
    WHERE user_id = p_user_id
      AND is_read = FALSE;

    GET DIAGNOSTICS affected_rows = ROW_COUNT;
    RETURN affected_rows;
END;
$$ LANGUAGE plpgsql;

-- Comments
COMMENT ON TABLE user_notifications IS 'Persistent notifications for users (notification bell system)';
COMMENT ON COLUMN user_notifications.notification_type IS 'Type of notification for filtering and display';
COMMENT ON COLUMN user_notifications.priority IS 'Priority level: low, medium, high, urgent';
COMMENT ON COLUMN user_notifications.action_url IS 'Optional URL to navigate to when clicking notification';
COMMENT ON COLUMN user_notifications.metadata IS 'Additional context like severity, old/new status for reopened vulns';
COMMENT ON COLUMN user_notifications.is_dismissed IS 'Soft delete flag - dismissed notifications are hidden from list';
COMMENT ON COLUMN user_notifications.expires_at IS 'Optional expiration date for temporary notifications';
