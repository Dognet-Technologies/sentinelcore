-- Migration 014: Comments System
-- Implements team collaboration through comments on vulnerabilities

-- Vulnerability comments table
CREATE TABLE IF NOT EXISTS vulnerability_comments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    vulnerability_id UUID NOT NULL REFERENCES vulnerabilities(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    comment_text TEXT NOT NULL,
    parent_comment_id UUID REFERENCES vulnerability_comments(id) ON DELETE CASCADE, -- For threading/replies
    mentions JSON DEFAULT '[]'::JSON, -- Array of mentioned user IDs: ["uuid1", "uuid2"]
    attachments JSON DEFAULT '[]'::JSON, -- Array of attachment metadata
    is_internal BOOLEAN DEFAULT TRUE, -- Internal team comment vs customer-visible
    is_edited BOOLEAN DEFAULT FALSE,
    edited_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMPTZ
);

-- Indexes
CREATE INDEX idx_vuln_comments_vulnerability ON vulnerability_comments(vulnerability_id, created_at DESC);
CREATE INDEX idx_vuln_comments_user ON vulnerability_comments(user_id);
CREATE INDEX idx_vuln_comments_parent ON vulnerability_comments(parent_comment_id) WHERE parent_comment_id IS NOT NULL;
CREATE INDEX idx_vuln_comments_deleted ON vulnerability_comments(deleted_at) WHERE deleted_at IS NULL;

-- Asset comments (for device-specific notes)
CREATE TABLE IF NOT EXISTS asset_comments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    asset_id UUID NOT NULL REFERENCES assets(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    comment_text TEXT NOT NULL,
    parent_comment_id UUID REFERENCES asset_comments(id) ON DELETE CASCADE,
    mentions JSON DEFAULT '[]'::JSON,
    attachments JSON DEFAULT '[]'::JSON,
    is_internal BOOLEAN DEFAULT TRUE,
    is_edited BOOLEAN DEFAULT FALSE,
    edited_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMPTZ
);

-- Indexes for asset comments
CREATE INDEX idx_asset_comments_asset ON asset_comments(asset_id, created_at DESC);
CREATE INDEX idx_asset_comments_user ON asset_comments(user_id);
CREATE INDEX idx_asset_comments_parent ON asset_comments(parent_comment_id) WHERE parent_comment_id IS NOT NULL;

-- Remediation plan comments (for task discussions)
CREATE TABLE IF NOT EXISTS remediation_comments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    remediation_plan_id UUID NOT NULL REFERENCES remediation_plans(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    comment_text TEXT NOT NULL,
    parent_comment_id UUID REFERENCES remediation_comments(id) ON DELETE CASCADE,
    mentions JSON DEFAULT '[]'::JSON,
    attachments JSON DEFAULT '[]'::JSON,
    is_edited BOOLEAN DEFAULT FALSE,
    edited_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMPTZ
);

-- Indexes for remediation comments
CREATE INDEX idx_remediation_comments_plan ON remediation_comments(remediation_plan_id, created_at DESC);
CREATE INDEX idx_remediation_comments_user ON remediation_comments(user_id);

-- Function: Extract @mentions from comment text
-- Finds @username patterns and returns array of user IDs
CREATE OR REPLACE FUNCTION extract_mentions(comment_text TEXT)
RETURNS JSON AS $$
DECLARE
    mention_pattern TEXT := '@\w+';
    mentioned_users JSON;
BEGIN
    SELECT json_agg(DISTINCT u.id)
    INTO mentioned_users
    FROM regexp_matches(comment_text, mention_pattern, 'g') AS m(username),
         users u
    WHERE LOWER(u.username) = LOWER(REPLACE(m.username, '@', ''));

    RETURN COALESCE(mentioned_users, '[]'::JSON);
END;
$$ LANGUAGE plpgsql;

-- Trigger: Auto-extract mentions on insert/update
CREATE OR REPLACE FUNCTION trigger_extract_mentions()
RETURNS TRIGGER AS $$
BEGIN
    NEW.mentions := extract_mentions(NEW.comment_text);
    NEW.updated_at := NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Apply mention extraction trigger to all comment tables
DROP TRIGGER IF EXISTS trigger_vuln_comment_mentions ON vulnerability_comments;
CREATE TRIGGER trigger_vuln_comment_mentions
    BEFORE INSERT OR UPDATE OF comment_text
    ON vulnerability_comments
    FOR EACH ROW
    EXECUTE FUNCTION trigger_extract_mentions();

DROP TRIGGER IF EXISTS trigger_asset_comment_mentions ON asset_comments;
CREATE TRIGGER trigger_asset_comment_mentions
    BEFORE INSERT OR UPDATE OF comment_text
    ON asset_comments
    FOR EACH ROW
    EXECUTE FUNCTION trigger_extract_mentions();

DROP TRIGGER IF EXISTS trigger_remediation_comment_mentions ON remediation_comments;
CREATE TRIGGER trigger_remediation_comment_mentions
    BEFORE INSERT OR UPDATE OF comment_text
    ON remediation_comments
    FOR EACH ROW
    EXECUTE FUNCTION trigger_extract_mentions();

-- Function: Get comment thread (comment + all replies)
CREATE OR REPLACE FUNCTION get_comment_thread(p_comment_id UUID)
RETURNS TABLE (
    id UUID,
    parent_comment_id UUID,
    user_id UUID,
    username VARCHAR,
    comment_text TEXT,
    mentions JSON,
    depth INTEGER,
    created_at TIMESTAMPTZ
) AS $$
BEGIN
    RETURN QUERY
    WITH RECURSIVE comment_tree AS (
        -- Root comment
        SELECT
            vc.id,
            vc.parent_comment_id,
            vc.user_id,
            u.username,
            vc.comment_text,
            vc.mentions,
            0 as depth,
            vc.created_at
        FROM vulnerability_comments vc
        JOIN users u ON u.id = vc.user_id
        WHERE vc.id = p_comment_id
          AND vc.deleted_at IS NULL

        UNION ALL

        -- Replies
        SELECT
            vc.id,
            vc.parent_comment_id,
            vc.user_id,
            u.username,
            vc.comment_text,
            vc.mentions,
            ct.depth + 1,
            vc.created_at
        FROM vulnerability_comments vc
        JOIN users u ON u.id = vc.user_id
        JOIN comment_tree ct ON vc.parent_comment_id = ct.id
        WHERE vc.deleted_at IS NULL
    )
    SELECT * FROM comment_tree
    ORDER BY depth, created_at;
END;
$$ LANGUAGE plpgsql;

-- Function: Get user's mentions (for "My Mentions" notification feed)
CREATE OR REPLACE FUNCTION get_user_mentions(p_user_id UUID, p_limit INTEGER DEFAULT 50)
RETURNS TABLE (
    comment_id UUID,
    comment_type VARCHAR,
    entity_id UUID,
    entity_title TEXT,
    commenter_id UUID,
    commenter_username VARCHAR,
    comment_text TEXT,
    created_at TIMESTAMPTZ
) AS $$
BEGIN
    RETURN QUERY
    -- Vulnerability comments
    SELECT
        vc.id as comment_id,
        'vulnerability'::VARCHAR as comment_type,
        v.id as entity_id,
        v.title::TEXT as entity_title,
        u.id as commenter_id,
        u.username as commenter_username,
        vc.comment_text,
        vc.created_at
    FROM vulnerability_comments vc
    JOIN users u ON u.id = vc.user_id
    JOIN vulnerabilities v ON v.id = vc.vulnerability_id
    WHERE vc.mentions::jsonb ? p_user_id::TEXT
      AND vc.deleted_at IS NULL
      AND vc.user_id != p_user_id  -- Don't show self-mentions

    UNION ALL

    -- Asset comments
    SELECT
        ac.id,
        'asset'::VARCHAR,
        a.id,
        COALESCE(a.hostname, host(a.ip_address)::TEXT) as entity_title,
        u.id,
        u.username,
        ac.comment_text,
        ac.created_at
    FROM asset_comments ac
    JOIN users u ON u.id = ac.user_id
    JOIN assets a ON a.id = ac.asset_id
    WHERE ac.mentions::jsonb ? p_user_id::TEXT
      AND ac.deleted_at IS NULL
      AND ac.user_id != p_user_id

    ORDER BY created_at DESC
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;

-- Function: Soft delete comment
CREATE OR REPLACE FUNCTION soft_delete_comment(
    p_comment_id UUID,
    p_user_id UUID,
    p_comment_type VARCHAR DEFAULT 'vulnerability'
) RETURNS BOOLEAN AS $$
DECLARE
    v_row_count INTEGER;
BEGIN
    -- Only allow deletion by comment author or admins
    IF p_comment_type = 'vulnerability' THEN
        UPDATE vulnerability_comments
        SET deleted_at = NOW()
        WHERE id = p_comment_id
          AND (user_id = p_user_id OR EXISTS (
              SELECT 1 FROM users WHERE id = p_user_id AND role = 'admin'
          ));
        GET DIAGNOSTICS v_row_count = ROW_COUNT;
        RETURN v_row_count > 0;

    ELSIF p_comment_type = 'asset' THEN
        UPDATE asset_comments
        SET deleted_at = NOW()
        WHERE id = p_comment_id
          AND (user_id = p_user_id OR EXISTS (
              SELECT 1 FROM users WHERE id = p_user_id AND role = 'admin'
          ));
        GET DIAGNOSTICS v_row_count = ROW_COUNT;
        RETURN v_row_count > 0;

    ELSIF p_comment_type = 'remediation' THEN
        UPDATE remediation_comments
        SET deleted_at = NOW()
        WHERE id = p_comment_id
          AND (user_id = p_user_id OR EXISTS (
              SELECT 1 FROM users WHERE id = p_user_id AND role = 'admin'
          ));
        GET DIAGNOSTICS v_row_count = ROW_COUNT;
        RETURN v_row_count > 0;
    END IF;

    RETURN FALSE;
END;
$$ LANGUAGE plpgsql;

-- Comments
COMMENT ON TABLE vulnerability_comments IS 'Team collaboration comments on vulnerabilities with @mentions and threading';
COMMENT ON TABLE asset_comments IS 'Team collaboration comments on assets/devices';
COMMENT ON TABLE remediation_comments IS 'Team collaboration comments on remediation plans';
COMMENT ON COLUMN vulnerability_comments.mentions IS 'Array of mentioned user IDs extracted from @username patterns';
COMMENT ON COLUMN vulnerability_comments.attachments IS 'JSON array of attachment metadata {name, url, size, type}';
COMMENT ON COLUMN vulnerability_comments.is_internal IS 'Internal team comment vs customer-visible';
COMMENT ON FUNCTION extract_mentions IS 'Auto-extracts @mentions from comment text and returns user IDs';
COMMENT ON FUNCTION get_comment_thread IS 'Returns comment and all nested replies in tree structure';
COMMENT ON FUNCTION get_user_mentions IS 'Returns all comments where user was @mentioned (for notification feed)';
