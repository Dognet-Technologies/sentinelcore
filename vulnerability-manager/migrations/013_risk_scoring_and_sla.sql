-- Migration 013: Risk Scoring & SLA Automation
-- Implements intelligent risk scoring algorithm and automatic SLA deadline calculation

-- Add risk scoring columns to vulnerabilities table
ALTER TABLE vulnerabilities ADD COLUMN IF NOT EXISTS risk_score INTEGER DEFAULT 0 CHECK (risk_score >= 0 AND risk_score <= 100);
ALTER TABLE vulnerabilities ADD COLUMN IF NOT EXISTS risk_tier VARCHAR(20) DEFAULT 'Info' CHECK (risk_tier IN ('Critical', 'High', 'Medium', 'Low', 'Info'));
ALTER TABLE vulnerabilities ADD COLUMN IF NOT EXISTS sla_deadline TIMESTAMPTZ;
ALTER TABLE vulnerabilities ADD COLUMN IF NOT EXISTS sla_days INTEGER DEFAULT 0;
ALTER TABLE vulnerabilities ADD COLUMN IF NOT EXISTS sla_breached BOOLEAN DEFAULT FALSE;

-- Add component scores for transparency
ALTER TABLE vulnerabilities ADD COLUMN IF NOT EXISTS cvss_component REAL DEFAULT 0;
ALTER TABLE vulnerabilities ADD COLUMN IF NOT EXISTS epss_component REAL DEFAULT 0;
ALTER TABLE vulnerabilities ADD COLUMN IF NOT EXISTS business_component REAL DEFAULT 0;
ALTER TABLE vulnerabilities ADD COLUMN IF NOT EXISTS exposure_component REAL DEFAULT 0;
ALTER TABLE vulnerabilities ADD COLUMN IF NOT EXISTS exploit_component REAL DEFAULT 0;

-- Add business impact fields
ALTER TABLE assets ADD COLUMN IF NOT EXISTS criticality VARCHAR(20) DEFAULT 'Medium' CHECK (criticality IN ('Critical', 'High', 'Medium', 'Low'));
ALTER TABLE assets ADD COLUMN IF NOT EXISTS has_sensitive_data BOOLEAN DEFAULT FALSE;
ALTER TABLE assets ADD COLUMN IF NOT EXISTS revenue_impact_per_hour REAL DEFAULT 0;
ALTER TABLE assets ADD COLUMN IF NOT EXISTS network_zone VARCHAR(50);

-- Add exploit intelligence fields to vulnerabilities
ALTER TABLE vulnerabilities ADD COLUMN IF NOT EXISTS exploit_status VARCHAR(50) DEFAULT 'NoExploit';
ALTER TABLE vulnerabilities ADD COLUMN IF NOT EXISTS has_metasploit BOOLEAN DEFAULT FALSE;
ALTER TABLE vulnerabilities ADD COLUMN IF NOT EXISTS has_exploit_db BOOLEAN DEFAULT FALSE;
ALTER TABLE vulnerabilities ADD COLUMN IF NOT EXISTS in_active_campaigns BOOLEAN DEFAULT FALSE;
ALTER TABLE vulnerabilities ADD COLUMN IF NOT EXISTS is_zero_day BOOLEAN DEFAULT FALSE;
ALTER TABLE vulnerabilities ADD COLUMN IF NOT EXISTS is_ransomware_targeted BOOLEAN DEFAULT FALSE;
ALTER TABLE vulnerabilities ADD COLUMN IF NOT EXISTS in_cisa_kev BOOLEAN DEFAULT FALSE;

-- Add remediation effort estimation
ALTER TABLE vulnerabilities ADD COLUMN IF NOT EXISTS remediation_effort VARCHAR(20) DEFAULT 'Medium';
ALTER TABLE vulnerabilities ADD COLUMN IF NOT EXISTS estimated_hours INTEGER DEFAULT 24;

-- Function: Calculate risk score for vulnerability
-- Implements formula: (CVSS×0.30) + (EPSS×0.25) + (Business×0.25) + (Exposure×0.15) + (Exploit×0.05)
CREATE OR REPLACE FUNCTION calculate_risk_score(
    p_cvss_score REAL,
    p_epss_score REAL,
    p_asset_criticality VARCHAR(20),
    p_has_sensitive_data BOOLEAN,
    p_revenue_impact REAL,
    p_network_zone VARCHAR(50),
    p_is_public_ip BOOLEAN,
    p_exploit_status VARCHAR(50),
    p_is_zero_day BOOLEAN,
    p_is_ransomware_targeted BOOLEAN,
    p_in_active_campaigns BOOLEAN
) RETURNS TABLE (
    risk_score INTEGER,
    risk_tier VARCHAR(20),
    sla_days INTEGER,
    cvss_comp REAL,
    epss_comp REAL,
    business_comp REAL,
    exposure_comp REAL,
    exploit_comp REAL
) AS $$
DECLARE
    v_cvss_component REAL := 0;
    v_epss_component REAL := 0;
    v_business_component REAL := 0;
    v_exposure_component REAL := 0;
    v_exploit_component REAL := 0;
    v_total_score INTEGER := 0;
    v_tier VARCHAR(20);
    v_sla INTEGER;
BEGIN
    -- 1. CVSS Component (0-30 points)
    v_cvss_component := CASE
        WHEN p_cvss_score >= 9.0 THEN 30
        WHEN p_cvss_score >= 7.0 THEN 22
        WHEN p_cvss_score >= 4.0 THEN 15
        WHEN p_cvss_score >= 0.1 THEN 5
        ELSE 0
    END;

    -- 2. EPSS Component (0-25 points)
    v_epss_component := CASE
        WHEN p_epss_score >= 0.50 THEN 25
        WHEN p_epss_score >= 0.20 THEN 18
        WHEN p_epss_score >= 0.05 THEN 10
        WHEN p_epss_score > 0 THEN 3
        ELSE 0
    END;

    -- 3. Business Impact Component (0-25 points)
    -- Base score from criticality (0-15)
    v_business_component := CASE p_asset_criticality
        WHEN 'Critical' THEN 15
        WHEN 'High' THEN 11
        WHEN 'Medium' THEN 6
        WHEN 'Low' THEN 2
        ELSE 6
    END;

    -- +5 if sensitive data
    IF p_has_sensitive_data THEN
        v_business_component := v_business_component + 5;
    END IF;

    -- +5 if revenue impact >€10k/hour
    IF p_revenue_impact > 10000 THEN
        v_business_component := v_business_component + 5;
    END IF;

    -- Cap at 25
    v_business_component := LEAST(v_business_component, 25);

    -- 4. Asset Exposure Component (0-15 points)
    v_exposure_component := CASE
        WHEN p_is_public_ip OR p_network_zone = 'Internet-Facing' THEN 12
        WHEN p_network_zone = 'DMZ' THEN 10
        WHEN p_network_zone = 'Isolated' THEN 0
        ELSE 5  -- Internal
    END;

    -- 5. Exploit Availability Component (0-5 points)
    v_exploit_component := CASE p_exploit_status
        WHEN 'PublicExploitActiveCampaigns' THEN 5
        WHEN 'PublicExploit' THEN 4
        WHEN 'PoCAvailable' THEN 3
        WHEN 'TheoreticalExploit' THEN 1
        ELSE 0
    END;

    -- Calculate total score
    v_total_score := LEAST(ROUND(
        v_cvss_component +
        v_epss_component +
        v_business_component +
        v_exposure_component +
        v_exploit_component
    ), 100);

    -- Apply overrides
    -- Zero-day: Auto-escalate to Critical
    IF p_is_zero_day THEN
        v_total_score := GREATEST(v_total_score, 90);
    END IF;

    -- Ransomware targeted: Critical
    IF p_is_ransomware_targeted THEN
        v_total_score := GREATEST(v_total_score, 85);
    END IF;

    -- Active exploitation: +20 points
    IF p_in_active_campaigns THEN
        v_total_score := LEAST(v_total_score + 20, 100);
    END IF;

    -- Determine tier and SLA
    v_tier := CASE
        WHEN v_total_score >= 80 THEN 'Critical'
        WHEN v_total_score >= 60 THEN 'High'
        WHEN v_total_score >= 40 THEN 'Medium'
        WHEN v_total_score >= 20 THEN 'Low'
        ELSE 'Info'
    END;

    v_sla := CASE v_tier
        WHEN 'Critical' THEN 1    -- 24 hours
        WHEN 'High' THEN 7        -- 1 week
        WHEN 'Medium' THEN 30     -- 1 month
        WHEN 'Low' THEN 90        -- 3 months
        ELSE 0                    -- No SLA
    END;

    -- Return all components
    RETURN QUERY SELECT
        v_total_score,
        v_tier,
        v_sla,
        v_cvss_component,
        v_epss_component,
        v_business_component,
        v_exposure_component,
        v_exploit_component;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- Trigger: Auto-calculate risk score on vulnerability insert/update
CREATE OR REPLACE FUNCTION trigger_calculate_risk_score()
RETURNS TRIGGER AS $$
DECLARE
    v_asset_criticality VARCHAR(20);
    v_has_sensitive_data BOOLEAN;
    v_revenue_impact REAL;
    v_network_zone VARCHAR(50);
    v_is_public_ip BOOLEAN;
    v_result RECORD;
BEGIN
    -- Get asset metadata
    SELECT
        COALESCE(a.criticality, 'Medium'),
        COALESCE(a.has_sensitive_data, FALSE),
        COALESCE(a.revenue_impact_per_hour, 0),
        COALESCE(a.network_zone, 'Internal'),
        NOT (host(NEW.ip_address) LIKE '10.%'
             OR host(NEW.ip_address) LIKE '192.168.%'
             OR host(NEW.ip_address) LIKE '172.%')
    INTO
        v_asset_criticality,
        v_has_sensitive_data,
        v_revenue_impact,
        v_network_zone,
        v_is_public_ip
    FROM assets a
    WHERE a.ip_address = NEW.ip_address
    LIMIT 1;

    -- Calculate risk score
    SELECT * INTO v_result FROM calculate_risk_score(
        COALESCE(NEW.cvss_score, 0),
        COALESCE(NEW.epss_score, 0),
        COALESCE(v_asset_criticality, 'Medium'),
        COALESCE(v_has_sensitive_data, FALSE),
        COALESCE(v_revenue_impact, 0),
        COALESCE(v_network_zone, 'Internal'),
        COALESCE(v_is_public_ip, FALSE),
        COALESCE(NEW.exploit_status, 'NoExploit'),
        COALESCE(NEW.is_zero_day, FALSE),
        COALESCE(NEW.is_ransomware_targeted, FALSE),
        COALESCE(NEW.in_active_campaigns, FALSE)
    );

    -- Update vulnerability fields
    NEW.risk_score := v_result.risk_score;
    NEW.risk_tier := v_result.risk_tier;
    NEW.sla_days := v_result.sla_days;
    NEW.cvss_component := v_result.cvss_comp;
    NEW.epss_component := v_result.epss_comp;
    NEW.business_component := v_result.business_comp;
    NEW.exposure_component := v_result.exposure_comp;
    NEW.exploit_component := v_result.exploit_comp;

    -- Calculate SLA deadline (only if not already resolved)
    IF NEW.status NOT IN ('resolved', 'closed') AND v_result.sla_days > 0 THEN
        NEW.sla_deadline := COALESCE(NEW.first_detected, NOW()) + (v_result.sla_days || ' days')::INTERVAL;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger for automatic risk calculation
DROP TRIGGER IF EXISTS trigger_auto_risk_score ON vulnerabilities;
CREATE TRIGGER trigger_auto_risk_score
    BEFORE INSERT OR UPDATE OF cvss_score, epss_score, exploit_status, is_zero_day, is_ransomware_targeted, in_active_campaigns
    ON vulnerabilities
    FOR EACH ROW
    EXECUTE FUNCTION trigger_calculate_risk_score();

-- Function: Check SLA breaches
CREATE OR REPLACE FUNCTION check_sla_breaches()
RETURNS TABLE (
    vulnerability_id UUID,
    title TEXT,
    risk_tier VARCHAR(20),
    sla_deadline TIMESTAMPTZ,
    days_overdue INTEGER
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        v.id,
        v.title::TEXT,
        v.risk_tier,
        v.sla_deadline,
        EXTRACT(DAY FROM NOW() - v.sla_deadline)::INTEGER as days_overdue
    FROM vulnerabilities v
    WHERE v.sla_deadline IS NOT NULL
      AND v.sla_deadline < NOW()
      AND v.status NOT IN ('resolved', 'closed')
      AND v.sla_breached = FALSE
    ORDER BY v.risk_score DESC, v.sla_deadline ASC;
END;
$$ LANGUAGE plpgsql;

-- Function: Mark SLA breaches (to run periodically)
CREATE OR REPLACE FUNCTION mark_sla_breaches()
RETURNS INTEGER AS $$
DECLARE
    v_count INTEGER;
BEGIN
    UPDATE vulnerabilities
    SET sla_breached = TRUE
    WHERE sla_deadline IS NOT NULL
      AND sla_deadline < NOW()
      AND status NOT IN ('resolved', 'closed')
      AND sla_breached = FALSE;

    GET DIAGNOSTICS v_count = ROW_COUNT;
    RETURN v_count;
END;
$$ LANGUAGE plpgsql;

-- Indexes for performance
CREATE INDEX IF NOT EXISTS idx_vulnerabilities_risk_score ON vulnerabilities(risk_score DESC);
CREATE INDEX IF NOT EXISTS idx_vulnerabilities_risk_tier ON vulnerabilities(risk_tier);
CREATE INDEX IF NOT EXISTS idx_vulnerabilities_sla_deadline ON vulnerabilities(sla_deadline) WHERE sla_deadline IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_vulnerabilities_sla_breached ON vulnerabilities(sla_breached) WHERE sla_breached = TRUE;

-- Index for asset lookups
CREATE INDEX IF NOT EXISTS idx_assets_criticality ON assets(criticality);

-- Comments
COMMENT ON COLUMN vulnerabilities.risk_score IS 'Calculated risk score (0-100) using intelligent prioritization formula';
COMMENT ON COLUMN vulnerabilities.risk_tier IS 'Risk tier: Critical (80-100), High (60-79), Medium (40-59), Low (20-39), Info (<20)';
COMMENT ON COLUMN vulnerabilities.sla_deadline IS 'Automatic SLA deadline based on risk tier';
COMMENT ON COLUMN vulnerabilities.sla_days IS 'SLA in days: Critical=1, High=7, Medium=30, Low=90';
COMMENT ON COLUMN vulnerabilities.sla_breached IS 'TRUE if SLA deadline has passed';

COMMENT ON FUNCTION calculate_risk_score IS 'Implements intelligent risk scoring: (CVSS×0.30) + (EPSS×0.25) + (Business×0.25) + (Exposure×0.15) + (Exploit×0.05)';
COMMENT ON FUNCTION check_sla_breaches IS 'Returns all vulnerabilities with breached SLA deadlines';
COMMENT ON FUNCTION mark_sla_breaches IS 'Marks vulnerabilities with breached SLA (run periodically via cron)';
