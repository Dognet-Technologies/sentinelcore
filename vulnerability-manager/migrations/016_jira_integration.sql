-- Migration 016: JIRA Integration for Auto-Ticketing
-- Implements bidirectional sync between SentinelCore and Atlassian JIRA

-- JIRA connection configuration
CREATE TABLE IF NOT EXISTS jira_configurations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(200) NOT NULL,
    base_url VARCHAR(500) NOT NULL, -- e.g., https://company.atlassian.net
    username VARCHAR(200), -- For basic auth (legacy)
    api_token TEXT, -- API token (encrypted)
    auth_type VARCHAR(50) DEFAULT 'token' CHECK (auth_type IN ('basic', 'token', 'oauth2')),
    default_project_key VARCHAR(50), -- e.g., 'VULN', 'SEC'
    default_issue_type VARCHAR(50) DEFAULT 'Task', -- Task, Bug, Story, etc.
    is_enabled BOOLEAN DEFAULT TRUE,
    auto_create_tickets BOOLEAN DEFAULT FALSE, -- Auto-create on vulnerability discovery
    auto_sync BOOLEAN DEFAULT TRUE, -- Bi-directional sync
    webhook_secret TEXT, -- For JIRA webhook verification
    custom_field_mapping JSON DEFAULT '{}'::JSON, -- Map SentinelCore fields to JIRA custom fields
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_by UUID REFERENCES users(id)
);

-- Auto-ticketing rules
CREATE TABLE IF NOT EXISTS jira_ticketing_rules (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    jira_config_id UUID NOT NULL REFERENCES jira_configurations(id) ON DELETE CASCADE,
    name VARCHAR(200) NOT NULL,
    is_enabled BOOLEAN DEFAULT TRUE,
    priority INTEGER DEFAULT 100,

    -- Trigger conditions (same format as notification rules)
    conditions JSON NOT NULL, -- {"risk_tier": {"in": ["Critical", "High"]}}

    -- JIRA ticket settings
    project_key VARCHAR(50), -- Override default project
    issue_type VARCHAR(50), -- Override default issue type
    priority_mapping JSON DEFAULT '{
        "Critical": "Highest",
        "High": "High",
        "Medium": "Medium",
        "Low": "Low",
        "Info": "Lowest"
    }'::JSON,

    -- Assignment
    assignee_field VARCHAR(100), -- JIRA field for assignee (username or email)
    auto_assign_from_sentinelcore BOOLEAN DEFAULT TRUE,
    default_assignee VARCHAR(200), -- Fallback assignee

    -- Labels and components
    labels TEXT[], -- Auto-add JIRA labels
    components TEXT[], -- Auto-add JIRA components

    -- Custom fields
    custom_fields JSON DEFAULT '{}'::JSON,

    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- JIRA ticket linkage
CREATE TABLE IF NOT EXISTS jira_tickets (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    jira_config_id UUID NOT NULL REFERENCES jira_configurations(id) ON DELETE CASCADE,

    -- SentinelCore entity
    entity_type VARCHAR(50) NOT NULL CHECK (entity_type IN ('vulnerability', 'remediation_plan', 'asset')),
    entity_id UUID NOT NULL,

    -- JIRA issue
    jira_issue_key VARCHAR(50) NOT NULL, -- e.g., 'VULN-123'
    jira_issue_id VARCHAR(100), -- JIRA internal ID
    jira_project_key VARCHAR(50),
    jira_issue_type VARCHAR(50),
    jira_status VARCHAR(100), -- e.g., 'Open', 'In Progress', 'Resolved'
    jira_priority VARCHAR(50),
    jira_assignee VARCHAR(200),
    jira_url TEXT, -- Direct link to JIRA issue

    -- Sync status
    sync_status VARCHAR(50) DEFAULT 'synced' CHECK (sync_status IN ('synced', 'pending', 'failed', 'conflict')),
    last_sync_at TIMESTAMPTZ,
    sync_error TEXT,

    -- Metadata
    created_in VARCHAR(50) DEFAULT 'sentinelcore', -- 'sentinelcore' or 'jira'
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    UNIQUE (jira_config_id, jira_issue_key)
);

-- JIRA sync history (audit trail)
CREATE TABLE IF NOT EXISTS jira_sync_history (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    jira_ticket_id UUID NOT NULL REFERENCES jira_tickets(id) ON DELETE CASCADE,
    sync_direction VARCHAR(50) NOT NULL CHECK (sync_direction IN ('to_jira', 'from_jira', 'bidirectional')),
    sync_action VARCHAR(100) NOT NULL, -- 'create', 'update', 'status_change', 'comment', etc.
    fields_changed JSON, -- {"status": {"old": "Open", "new": "In Progress"}}
    request_payload JSON,
    response_payload JSON,
    status VARCHAR(50) NOT NULL CHECK (status IN ('success', 'failed', 'partial')),
    error_message TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_jira_configs_enabled ON jira_configurations(is_enabled);
CREATE INDEX idx_jira_rules_config ON jira_ticketing_rules(jira_config_id);
CREATE INDEX idx_jira_rules_enabled ON jira_ticketing_rules(is_enabled);
CREATE INDEX idx_jira_tickets_entity ON jira_tickets(entity_type, entity_id);
CREATE INDEX idx_jira_tickets_issue_key ON jira_tickets(jira_issue_key);
CREATE INDEX idx_jira_tickets_sync_status ON jira_tickets(sync_status);
CREATE INDEX idx_jira_sync_history_ticket ON jira_sync_history(jira_ticket_id);
CREATE INDEX idx_jira_sync_history_created ON jira_sync_history(created_at DESC);

-- Function: Build JIRA issue description from vulnerability
CREATE OR REPLACE FUNCTION build_jira_description(p_vulnerability_id UUID)
RETURNS TEXT AS $$
DECLARE
    v_description TEXT;
BEGIN
    SELECT format(
        E'*Vulnerability Details*\n\n' ||
        E'*CVE:* %s\n' ||
        E'*CVSS Score:* %s (Severity: %s)\n' ||
        E'*Risk Score:* %s/100 (Tier: %s)\n' ||
        E'*EPSS Score:* %s%% (Exploit Probability)\n\n' ||
        E'*Affected Asset*\n' ||
        E'*Hostname:* %s\n' ||
        E'*IP Address:* %s\n' ||
        E'*OS:* %s\n\n' ||
        E'*Description*\n' ||
        E'%s\n\n' ||
        E'*Solution*\n' ||
        E'%s\n\n' ||
        E'*SLA Deadline:* %s\n' ||
        E'*Detected:* %s\n\n' ||
        E'_Auto-generated by SentinelCore_',
        COALESCE(v.cve_id, 'N/A'),
        COALESCE(v.cvss_score::TEXT, 'N/A'),
        COALESCE(v.severity, 'Unknown'),
        COALESCE(v.risk_score::TEXT, '0'),
        COALESCE(v.risk_tier, 'Info'),
        COALESCE(ROUND((v.epss_score * 100)::NUMERIC, 2)::TEXT, '0'),
        COALESCE(v.hostname, 'Unknown'),
        COALESCE(host(v.ip_address)::TEXT, 'N/A'),
        COALESCE(v.operating_system, 'Unknown'),
        COALESCE(v.description, 'No description available'),
        COALESCE(v.solution, 'No solution available'),
        COALESCE(v.sla_deadline::TEXT, 'No SLA'),
        COALESCE(v.first_detected::TEXT, NOW()::TEXT)
    )
    INTO v_description
    FROM vulnerabilities v
    WHERE v.id = p_vulnerability_id;

    RETURN v_description;
END;
$$ LANGUAGE plpgsql;

-- Function: Get matching JIRA ticketing rules
CREATE OR REPLACE FUNCTION get_matching_jira_rules(
    p_vulnerability_data JSON,
    p_jira_config_id UUID DEFAULT NULL
) RETURNS TABLE (
    rule_id UUID,
    jira_config_id UUID,
    project_key VARCHAR,
    issue_type VARCHAR,
    priority VARCHAR,
    assignee VARCHAR,
    labels TEXT[],
    components TEXT[]
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        jtr.id,
        jtr.jira_config_id,
        COALESCE(jtr.project_key, jc.default_project_key),
        COALESCE(jtr.issue_type, jc.default_issue_type),
        (jtr.priority_mapping->>COALESCE(p_vulnerability_data->>'risk_tier', 'Medium'))::VARCHAR,
        jtr.default_assignee,
        jtr.labels,
        jtr.components
    FROM jira_ticketing_rules jtr
    JOIN jira_configurations jc ON jc.id = jtr.jira_config_id
    WHERE jtr.is_enabled = TRUE
      AND jc.is_enabled = TRUE
      AND (p_jira_config_id IS NULL OR jtr.jira_config_id = p_jira_config_id)
      AND evaluate_rule_conditions(jtr.conditions, p_vulnerability_data)
    ORDER BY jtr.priority ASC
    LIMIT 1; -- Return first matching rule
END;
$$ LANGUAGE plpgsql;

-- Function: Sync JIRA ticket status to vulnerability
CREATE OR REPLACE FUNCTION sync_jira_status_to_vulnerability(
    p_jira_ticket_id UUID,
    p_new_jira_status VARCHAR
) RETURNS BOOLEAN AS $$
DECLARE
    v_entity_id UUID;
    v_new_status VARCHAR;
BEGIN
    -- Get entity ID
    SELECT entity_id INTO v_entity_id
    FROM jira_tickets
    WHERE id = p_jira_ticket_id AND entity_type = 'vulnerability';

    IF NOT FOUND THEN
        RETURN FALSE;
    END IF;

    -- Map JIRA status to SentinelCore status
    v_new_status := CASE
        WHEN lower(p_new_jira_status) IN ('done', 'resolved', 'closed') THEN 'resolved'
        WHEN lower(p_new_jira_status) IN ('in progress', 'in review') THEN 'in_progress'
        WHEN lower(p_new_jira_status) IN ('open', 'to do', 'backlog') THEN 'open'
        ELSE 'open'
    END;

    -- Update vulnerability status
    UPDATE vulnerabilities
    SET status = v_new_status,
        resolved_at = CASE WHEN v_new_status = 'resolved' THEN NOW() ELSE resolved_at END
    WHERE id = v_entity_id;

    -- Update JIRA ticket sync status
    UPDATE jira_tickets
    SET jira_status = p_new_jira_status,
        last_sync_at = NOW(),
        sync_status = 'synced'
    WHERE id = p_jira_ticket_id;

    RETURN TRUE;
END;
$$ LANGUAGE plpgsql;

-- Insert default JIRA ticketing rules
INSERT INTO jira_ticketing_rules (jira_config_id, name, priority, conditions, labels)
SELECT
    jc.id,
    'Auto-ticket Critical/High Vulnerabilities',
    10,
    '{"risk_tier": {"in": ["Critical", "High"]}}'::JSON,
    ARRAY['security', 'vulnerability', 'auto-created']
FROM jira_configurations jc
WHERE jc.auto_create_tickets = TRUE
ON CONFLICT DO NOTHING;

-- Trigger: Auto-create JIRA ticket on vulnerability insert
CREATE OR REPLACE FUNCTION trigger_auto_create_jira_ticket()
RETURNS TRIGGER AS $$
DECLARE
    v_rule RECORD;
    v_vuln_data JSON;
BEGIN
    -- Build vulnerability data JSON
    v_vuln_data := json_build_object(
        'id', NEW.id,
        'risk_tier', NEW.risk_tier,
        'risk_score', NEW.risk_score,
        'severity', NEW.severity,
        'cvss_score', NEW.cvss_score,
        'status', NEW.status
    );

    -- Get matching rule
    SELECT * INTO v_rule
    FROM get_matching_jira_rules(v_vuln_data)
    LIMIT 1;

    IF FOUND THEN
        -- Insert into jira_tickets with pending sync status
        -- Actual JIRA API call will be done by background worker
        INSERT INTO jira_tickets (
            jira_config_id,
            entity_type,
            entity_id,
            jira_project_key,
            jira_issue_type,
            jira_priority,
            sync_status,
            created_in
        ) VALUES (
            v_rule.jira_config_id,
            'vulnerability',
            NEW.id,
            v_rule.project_key,
            v_rule.issue_type,
            v_rule.priority,
            'pending',
            'sentinelcore'
        );
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Note: Trigger creation commented out - enable when JIRA is configured
-- DROP TRIGGER IF EXISTS trigger_jira_auto_ticket ON vulnerabilities;
-- CREATE TRIGGER trigger_jira_auto_ticket
--     AFTER INSERT ON vulnerabilities
--     FOR EACH ROW
--     WHEN (NEW.risk_tier IN ('Critical', 'High'))
--     EXECUTE FUNCTION trigger_auto_create_jira_ticket();

-- Comments
COMMENT ON TABLE jira_configurations IS 'JIRA/ServiceNow connection configurations for auto-ticketing';
COMMENT ON TABLE jira_ticketing_rules IS 'Rules for automatic ticket creation based on vulnerability properties';
COMMENT ON TABLE jira_tickets IS 'Linkage table between SentinelCore entities and JIRA issues';
COMMENT ON TABLE jira_sync_history IS 'Audit trail of all JIRA sync operations';
COMMENT ON COLUMN jira_configurations.webhook_secret IS 'Secret for verifying JIRA webhook requests';
COMMENT ON COLUMN jira_tickets.sync_status IS 'synced: up-to-date, pending: awaiting sync, failed: sync error, conflict: manual resolution needed';
COMMENT ON FUNCTION build_jira_description IS 'Generates formatted JIRA issue description from vulnerability data';
COMMENT ON FUNCTION sync_jira_status_to_vulnerability IS 'Syncs JIRA issue status change back to SentinelCore vulnerability';
