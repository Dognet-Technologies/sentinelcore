use anyhow::{Context, Result};
use serde::Deserialize;
use std::path::Path;

#[derive(Debug, Deserialize, Clone)]
pub struct Config {
    pub server: ServerConfig,
    pub database: DatabaseConfig,
    pub auth: AuthConfig,
    pub plugins: PluginsConfig,
    pub log: LogConfig,
    pub network: NetworkConfig,
    #[serde(default)]
    pub security: SecurityConfig,
    #[serde(default)]
    pub monitoring: MonitoringConfig,
}

#[derive(Debug, Deserialize, Clone)]
pub struct ServerConfig {
    pub port: u16,
    pub host: String,
    #[serde(default)]
    pub enable_tls: bool,
    #[serde(default)]
    pub tls_cert_path: Option<String>,
    #[serde(default)]
    pub tls_key_path: Option<String>,
    #[serde(default = "default_request_timeout")]
    pub request_timeout_seconds: u64,
    #[serde(default = "default_graceful_shutdown")]
    pub graceful_shutdown_timeout_seconds: u64,
}

fn default_request_timeout() -> u64 { 30 }
fn default_graceful_shutdown() -> u64 { 30 }

#[derive(Debug, Deserialize, Clone)]
pub struct DatabaseConfig {
    pub url: String,
    #[serde(default = "default_max_connections")]
    pub max_connections: u32,
    #[serde(default)]
    pub min_connections: Option<u32>,
    #[serde(default)]
    pub connection_timeout_seconds: Option<u64>,
    #[serde(default)]
    pub idle_timeout_seconds: Option<u64>,
    #[serde(default)]
    pub max_lifetime_seconds: Option<u64>,
    #[serde(default)]
    pub enable_ssl: bool,
}

fn default_max_connections() -> u32 { 5 }

#[derive(Debug, Deserialize, Clone)]
pub struct AuthConfig {
    pub secret_key: String,
    pub token_duration_hours: u64,
    pub password_policy: PasswordPolicyConfig,
    #[serde(default)]
    pub refresh_token_duration_hours: Option<u64>,
    #[serde(default)]
    pub enable_refresh_tokens: bool,
    #[serde(default)]
    pub session_timeout_hours: Option<u64>,
}

#[derive(Debug, Deserialize, Clone)]
pub struct PasswordPolicyConfig {
    pub min_length: u8,
    pub require_uppercase: bool,
    pub require_lowercase: bool,
    pub require_numbers: bool,
    pub require_special_chars: bool,
    pub special_chars: String,
    pub max_length: u8,
    pub prevent_common_passwords: bool,
}

#[derive(Debug, Deserialize, Clone)]
pub struct PluginsConfig {
    pub directory: String,
    pub enabled: bool,
}

#[derive(Debug, Deserialize, Clone)]
pub struct LogConfig {
    pub level: String,
    pub file: Option<String>,
}

#[derive(Debug, Deserialize, Clone)]
pub struct NetworkConfig {
    pub interface: String,
    pub default_scan_timeout: u32,
    pub max_scan_workers: u32,
}

#[derive(Debug, Deserialize, Clone, Default)]
pub struct SecurityConfig {
    #[serde(default)]
    pub cors: CorsConfig,
    #[serde(default)]
    pub headers: SecurityHeadersConfig,
    #[serde(default)]
    pub rate_limit: RateLimitConfig,
    #[serde(default)]
    pub csrf: CsrfConfig,
    #[serde(default)]
    pub cookies: CookieConfig,
}

#[derive(Debug, Deserialize, Clone)]
pub struct CorsConfig {
    #[serde(default = "default_true")]
    pub enabled: bool,
    #[serde(default)]
    pub allowed_origins: Vec<String>,
    #[serde(default = "default_allowed_methods")]
    pub allowed_methods: Vec<String>,
    #[serde(default = "default_allowed_headers")]
    pub allowed_headers: Vec<String>,
    #[serde(default)]
    pub expose_headers: Vec<String>,
    #[serde(default = "default_max_age")]
    pub max_age_seconds: u64,
    #[serde(default = "default_true")]
    pub allow_credentials: bool,
}

impl Default for CorsConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            allowed_origins: vec!["http://localhost:3000".to_string()],
            allowed_methods: default_allowed_methods(),
            allowed_headers: default_allowed_headers(),
            expose_headers: vec![],
            max_age_seconds: 3600,
            allow_credentials: true,
        }
    }
}

#[derive(Debug, Deserialize, Clone, Default)]
pub struct SecurityHeadersConfig {
    #[serde(default = "default_hsts_max_age")]
    pub hsts_max_age_seconds: u64,
    #[serde(default = "default_true")]
    pub hsts_include_subdomains: bool,
    #[serde(default)]
    pub hsts_preload: bool,
    #[serde(default = "default_frame_options")]
    pub frame_options: String,
    #[serde(default = "default_nosniff")]
    pub content_type_options: String,
    #[serde(default = "default_xss_protection")]
    pub xss_protection: String,
    #[serde(default = "default_referrer_policy")]
    pub referrer_policy: String,
    #[serde(default)]
    pub csp: Option<String>,
    #[serde(default)]
    pub permissions_policy: Option<String>,
}

#[derive(Debug, Deserialize, Clone)]
pub struct RateLimitConfig {
    #[serde(default = "default_true")]
    pub enabled: bool,
    #[serde(default = "default_rpm")]
    pub requests_per_minute: u32,
    #[serde(default = "default_burst")]
    pub burst_size: u32,
    #[serde(default = "default_login_rpm")]
    pub login_attempts_per_minute: u32,
    #[serde(default = "default_api_rpm")]
    pub api_requests_per_minute: u32,
}

impl Default for RateLimitConfig {
    fn default() -> Self {
        Self {
            enabled: false, // Disabled by default for backward compatibility
            requests_per_minute: 60,
            burst_size: 100,
            login_attempts_per_minute: 5,
            api_requests_per_minute: 120,
        }
    }
}

#[derive(Debug, Deserialize, Clone)]
pub struct CsrfConfig {
    #[serde(default)]
    pub enabled: bool,
    #[serde(default = "default_csrf_cookie_name")]
    pub cookie_name: String,
    #[serde(default = "default_csrf_header_name")]
    pub header_name: String,
    #[serde(default = "default_token_length")]
    pub token_length: usize,
    #[serde(default = "default_true")]
    pub secure_cookie: bool,
    #[serde(default)]
    pub http_only: bool,
    #[serde(default = "default_same_site")]
    pub same_site: String,
}

impl Default for CsrfConfig {
    fn default() -> Self {
        Self {
            enabled: false,
            cookie_name: "XSRF-TOKEN".to_string(),
            header_name: "X-CSRF-Token".to_string(),
            token_length: 32,
            secure_cookie: true,
            http_only: false,
            same_site: "Strict".to_string(),
        }
    }
}

#[derive(Debug, Deserialize, Clone)]
pub struct CookieConfig {
    #[serde(default)]
    pub secure: bool,
    #[serde(default = "default_true")]
    pub http_only: bool,
    #[serde(default = "default_same_site")]
    pub same_site: String,
    #[serde(default)]
    pub domain: Option<String>,
    #[serde(default = "default_path")]
    pub path: String,
    #[serde(default = "default_cookie_max_age")]
    pub max_age_seconds: i64,
}

impl Default for CookieConfig {
    fn default() -> Self {
        Self {
            secure: false, // Default to false for development
            http_only: true,
            same_site: "Lax".to_string(),
            domain: None,
            path: "/".to_string(),
            max_age_seconds: 28800, // 8 hours
        }
    }
}

#[derive(Debug, Deserialize, Clone)]
pub struct MonitoringConfig {
    #[serde(default)]
    pub enabled: bool,
    #[serde(default = "default_metrics_port")]
    pub metrics_port: u16,
    #[serde(default = "default_health_path")]
    pub health_check_path: String,
    #[serde(default = "default_ready_path")]
    pub readiness_check_path: String,
}

impl Default for MonitoringConfig {
    fn default() -> Self {
        Self {
            enabled: false,
            metrics_port: 9090,
            health_check_path: "/health".to_string(),
            readiness_check_path: "/ready".to_string(),
        }
    }
}

// Default value functions
fn default_true() -> bool { true }
fn default_allowed_methods() -> Vec<String> {
    vec!["GET".into(), "POST".into(), "PUT".into(), "DELETE".into(), "PATCH".into()]
}
fn default_allowed_headers() -> Vec<String> {
    vec!["Content-Type".into(), "Authorization".into()]
}
fn default_max_age() -> u64 { 3600 }
fn default_hsts_max_age() -> u64 { 31536000 }
fn default_frame_options() -> String { "DENY".into() }
fn default_nosniff() -> String { "nosniff".into() }
fn default_xss_protection() -> String { "1; mode=block".into() }
fn default_referrer_policy() -> String { "strict-origin-when-cross-origin".into() }
fn default_rpm() -> u32 { 60 }
fn default_burst() -> u32 { 100 }
fn default_login_rpm() -> u32 { 5 }
fn default_api_rpm() -> u32 { 120 }
fn default_csrf_cookie_name() -> String { "XSRF-TOKEN".into() }
fn default_csrf_header_name() -> String { "X-CSRF-Token".into() }
fn default_token_length() -> usize { 32 }
fn default_same_site() -> String { "Lax".into() }
fn default_path() -> String { "/".into() }
fn default_cookie_max_age() -> i64 { 28800 }
fn default_metrics_port() -> u16 { 9090 }
fn default_health_path() -> String { "/health".into() }
fn default_ready_path() -> String { "/ready".into() }

pub fn load_config() -> Result<Config> {
    // Load .env file if it exists
    let _ = dotenv::dotenv();

    let mut builder = config::Config::builder();

    // Add default config
    builder = builder.add_source(config::File::from_str(
        include_str!("../../config/default.yaml"),
        config::FileFormat::Yaml
    ));

    // Add environment-specific config if it exists
    let env = std::env::var("APP_ENV").unwrap_or_else(|_| "development".into());
    let env_config = format!("config/{}.yaml", env);

    if Path::new(&env_config).exists() {
        builder = builder.add_source(config::File::with_name(&env_config));
    }

    // Add environment variables with prefix VULN_
    builder = builder.add_source(config::Environment::with_prefix("VULN").separator("_"));

    // Build and deserialize
    let config: Config = builder.build()
        .context("Failed to build configuration")?
        .try_deserialize()
        .context("Failed to deserialize configuration")?;

    // Validate security-critical settings
    validate_config(&config)?;

    Ok(config)
}

/// Validates security-critical configuration values
fn validate_config(config: &Config) -> Result<()> {
    let env = std::env::var("APP_ENV").unwrap_or_else(|_| "development".into());

    // In production, ensure secrets are changed from defaults
    if env == "production" {
        if config.auth.secret_key == "DogNET" {
            anyhow::bail!(
                "SECURITY ERROR: JWT secret_key is still set to default 'DogNET'. \
                Please set a strong secret via VULN_AUTH_SECRET_KEY environment variable or config file."
            );
        }

        if config.database.url.contains("DogNET") {
            anyhow::bail!(
                "SECURITY ERROR: Database password appears to be default 'DogNET'. \
                Please set a strong password in DATABASE_URL environment variable."
            );
        }

        if !config.server.enable_tls {
            tracing::warn!(
                "⚠️  WARNING: TLS is disabled in production. \
                This is INSECURE and should only be used behind a reverse proxy with TLS termination."
            );
        }

        if config.security.cors.allowed_origins.is_empty() {
            tracing::warn!(
                "⚠️  WARNING: No CORS origins configured. API will reject all cross-origin requests."
            );
        }

        if config.security.cors.allowed_origins.iter().any(|o| o.contains("localhost")) {
            tracing::warn!(
                "⚠️  WARNING: CORS includes localhost origins in production. Remove these for security."
            );
        }
    }

    // Validate JWT secret length
    if config.auth.secret_key.len() < 32 {
        anyhow::bail!(
            "SECURITY ERROR: JWT secret_key must be at least 32 characters long. Current length: {}",
            config.auth.secret_key.len()
        );
    }

    Ok(())
}