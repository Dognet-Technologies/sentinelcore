use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct ErrorResponse {
    pub error: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub details: Option<ErrorDetails>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub code: Option<String>,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct ErrorDetails {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub fields: Option<HashMap<String, Vec<String>>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}

impl ErrorResponse {
    pub fn new(error: impl Into<String>) -> Self {
        Self {
            error: error.into(),
            details: None,
            code: None,
        }
    }

    pub fn with_code(error: impl Into<String>, code: impl Into<String>) -> Self {
        Self {
            error: error.into(),
            details: None,
            code: Some(code.into()),
        }
    }

    pub fn with_field_error(error: impl Into<String>, field: impl Into<String>, reason: impl Into<String>) -> Self {
        let mut fields = HashMap::new();
        fields.insert(field.into(), vec![reason.into()]);
        
        Self {
            error: error.into(),
            details: Some(ErrorDetails {
                fields: Some(fields),
                message: None,
            }),
            code: None,
        }
    }

    pub fn with_multiple_field_errors(error: impl Into<String>, field_errors: HashMap<String, Vec<String>>) -> Self {
        Self {
            error: error.into(),
            details: Some(ErrorDetails {
                fields: Some(field_errors),
                message: None,
            }),
            code: None,
        }
    }

    pub fn validation_error(field_errors: HashMap<String, Vec<String>>) -> Self {
        Self {
            error: "Validation failed".to_string(),
            details: Some(ErrorDetails {
                fields: Some(field_errors),
                message: Some("One or more fields contain invalid values".to_string()),
            }),
            code: Some("VALIDATION_ERROR".to_string()),
        }
    }

    pub fn not_found(resource: impl Into<String>) -> Self {
        Self {
            error: format!("{} not found", resource.into()),
            details: None,
            code: Some("NOT_FOUND".to_string()),
        }
    }

    pub fn conflict(reason: impl Into<String>) -> Self {
        Self {
            error: reason.into(),
            details: None,
            code: Some("CONFLICT".to_string()),
        }
    }

    pub fn gone(reason: impl Into<String>) -> Self {
        Self {
            error: reason.into(),
            details: None,
            code: Some("GONE".to_string()),
        }
    }

    pub fn internal_error(reason: impl Into<String>) -> Self {
        Self {
            error: format!("Internal server error: {}", reason.into()),
            details: None,
            code: Some("INTERNAL_ERROR".to_string()),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_error_response_new() {
        let err = ErrorResponse::new("Test error");
        assert_eq!(err.error, "Test error");
        assert!(err.details.is_none());
        assert!(err.code.is_none());
    }

    #[test]
    fn test_error_response_with_code() {
        let err = ErrorResponse::with_code("Bad request", "BAD_REQUEST");
        assert_eq!(err.error, "Bad request");
        assert_eq!(err.code, Some("BAD_REQUEST".to_string()));
    }

    #[test]
    fn test_error_response_with_field_error() {
        let err = ErrorResponse::with_field_error("Validation failed", "cvss_score", "must be between 0 and 10");
        assert!(err.details.is_some());
        let details = err.details.unwrap();
        assert!(details.fields.is_some());
        let fields = details.fields.unwrap();
        assert!(fields.contains_key("cvss_score"));
    }

    #[test]
    fn test_error_response_not_found() {
        let err = ErrorResponse::not_found("Vulnerability");
        assert_eq!(err.error, "Vulnerability not found");
        assert_eq!(err.code, Some("NOT_FOUND".to_string()));
    }

    #[test]
    fn test_error_response_gone() {
        let err = ErrorResponse::gone("Resource has been deleted");
        assert_eq!(err.code, Some("GONE".to_string()));
    }
}
