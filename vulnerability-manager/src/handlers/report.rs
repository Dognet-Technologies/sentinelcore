use axum::{
    extract::{Path, State},
    http::{StatusCode, header, HeaderMap},
    response::{IntoResponse, Response},
    Json,
};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use crate::models::{Report, ReportType, ReportStatus, ReportFormat};
use crate::auth::Claims;
use crate::state::AppState;

#[derive(Debug, Serialize)]
pub struct ErrorResponse {
    pub error: String,
}

#[derive(Debug, Deserialize)]
pub struct NewReport {
    pub name: String,
    pub report_type: ReportType,
    pub format: ReportFormat,
    pub source: String,
    pub scan_date: Option<chrono::DateTime<chrono::Utc>>,
}

#[derive(Debug, Deserialize)]
pub struct UpdateReport {
    pub name: Option<String>,
    pub status: Option<ReportStatus>,
    pub error_message: Option<String>,
    pub processed_vulns: Option<i32>,
    pub total_vulns: Option<i32>,
}

// LIST - Ottieni lista report
pub async fn list_reports(
    State(app_state): State<AppState>,
) -> Result<Json<Vec<Report>>, (StatusCode, Json<ErrorResponse>)> {
    let reports = sqlx::query_as!(
        Report,
        r#"
        SELECT id, name, report_type as "report_type: ReportType", 
               format as "format: ReportFormat", 
               status as "status: ReportStatus", source, created_by, file_path, 
               error_message, scan_date, processed_vulns, total_vulns, 
               created_at, updated_at
        FROM reports
        ORDER BY created_at DESC
        "#
    )
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore nel recupero dei report: {}", e),
        }),
    ))?;

    Ok(Json(reports))
}

// GET - Ottieni singolo report
pub async fn get_report(
    State(app_state): State<AppState>,
    Path(report_id): Path<Uuid>,
) -> Result<Json<Report>, (StatusCode, Json<ErrorResponse>)> {
    let report = sqlx::query_as!(
        Report,
        r#"
        SELECT id, name, report_type as "report_type: ReportType", 
               format as "format: ReportFormat", 
               status as "status: ReportStatus", source, created_by, file_path, 
               error_message, scan_date, processed_vulns, total_vulns, 
               created_at, updated_at
        FROM reports
        WHERE id = $1
        "#,
        report_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore database: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Report non trovato".to_string(),
        }),
    ))?;

    Ok(Json(report))
}

// CREATE - Crea nuovo report
pub async fn create_report(
    State(app_state): State<AppState>,
    claims: Claims,
    Json(new_report): Json<NewReport>,
) -> Result<Json<Report>, (StatusCode, Json<ErrorResponse>)> {
    let user_id = Uuid::parse_str(&claims.sub)
        .map_err(|_| (
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: "ID utente non valido nel token".to_string(),
            }),
        ))?;
    
    let report = sqlx::query_as!(
        Report,
        r#"
        INSERT INTO reports (
            name, report_type, format, status, source, created_by, scan_date
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7)
        RETURNING id, name, report_type as "report_type: ReportType", 
                  format as "format: ReportFormat", 
                  status as "status: ReportStatus", source, created_by, file_path, 
                  error_message, scan_date, processed_vulns, total_vulns, 
                  created_at, updated_at
        "#,
        new_report.name,
        new_report.report_type as _,
        new_report.format as _,
        ReportStatus::Pending as _,
        new_report.source,
        user_id,
        new_report.scan_date
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| {
        let error_message = if e.to_string().contains("duplicate key") {
            "Report con questo nome già esistente".to_string()
        } else {
            format!("Errore durante la creazione: {}", e)
        };
        (
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse { error: error_message }),
        )
    })?;

    Ok(Json(report))
}

// UPDATE - Aggiorna report
pub async fn update_report(
    State(app_state): State<AppState>,
    Path(report_id): Path<Uuid>,
    Json(update_data): Json<UpdateReport>,
) -> Result<Json<Report>, (StatusCode, Json<ErrorResponse>)> {
    let report = sqlx::query_as!(
        Report,
        r#"
        UPDATE reports
        SET 
            name = COALESCE($2, name),
            status = COALESCE($3, status),
            error_message = COALESCE($4, error_message),
            processed_vulns = COALESCE($5, processed_vulns),
            total_vulns = COALESCE($6, total_vulns),
            updated_at = NOW()
        WHERE id = $1
        RETURNING id, name, report_type as "report_type: ReportType", 
                  format as "format: ReportFormat", 
                  status as "status: ReportStatus", source, created_by, file_path, 
                  error_message, scan_date, processed_vulns, total_vulns, 
                  created_at, updated_at
        "#,
        report_id,
        update_data.name,
        update_data.status as _,
        update_data.error_message,
        update_data.processed_vulns,
        update_data.total_vulns
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore durante l'aggiornamento: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Report non trovato".to_string(),
        }),
    ))?;

    Ok(Json(report))
}

// DELETE - Elimina report
pub async fn delete_report(
    State(app_state): State<AppState>,
    Path(report_id): Path<Uuid>,
) -> Result<StatusCode, (StatusCode, Json<ErrorResponse>)> {
    // Prima ottieni il file_path per eliminare il file fisico se esiste
    let file_path: Option<String> = sqlx::query_scalar!(
        "SELECT file_path FROM reports WHERE id = $1",
        report_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore database: {}", e),
        }),
    ))?
    .flatten();

    // Se c'è un file associato, prova a eliminarlo
    if let Some(path) = file_path {
        if let Err(e) = std::fs::remove_file(&path) {
            // Log l'errore ma continua con l'eliminazione del record
            eprintln!("Errore durante l'eliminazione del file {}: {}", path, e);
        }
    }

    let result = sqlx::query!(
        "DELETE FROM reports WHERE id = $1",
        report_id
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore durante l'eliminazione: {}", e),
        }),
    ))?;

    if result.rows_affected() == 0 {
        return Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Report non trovato".to_string(),
            }),
        ));
    }

    Ok(StatusCode::NO_CONTENT)
}

/// Generate/regenerate report
pub async fn generate_report(
    State(app_state): State<AppState>,
    Path(report_id): Path<Uuid>,
) -> Result<Json<Report>, (StatusCode, Json<ErrorResponse>)> {
    let pool = &*app_state.pool;

    let report = sqlx::query_as!(
        Report,
        r#"
        SELECT id, name, report_type as "report_type: ReportType", 
               format as "format: ReportFormat", 
               status as "status: ReportStatus", source, created_by, file_path, 
               error_message, scan_date, processed_vulns, total_vulns, 
               created_at, updated_at
        FROM reports
        WHERE id = $1
        "#,
        report_id
    )
    .fetch_optional(pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore database: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Report non trovato".to_string(),
        }),
    ))?;

    sqlx::query!(
        r#"
        UPDATE reports
        SET status = $2, error_message = NULL, updated_at = NOW()
        WHERE id = $1
        "#,
        report_id,
        ReportStatus::Processing as _
    )
    .execute(pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore durante la rigenerazione: {}", e),
        }),
    ))?;

    let updated_report = sqlx::query_as!(
        Report,
        r#"
        SELECT id, name, report_type as "report_type: ReportType", 
               format as "format: ReportFormat", 
               status as "status: ReportStatus", source, created_by, file_path, 
               error_message, scan_date, processed_vulns, total_vulns, 
               created_at, updated_at
        FROM reports
        WHERE id = $1
        "#,
        report_id
    )
    .fetch_one(pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore nel recupero del report aggiornato: {}", e),
        }),
    ))?;

    Ok(Json(updated_report))
}

/// Scarica file del report
pub async fn download_report(
    State(app_state): State<AppState>,
    Path(report_id): Path<Uuid>,
) -> Result<Response, (StatusCode, Json<ErrorResponse>)> {
    let report_data: (Option<String>, String) = sqlx::query_as(
        "SELECT file_path, format FROM reports WHERE id = $1"
    )
    .bind(report_id)
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore database: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Report non trovato".to_string(),
        }),
    ))?;

    let file_path = report_data.0.ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "File del report non disponibile".to_string(),
        }),
    ))?;

    let content = std::fs::read(&file_path)
        .map_err(|e| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Errore durante la lettura del file: {}", e),
            }),
        ))?;

    let file_name = std::path::Path::new(&file_path)
        .file_name()
        .and_then(|n| n.to_str())
        .unwrap_or("report")
        .to_string();

    let content_type = match report_data.1.as_str() {
        "pdf" => "application/pdf",
        "json" => "application/json",
        "csv" => "text/csv",
        "xml" => "application/xml",
        "text" => "text/plain",
        _ => "application/octet-stream",
    };

    let mut headers = HeaderMap::new();
    
    if let Ok(ct) = content_type.parse() {
        headers.insert(header::CONTENT_TYPE, ct);
    }
    
    if let Ok(cd) = format!("attachment; filename=\"{}\"", file_name).parse() {
        headers.insert(header::CONTENT_DISPOSITION, cd);
    }

    Ok((headers, content).into_response())
}

// Invia report via email
pub async fn send_report_email(
    State(app_state): State<AppState>,
    claims: Claims,
    Path(report_id): Path<Uuid>,
    Json(payload): Json<serde_json::Value>,
) -> Result<Json<serde_json::Value>, (StatusCode, Json<ErrorResponse>)> {
    let user_id = claims.sub.parse::<Uuid>().map_err(|_| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: "Invalid user ID".to_string(),
        }),
    ))?;

    // Verify report exists
    let report_exists = sqlx::query_scalar!(
        "SELECT EXISTS(SELECT 1 FROM reports WHERE id = $1)",
        report_id
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Database error: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Database error".to_string(),
            }),
        )
    })?
    .unwrap_or(false);

    if !report_exists {
        return Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Report non trovato".to_string(),
            }),
        ));
    }

    let email = payload["email"].as_str().unwrap_or("");

    // TODO: Implement actual email sending with SMTP
    // For now, just log the action
    tracing::info!("Report {} would be sent to {}", report_id, email);

    // Log audit
    sqlx::query!(
        r#"
        INSERT INTO audit_logs (user_id, action, entity_type, entity_id, old_values, new_values, ip_address)
        VALUES ($1, $2, $3, $4, $5, $6, $7)
        "#,
        user_id,
        "send_report_email",
        "report",
        report_id,
        None as Option<serde_json::Value>,
        serde_json::json!({"email": email}),
        None as Option<String>
    )
    .execute(&*app_state.pool)
    .await
    .ok();

    Ok(Json(serde_json::json!({
        "success": true,
        "message": format!("Report will be sent to {}", email)
    })))
}

// Duplica un report
pub async fn duplicate_report(
    State(app_state): State<AppState>,
    claims: Claims,
    Path(report_id): Path<Uuid>,
) -> Result<Json<serde_json::Value>, (StatusCode, Json<ErrorResponse>)> {
    let user_id = claims.sub.parse::<Uuid>().map_err(|_| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: "Invalid user ID".to_string(),
        }),
    ))?;

    // Fetch original report
    let original_report = sqlx::query!(
        r#"
        SELECT name, report_type as "report_type: ReportType", format as "format: ReportFormat", source, created_by
        FROM reports
        WHERE id = $1
        "#,
        report_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Database error: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Database error".to_string(),
            }),
        )
    })?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Report non trovato".to_string(),
        }),
    ))?;

    // Create duplicate
    let new_id = Uuid::new_v4();
    let new_name = format!("{} (Copia)", original_report.name);

    sqlx::query!(
        r#"
        INSERT INTO reports (id, name, report_type, format, source, status, created_by)
        VALUES ($1, $2, $3, $4, $5, $6, $7)
        "#,
        new_id,
        new_name,
        original_report.report_type as _,
        original_report.format as _,
        original_report.source,
        ReportStatus::Pending as _,
        user_id
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to duplicate report: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to duplicate report".to_string(),
            }),
        )
    })?;

    // Log audit
    sqlx::query!(
        r#"
        INSERT INTO audit_logs (user_id, action, entity_type, entity_id, old_values, new_values, ip_address)
        VALUES ($1, $2, $3, $4, $5, $6, $7)
        "#,
        user_id,
        "duplicate_report",
        "report",
        new_id,
        serde_json::json!({"original_id": report_id}),
        serde_json::json!({"new_id": new_id}),
        None as Option<String>
    )
    .execute(&*app_state.pool)
    .await
    .ok();

    Ok(Json(serde_json::json!({
        "success": true,
        "report_id": new_id,
        "message": "Report duplicato con successo"
    })))
}