use axum::{
    extract::{Path, Extension},
    http::StatusCode,
    Json,
};
use sqlx::PgPool;
use std::sync::Arc;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use crate::models::{Report, ReportType, ReportStatus, ReportFormat};
use crate::auth::Claims;

#[derive(Debug, Serialize)]
pub struct ErrorResponse {
    pub error: String,
}

#[derive(Debug, Deserialize)]
pub struct NewReport {
    pub name: String,
    pub report_type: ReportType,
    pub format: ReportFormat,
    pub source: String,
    pub scan_date: Option<chrono::DateTime<chrono::Utc>>,
}

#[derive(Debug, Deserialize)]
pub struct UpdateReport {
    pub name: Option<String>,
    pub status: Option<ReportStatus>,
    pub error_message: Option<String>,
    pub processed_vulns: Option<i32>,
    pub total_vulns: Option<i32>,
}

// LIST - Ottieni lista report
pub async fn list_reports(
    Extension(pool): Extension<Arc<PgPool>>,
) -> Result<Json<Vec<Report>>, (StatusCode, Json<ErrorResponse>)> {
    let reports = sqlx::query_as!(
        Report,
        r#"
        SELECT id, name, report_type as "report_type: ReportType", 
               format as "format: ReportFormat", 
               status as "status: ReportStatus", source, created_by, file_path, 
               error_message, scan_date, processed_vulns, total_vulns, 
               created_at, updated_at
        FROM reports
        ORDER BY created_at DESC
        "#
    )
    .fetch_all(&*pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore nel recupero dei report: {}", e),
        }),
    ))?;

    Ok(Json(reports))
}

// GET - Ottieni singolo report
pub async fn get_report(
    Extension(pool): Extension<Arc<PgPool>>,
    Path(report_id): Path<Uuid>,
) -> Result<Json<Report>, (StatusCode, Json<ErrorResponse>)> {
    let report = sqlx::query_as!(
        Report,
        r#"
        SELECT id, name, report_type as "report_type: ReportType", 
               format as "format: ReportFormat", 
               status as "status: ReportStatus", source, created_by, file_path, 
               error_message, scan_date, processed_vulns, total_vulns, 
               created_at, updated_at
        FROM reports
        WHERE id = $1
        "#,
        report_id
    )
    .fetch_optional(&*pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore database: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Report non trovato".to_string(),
        }),
    ))?;

    Ok(Json(report))
}

// CREATE - Crea nuovo report
pub async fn create_report(
    Extension(pool): Extension<Arc<PgPool>>,
    Extension(claims): Extension<Claims>,
    Json(new_report): Json<NewReport>,
) -> Result<Json<Report>, (StatusCode, Json<ErrorResponse>)> {
    let user_id = Uuid::parse_str(&claims.sub)
        .map_err(|_| (
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: "ID utente non valido nel token".to_string(),
            }),
        ))?;
    
    let report = sqlx::query_as!(
        Report,
        r#"
        INSERT INTO reports (
            name, report_type, format, status, source, created_by, scan_date
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7)
        RETURNING id, name, report_type as "report_type: ReportType", 
                  format as "format: ReportFormat", 
                  status as "status: ReportStatus", source, created_by, file_path, 
                  error_message, scan_date, processed_vulns, total_vulns, 
                  created_at, updated_at
        "#,
        new_report.name,
        new_report.report_type as _,
        new_report.format as _,
        ReportStatus::Pending as _,
        new_report.source,
        user_id,
        new_report.scan_date
    )
    .fetch_one(&*pool)
    .await
    .map_err(|e| {
        let error_message = if e.to_string().contains("duplicate key") {
            "Report con questo nome già esistente".to_string()
        } else {
            format!("Errore durante la creazione: {}", e)
        };
        (
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse { error: error_message }),
        )
    })?;

    Ok(Json(report))
}

// UPDATE - Aggiorna report
pub async fn update_report(
    Extension(pool): Extension<Arc<PgPool>>,
    Path(report_id): Path<Uuid>,
    Json(update_data): Json<UpdateReport>,
) -> Result<Json<Report>, (StatusCode, Json<ErrorResponse>)> {
    let report = sqlx::query_as!(
        Report,
        r#"
        UPDATE reports
        SET 
            name = COALESCE($2, name),
            status = COALESCE($3, status),
            error_message = COALESCE($4, error_message),
            processed_vulns = COALESCE($5, processed_vulns),
            total_vulns = COALESCE($6, total_vulns),
            updated_at = NOW()
        WHERE id = $1
        RETURNING id, name, report_type as "report_type: ReportType", 
                  format as "format: ReportFormat", 
                  status as "status: ReportStatus", source, created_by, file_path, 
                  error_message, scan_date, processed_vulns, total_vulns, 
                  created_at, updated_at
        "#,
        report_id,
        update_data.name,
        update_data.status as _,
        update_data.error_message,
        update_data.processed_vulns,
        update_data.total_vulns
    )
    .fetch_optional(&*pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore durante l'aggiornamento: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Report non trovato".to_string(),
        }),
    ))?;

    Ok(Json(report))
}

// DELETE - Elimina report
pub async fn delete_report(
    Extension(pool): Extension<Arc<PgPool>>,
    Path(report_id): Path<Uuid>,
) -> Result<StatusCode, (StatusCode, Json<ErrorResponse>)> {
    // Prima ottieni il file_path per eliminare il file fisico se esiste
    let file_path: Option<String> = sqlx::query_scalar!(
        "SELECT file_path FROM reports WHERE id = $1",
        report_id
    )
    .fetch_optional(&*pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore database: {}", e),
        }),
    ))?
    .flatten();

    // Se c'è un file associato, prova a eliminarlo
    if let Some(path) = file_path {
        if let Err(e) = std::fs::remove_file(&path) {
            // Log l'errore ma continua con l'eliminazione del record
            eprintln!("Errore durante l'eliminazione del file {}: {}", path, e);
        }
    }

    let result = sqlx::query!(
        "DELETE FROM reports WHERE id = $1",
        report_id
    )
    .execute(&*pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore durante l'eliminazione: {}", e),
        }),
    ))?;

    if result.rows_affected() == 0 {
        return Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Report non trovato".to_string(),
            }),
        ));
    }

    Ok(StatusCode::NO_CONTENT)
}

// Scarica file del report
pub async fn download_report(
    Extension(pool): Extension<Arc<PgPool>>,
    Path(report_id): Path<Uuid>,
) -> Result<Vec<u8>, (StatusCode, Json<ErrorResponse>)> {
    let file_path: Option<String> = sqlx::query_scalar!(
        "SELECT file_path FROM reports WHERE id = $1 AND status = $2",
        report_id,
        ReportStatus::Completed as _
    )
    .fetch_optional(&*pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore database: {}", e),
        }),
    ))?
    .flatten();

    let file_path = file_path.ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Report non trovato o non completato".to_string(),
        }),
    ))?;

    std::fs::read(&file_path)
        .map_err(|e| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Errore durante la lettura del file: {}", e),
            }),
        ))
}