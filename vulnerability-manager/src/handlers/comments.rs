// src/handlers/comments.rs
// Comments system handlers with @mentions support

use axum::{
    extract::{Path, State},
    http::StatusCode,
    Json,
};
use serde::{Deserialize, Serialize};
use uuid::Uuid;
use chrono::{DateTime, Utc};

use crate::auth::Claims;
use crate::state::AppState;

#[derive(Debug, Serialize, Deserialize, sqlx::FromRow)]
pub struct Comment {
    pub id: Uuid,
    pub entity_type: String,
    pub entity_id: Uuid,
    pub user_id: Uuid,
    pub username: String,
    pub comment_text: String,
    pub parent_comment_id: Option<Uuid>,
    pub mentions: serde_json::Value,
    pub attachments: serde_json::Value,
    pub is_internal: bool,
    pub is_edited: bool,
    pub edited_at: Option<DateTime<Utc>>,
    pub created_at: DateTime<Utc>,
}

#[derive(Debug, Deserialize)]
pub struct CreateComment {
    pub entity_type: String,  // 'vulnerability', 'asset', 'remediation_plan'
    pub entity_id: Uuid,
    pub comment_text: String,
    pub parent_comment_id: Option<Uuid>,
    pub is_internal: Option<bool>,
}

#[derive(Debug, Deserialize)]
pub struct UpdateComment {
    pub comment_text: String,
}

#[derive(Debug, Serialize)]
pub struct CommentResponse {
    pub comment: Comment,
}

#[derive(Debug, Serialize)]
pub struct CommentsListResponse {
    pub comments: Vec<Comment>,
    pub total: i64,
}

#[derive(Debug, Serialize)]
pub struct MentionsResponse {
    pub mentions: Vec<MentionNotification>,
}

#[derive(Debug, Serialize, sqlx::FromRow)]
pub struct MentionNotification {
    pub comment_id: Uuid,
    pub comment_type: String,
    pub entity_id: Uuid,
    pub entity_title: String,
    pub commenter_id: Uuid,
    pub commenter_username: String,
    pub comment_text: String,
    pub created_at: DateTime<Utc>,
}

// Get comments for entity
pub async fn get_comments(
    State(app_state): State<AppState>,
    Path((entity_type, entity_id)): Path<(String, Uuid)>,
    _claims: Claims,
) -> Result<Json<CommentsListResponse>, StatusCode> {
    let (table_name, entity_column) = match entity_type.as_str() {
        "vulnerability" => ("vulnerability_comments", "vulnerability_id"),
        "asset" => ("asset_comments", "asset_id"),
        "remediation" => ("remediation_comments", "remediation_plan_id"),
        _ => return Err(StatusCode::BAD_REQUEST),
    };

    let entity_field = match entity_type.as_str() {
        "vulnerability" => "vulnerability_id",
        "asset" => "asset_id",
        "remediation" => "remediation_plan_id",
        _ => return Err(StatusCode::BAD_REQUEST),
    };

    let query = format!(
        r#"
        SELECT
            c.id,
            $1 as entity_type,
            c.{} as entity_id,
            c.user_id,
            u.username,
            c.comment_text,
            c.parent_comment_id,
            c.mentions,
            c.attachments,
            c.is_internal,
            c.is_edited,
            c.edited_at,
            c.created_at
        FROM {} c
        JOIN users u ON u.id = c.user_id
        WHERE c.{} = $2
            AND c.deleted_at IS NULL
        ORDER BY c.created_at ASC
        "#,
        entity_field, table_name, entity_field
    );

    let comments = sqlx::query_as::<_, Comment>(&query)
        .bind(&entity_type)
        .bind(entity_id)
        .fetch_all(&*app_state.pool)
        .await
        .map_err(|e| {
            tracing::error!("Failed to fetch comments: {}", e);
            StatusCode::INTERNAL_SERVER_ERROR
        })?;

    let total = comments.len() as i64;

    Ok(Json(CommentsListResponse { comments, total }))
}

// Create comment
pub async fn create_comment(
    State(app_state): State<AppState>,
    claims: Claims,
    Json(payload): Json<CreateComment>,
) -> Result<(StatusCode, Json<CommentResponse>), StatusCode> {
    let user_id = claims.sub.parse::<Uuid>()
        .map_err(|_| StatusCode::BAD_REQUEST)?;

    let table_name = match payload.entity_type.as_str() {
        "vulnerability" => "vulnerability_comments",
        "asset" => "asset_comments",
        "remediation" => "remediation_comments",
        _ => return Err(StatusCode::BAD_REQUEST),
    };

    let entity_field = match payload.entity_type.as_str() {
        "vulnerability" => "vulnerability_id",
        "asset" => "asset_id",
        "remediation" => "remediation_plan_id",
        _ => return Err(StatusCode::BAD_REQUEST),
    };

    let query = format!(
        r#"
        WITH inserted_comment AS (
            INSERT INTO {} ({}, user_id, comment_text, parent_comment_id, is_internal)
            VALUES ($1, $2, $3, $4, $5)
            RETURNING
            	id,
            	{} as entity_id,
            	user_id,
            	comment_text,
            	parent_comment_id,
            	mentions,
            	attachments,
            	is_internal,
            	is_edited,
            	edited_at,
            	created_at
        )
        SELECT
            ic.id,
            $6 as entity_type,
            ic.entity_id,
            ic.user_id,
            u.username,
            ic.comment_text,
            ic.parent_comment_id,
            ic.mentions,
            ic.attachments,
            ic.is_internal,
            ic.is_edited,
            ic.edited_at,
            ic.created_at
        FROM inserted_comment ic
        JOIN users u ON u.id = ic.user_id
        "#,
        table_name, entity_field, entity_field
    );

    let comment = sqlx::query_as::<_, Comment>(&query)
        .bind(payload.entity_id)
        .bind(user_id)
        .bind(&payload.comment_text)
        .bind(payload.parent_comment_id)
        .bind(payload.is_internal.unwrap_or(true))
        .bind(&payload.entity_type)
        .fetch_one(&*app_state.pool)
        .await
        .map_err(|e| {
            tracing::error!("Failed to create comment: {}", e);
            StatusCode::INTERNAL_SERVER_ERROR
        })?;

    Ok((
        StatusCode::CREATED,
        Json(CommentResponse {
            comment,
        }),
    ))
}

// Update comment
pub async fn update_comment(
    State(app_state): State<AppState>,
    Path(comment_id): Path<Uuid>,
    claims: Claims,
    Json(payload): Json<UpdateComment>,
) -> Result<Json<CommentResponse>, StatusCode> {
    let user_id = claims.sub.parse::<Uuid>()
        .map_err(|_| StatusCode::BAD_REQUEST)?;

    // Try updating in each table until we find the comment
    let tables = vec![
        ("vulnerability_comments", "vulnerability_id"),
        ("asset_comments", "asset_id"),
        ("remediation_comments", "remediation_plan_id"),
    ];

    for (table_name, entity_field) in tables {
        let query = format!(
            r#"
            WITH updated_comment AS (
                UPDATE {}
                SET comment_text = $1,
                    is_edited = TRUE,
                    edited_at = NOW()
                WHERE id = $2 AND user_id = $3
                RETURNING id, {} as entity_id, user_id, comment_text, parent_comment_id,
                          mentions, attachments, is_internal, is_edited,
                          edited_at, created_at
            )
            SELECT
                uc.id,
                CASE
                    WHEN $4 = 'vulnerability' THEN 'vulnerability'::VARCHAR
                    WHEN $4 = 'asset' THEN 'asset'::VARCHAR
                    WHEN $4 = 'remediation' THEN 'remediation'::VARCHAR
                    ELSE 'unknown'::VARCHAR
                END as entity_type,
                uc.entity_id,
                uc.user_id,
                u.username,
                uc.comment_text,
                uc.parent_comment_id,
                uc.mentions,
                uc.attachments,
                uc.is_internal,
                uc.is_edited,
                uc.edited_at,
                uc.created_at
            FROM updated_comment uc
            JOIN users u ON u.id = uc.user_id
            "#,
            table_name, entity_field
        );

        let entity_type = match table_name {
            "vulnerability_comments" => "vulnerability",
            "asset_comments" => "asset",
            "remediation_comments" => "remediation",
            _ => "unknown",
        };

        if let Ok(comment) = sqlx::query_as::<_, Comment>(&query)
            .bind(&payload.comment_text)
            .bind(comment_id)
            .bind(user_id)
            .bind(entity_type)
            .fetch_one(&*app_state.pool)
            .await
        {
            return Ok(Json(CommentResponse { comment }));
        }
    }

    Err(StatusCode::NOT_FOUND)
}

// Delete comment (soft delete)
pub async fn delete_comment(
    State(app_state): State<AppState>,
    Path(comment_id): Path<Uuid>,
    claims: Claims,
) -> Result<StatusCode, StatusCode> {
    let user_id = claims.sub.parse::<Uuid>()
        .map_err(|_| StatusCode::BAD_REQUEST)?;

    // Try deleting from each entity type until we find the comment
    let entity_types = ["vulnerability", "asset", "remediation"];

    for entity_type in &entity_types {
        // Use soft_delete_comment function from database
        if let Ok(deleted) = sqlx::query_scalar::<_, bool>(
            "SELECT soft_delete_comment($1, $2, $3)"
        )
        .bind(comment_id)
        .bind(user_id)
        .bind(entity_type)
        .fetch_one(&*app_state.pool)
        .await
        {
            if deleted {
                return Ok(StatusCode::NO_CONTENT);
            }
        }
    }

    Err(StatusCode::NOT_FOUND)
}

// Get user's mentions
pub async fn get_user_mentions(
    State(app_state): State<AppState>,
    claims: Claims,
) -> Result<Json<MentionsResponse>, StatusCode> {
    let user_id = claims.sub.parse::<Uuid>()
        .map_err(|_| StatusCode::BAD_REQUEST)?;

    let mentions = sqlx::query_as::<_, MentionNotification>(
        "SELECT * FROM get_user_mentions($1, 50)"
    )
    .bind(user_id)
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch mentions: {}", e);
        StatusCode::INTERNAL_SERVER_ERROR
    })?;

    Ok(Json(MentionsResponse { mentions }))
}
