// src/handlers/comments.rs
// Comments system handlers with @mentions support

use axum::{
    extract::{Path, State},
    http::StatusCode,
    Json,
};
use serde::{Deserialize, Serialize};
use uuid::Uuid;
use chrono::{DateTime, Utc};

use crate::auth::Claims;
use crate::state::AppState;

#[derive(Debug, Serialize, Deserialize, sqlx::FromRow)]
pub struct Comment {
    pub id: Uuid,
    pub entity_type: String,
    pub entity_id: Uuid,
    pub user_id: Uuid,
    pub username: String,
    pub comment_text: String,
    pub parent_comment_id: Option<Uuid>,
    pub mentions: serde_json::Value,
    pub attachments: serde_json::Value,
    pub is_internal: bool,
    pub is_edited: bool,
    pub edited_at: Option<DateTime<Utc>>,
    pub created_at: DateTime<Utc>,
}

#[derive(Debug, Deserialize)]
pub struct CreateComment {
    pub entity_type: String,  // 'vulnerability', 'asset', 'remediation_plan'
    pub entity_id: Uuid,
    pub comment_text: String,
    pub parent_comment_id: Option<Uuid>,
    pub is_internal: Option<bool>,
}

#[derive(Debug, Deserialize)]
pub struct UpdateComment {
    pub comment_text: String,
}

#[derive(Debug, Serialize)]
pub struct CommentResponse {
    pub comment: Comment,
}

#[derive(Debug, Serialize)]
pub struct CommentsListResponse {
    pub comments: Vec<Comment>,
    pub total: i64,
}

#[derive(Debug, Serialize)]
pub struct MentionsResponse {
    pub mentions: Vec<MentionNotification>,
}

#[derive(Debug, Serialize, sqlx::FromRow)]
pub struct MentionNotification {
    pub comment_id: Uuid,
    pub comment_type: String,
    pub entity_id: Uuid,
    pub entity_title: String,
    pub commenter_id: Uuid,
    pub commenter_username: String,
    pub comment_text: String,
    pub created_at: DateTime<Utc>,
}

// Get comments for entity
pub async fn get_comments(
    State(app_state): State<AppState>,
    Path((entity_type, entity_id)): Path<(String, Uuid)>,
    _claims: Claims,
) -> Result<Json<CommentsListResponse>, StatusCode> {
    let table_name = match entity_type.as_str() {
        "vulnerability" => "vulnerability_comments",
        "asset" => "asset_comments",
        "remediation" => "remediation_comments",
        _ => return Err(StatusCode::BAD_REQUEST),
    };

    let entity_field = match entity_type.as_str() {
        "vulnerability" => "vulnerability_id",
        "asset" => "asset_id",
        "remediation" => "remediation_plan_id",
        _ => return Err(StatusCode::BAD_REQUEST),
    };

    let query = format!(
        r#"
        SELECT
            c.id,
            $1 as entity_type,
            c.{} as entity_id,
            c.user_id,
            u.username,
            c.comment_text,
            c.parent_comment_id,
            c.mentions,
            c.attachments,
            c.is_internal,
            c.is_edited,
            c.edited_at,
            c.created_at
        FROM {} c
        JOIN users u ON u.id = c.user_id
        WHERE c.{} = $2
            AND c.deleted_at IS NULL
        ORDER BY c.created_at ASC
        "#,
        entity_field, table_name, entity_field
    );

    let comments = sqlx::query_as::<_, Comment>(&query)
        .bind(&entity_type)
        .bind(entity_id)
        .fetch_all(&*app_state.pool)
        .await
        .map_err(|e| {
            tracing::error!("Failed to fetch comments: {}", e);
            StatusCode::INTERNAL_SERVER_ERROR
        })?;

    let total = comments.len() as i64;

    Ok(Json(CommentsListResponse { comments, total }))
}

// Create comment
pub async fn create_comment(
    State(app_state): State<AppState>,
    claims: Claims,
    Json(payload): Json<CreateComment>,
) -> Result<(StatusCode, Json<CommentResponse>), StatusCode> {
    let user_id = claims.sub.parse::<Uuid>()
        .map_err(|_| StatusCode::BAD_REQUEST)?;

    let table_name = match payload.entity_type.as_str() {
        "vulnerability" => "vulnerability_comments",
        "asset" => "asset_comments",
        "remediation" => "remediation_comments",
        _ => return Err(StatusCode::BAD_REQUEST),
    };

    let entity_field = match payload.entity_type.as_str() {
        "vulnerability" => "vulnerability_id",
        "asset" => "asset_id",
        "remediation" => "remediation_plan_id",
        _ => return Err(StatusCode::BAD_REQUEST),
    };

    let query = format!(
        r#"
        INSERT INTO {} ({}, user_id, comment_text, parent_comment_id, is_internal)
        VALUES ($1, $2, $3, $4, $5)
        RETURNING
            id,
            {} as entity_id,
            user_id,
            comment_text,
            parent_comment_id,
            mentions,
            attachments,
            is_internal,
            is_edited,
            edited_at,
            created_at
        "#,
        table_name, entity_field, entity_field
    );

    let comment = sqlx::query_as::<_, Comment>(&query)
        .bind(payload.entity_id)
        .bind(user_id)
        .bind(&payload.comment_text)
        .bind(payload.parent_comment_id)
        .bind(payload.is_internal.unwrap_or(true))
        .fetch_one(&*app_state.pool)
        .await
        .map_err(|e| {
            tracing::error!("Failed to create comment: {}", e);
            StatusCode::INTERNAL_SERVER_ERROR
        })?;

    // Get username
    let username = sqlx::query_scalar::<_, String>("SELECT username FROM users WHERE id = $1")
        .bind(user_id)
        .fetch_one(&*app_state.pool)
        .await
        .unwrap_or_else(|_| "Unknown".to_string());

    let mut comment_with_username = comment;
    comment_with_username.username = username;
    comment_with_username.entity_type = payload.entity_type;

    Ok((
        StatusCode::CREATED,
        Json(CommentResponse {
            comment: comment_with_username,
        }),
    ))
}

// Update comment
pub async fn update_comment(
    State(app_state): State<AppState>,
    Path(comment_id): Path<Uuid>,
    claims: Claims,
    Json(payload): Json<UpdateComment>,
) -> Result<Json<CommentResponse>, StatusCode> {
    let user_id = claims.sub.parse::<Uuid>()
        .map_err(|_| StatusCode::BAD_REQUEST)?;

    // Try updating in each table until we find the comment
    let tables = ["vulnerability_comments", "asset_comments", "remediation_comments"];

    for table_name in &tables {
        let query = format!(
            r#"
            UPDATE {}
            SET comment_text = $1,
                is_edited = TRUE,
                edited_at = NOW()
            WHERE id = $2 AND user_id = $3
            RETURNING id, user_id, comment_text, parent_comment_id,
                      mentions, attachments, is_internal, is_edited,
                      edited_at, created_at
            "#,
            table_name
        );

        if let Ok(comment) = sqlx::query_as::<_, Comment>(&query)
            .bind(&payload.comment_text)
            .bind(comment_id)
            .bind(user_id)
            .fetch_one(&*app_state.pool)
            .await
        {
            return Ok(Json(CommentResponse { comment }));
        }
    }

    Err(StatusCode::NOT_FOUND)
}

// Delete comment (soft delete)
pub async fn delete_comment(
    State(app_state): State<AppState>,
    Path(comment_id): Path<Uuid>,
    claims: Claims,
) -> Result<StatusCode, StatusCode> {
    let user_id = claims.sub.parse::<Uuid>()
        .map_err(|_| StatusCode::BAD_REQUEST)?;

    // Try deleting from each entity type until we find the comment
    let entity_types = ["vulnerability", "asset", "remediation"];

    for entity_type in &entity_types {
        // Use soft_delete_comment function from database
        if let Ok(deleted) = sqlx::query_scalar::<_, bool>(
            "SELECT soft_delete_comment($1, $2, $3)"
        )
        .bind(comment_id)
        .bind(user_id)
        .bind(entity_type)
        .fetch_one(&*app_state.pool)
        .await
        {
            if deleted {
                return Ok(StatusCode::NO_CONTENT);
            }
        }
    }

    Err(StatusCode::NOT_FOUND)
}

// Get user's mentions
pub async fn get_user_mentions(
    State(app_state): State<AppState>,
    claims: Claims,
) -> Result<Json<MentionsResponse>, StatusCode> {
    let user_id = claims.sub.parse::<Uuid>()
        .map_err(|_| StatusCode::BAD_REQUEST)?;

    let mentions = sqlx::query_as::<_, MentionNotification>(
        "SELECT * FROM get_user_mentions($1, 50)"
    )
    .bind(user_id)
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch mentions: {}", e);
        StatusCode::INTERNAL_SERVER_ERROR
    })?;

    Ok(Json(MentionsResponse { mentions }))
}
