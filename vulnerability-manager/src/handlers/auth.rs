// src/handlers/auth.rs
// FIXED: Rimosso cast ::INET nelle query, corretto per String IP addresses

use axum::{
    Extension,
    http::{StatusCode, HeaderMap},
    Json,
};
use serde::{Serialize, Deserialize};
use sqlx::PgPool;
use std::sync::Arc;
use uuid::Uuid;
use chrono::{Utc, Duration};

use crate::auth::{Auth, Claims};
use crate::models::user::{User, Role, LoginCredentials, UserSession};

#[derive(Serialize)]
pub struct LoginResponse {
    token: String,
    session_id: String,
    user: UserInfo,
    expires_at: String,
}

#[derive(Serialize)]
pub struct UserInfo {
    id: Uuid,
    username: String,
    email: String,
    role: String,
    reputation_score: i32,
    avatar_url: Option<String>,
}

#[derive(Serialize)]
pub struct ErrorResponse {
    error: String,
}

#[derive(Deserialize)]
pub struct PasswordResetRequest {
    email: String,
}

#[derive(Deserialize)]
pub struct PasswordResetConfirm {
    new_password: String,
}

// Enhanced login with session tracking
pub async fn login(
    Extension(pool): Extension<Arc<PgPool>>,
    Extension(auth): Extension<Arc<Auth>>,
    headers: HeaderMap,
    Json(credentials): Json<LoginCredentials>,
) -> Result<Json<LoginResponse>, (StatusCode, Json<ErrorResponse>)> {
    // Get user IP and user agent
    let ip_address = headers
        .get("x-forwarded-for")
        .and_then(|h| h.to_str().ok())
        .and_then(|s| s.split(',').next())
        .unwrap_or("unknown")
        .to_string();
    
    let user_agent = headers
        .get("user-agent")
        .and_then(|h| h.to_str().ok())
        .unwrap_or("unknown")
        .to_string();
    
    // Find user by username
    let user = sqlx::query_as!(
        User,
        r#"
        SELECT id, username, email, password_hash, role as "role: Role",
               reputation_score, avatar_url, last_login, failed_login_attempts,
               account_locked_until, two_factor_enabled, two_factor_secret,
               phone_number, bio, preferred_language, created_at, updated_at
        FROM users 
        WHERE username = $1
        "#,
        credentials.username
    )
    .fetch_optional(&*pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?;
    
    let mut user = match user {
        Some(u) => u,
        None => {
            return Err((
                StatusCode::UNAUTHORIZED,
                Json(ErrorResponse {
                    error: "Invalid credentials".to_string(),
                }),
            ));
        }
    };

    // Verify password
    let is_valid = auth.verify_password(&credentials.password, &user.password_hash)
        .map_err(|_| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Password verification failed".to_string(),
            }),
        ))?;

    if !is_valid {
        let failed_attempts = user.failed_login_attempts.unwrap_or(0) + 1;
        let locked_until = if failed_attempts >= 5 {
            Some(Utc::now() + Duration::hours(1))
        } else {
            None
        };

        // Update failed attempts
        let _ = sqlx::query!(
            "UPDATE users SET failed_login_attempts = $1, account_locked_until = $2 WHERE id = $3",
            failed_attempts,
            locked_until,
            user.id
        )
        .execute(&*pool)
        .await;

        return Err((
            StatusCode::UNAUTHORIZED,
            Json(ErrorResponse {
                error: "Invalid credentials".to_string(),
            }),
        ));
    }

    // Create session
    let session_token = uuid::Uuid::new_v4().to_string();
    let expires_at = Utc::now() + Duration::hours(24);

    // FIXED: Rimosso cast ::INET - PostgreSQL converte automaticamente String â†’ INET
    let session = sqlx::query_as!(
        UserSession,
        r#"
        INSERT INTO user_sessions (user_id, session_token, ip_address, user_agent, expires_at)
        VALUES ($1, $2, $3, $4, $5)
        RETURNING id, user_id, session_token, ip_address::text as ip_address,
                  user_agent, device_info, created_at, last_activity, expires_at,
                  is_active, revoked_at, revoked_reason
        "#,
        user.id,
        session_token,
        ip_address,  // FIXED: String diretto senza cast ::INET
        user_agent,
        expires_at
    )
    .fetch_one(&*pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Session creation error: {}", e),
        }),
    ))?;

    // Create JWT token with session ID
    let token = auth.create_token_with_session(user.id, user.role.clone(), Some(session.session_token.clone()))
        .map_err(|e| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Token creation error: {}", e),
            }),
        ))?;

    // Update user login data
    user.last_login = Some(Utc::now());
    user.failed_login_attempts = Some(0);
    user.account_locked_until = None;

    let user_info = UserInfo {
        id: user.id,
        username: user.username,
        email: user.email,
        role: user.role.as_str().to_string(),
        reputation_score: user.reputation_score.unwrap_or(0),
        avatar_url: user.avatar_url,
    };

    let response = LoginResponse {
        token,
        session_id: session.session_token,
        user: user_info,
        expires_at: expires_at.to_rfc3339(),
    };

    Ok(Json(response))
}

// Logout with session revocation
pub async fn logout(
    Extension(pool): Extension<Arc<PgPool>>,
    claims: Claims,
) -> Result<StatusCode, (StatusCode, Json<ErrorResponse>)> {
    let user_id = claims.sub.parse::<Uuid>().map_err(|_| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: "Invalid user ID".to_string(),
        }),
    ))?;

    // FIXED: Clone session_token per evitare ownership issues
    if let Some(session_token) = claims.jti.clone() {
        sqlx::query!(
            r#"
            UPDATE user_sessions 
            SET is_active = false, revoked_at = NOW(), revoked_reason = 'User logout'
            WHERE user_id = $1 AND session_token = $2
            "#,
            user_id,
            session_token
        )
        .execute(&*pool)
        .await
        .map_err(|e| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Failed to revoke session: {}", e),
            }),
        ))?;
    }

    Ok(StatusCode::NO_CONTENT)
}

// Refresh token
pub async fn refresh_token(
    Extension(pool): Extension<Arc<PgPool>>,
    Extension(auth): Extension<Arc<Auth>>,
    claims: Claims,
) -> Result<Json<LoginResponse>, (StatusCode, Json<ErrorResponse>)> {
    let user_id = claims.sub.parse::<Uuid>().map_err(|_| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: "Invalid user ID".to_string(),
        }),
    ))?;

    // Verify session is still active
    if let Some(session_token) = &claims.jti {
        let session_exists = sqlx::query_scalar!(
            "SELECT EXISTS(SELECT 1 FROM user_sessions WHERE user_id = $1 AND session_token = $2 AND is_active = true)",
            user_id,
            session_token
        )
        .fetch_one(&*pool)
        .await
        .map_err(|e| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Session verification failed: {}", e),
            }),
        ))?;

        if !session_exists.unwrap_or(false) {
            return Err((
                StatusCode::UNAUTHORIZED,
                Json(ErrorResponse {
                    error: "Session expired or invalid".to_string(),
                }),
            ));
        }
    }

    // Get user data
    let user = sqlx::query_as!(
        User,
        r#"
        SELECT id, username, email, password_hash, role as "role: Role",
               reputation_score, avatar_url, last_login, failed_login_attempts,
               account_locked_until, two_factor_enabled, two_factor_secret,
               phone_number, bio, preferred_language, created_at, updated_at
        FROM users 
        WHERE id = $1
        "#,
        user_id
    )
    .fetch_optional(&*pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "User not found".to_string(),
        }),
    ))?;

    // Create new token
    let new_token = auth.create_token_with_session(user.id, user.role.clone(), claims.jti.clone())
        .map_err(|e| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Token creation error: {}", e),
            }),
        ))?;

    let user_info = UserInfo {
        id: user.id,
        username: user.username,
        email: user.email,
        role: user.role.as_str().to_string(),
        reputation_score: user.reputation_score.unwrap_or(0),
        avatar_url: user.avatar_url,
    };

    let expires_at = Utc::now() + Duration::hours(24);
    
    let response = LoginResponse {
        token: new_token,
        session_id: claims.jti.unwrap_or_default(),
        user: user_info,
        expires_at: expires_at.to_rfc3339(),
    };

    Ok(Json(response))
}