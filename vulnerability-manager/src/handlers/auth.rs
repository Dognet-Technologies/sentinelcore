// src/handlers/auth.rs
// FIXED: Convertito da Extension a State e corretto reputation_score

use axum::{
    extract::State, // FIXED: State invece di Extension
    http::{StatusCode, HeaderMap},
    Json,
};
use serde::{Serialize, Deserialize};
use sqlx::PgPool;
use std::sync::Arc;
use uuid::Uuid;
use chrono::{Utc, Duration};

use crate::auth::{Auth, Claims};
use crate::models::user::{User, Role, LoginCredentials, UserSession};
use crate::AppState; // FIXED: Import AppState

#[derive(Serialize)]
pub struct LoginResponse {
    token: String,
    session_id: String,
    user: UserInfo,
    expires_at: String,
}

#[derive(Serialize)]
pub struct UserInfo {
    id: Uuid,
    username: String,
    email: String,
    role: String,
    reputation_score: i32, // FIXED: i32 invece di Option<i32>
    avatar_url: Option<String>,
}

#[derive(Serialize)]
pub struct ErrorResponse {
    error: String,
}

#[derive(Deserialize)]
pub struct PasswordResetRequest {
    email: String,
}

#[derive(Deserialize)]
pub struct PasswordResetConfirm {
    new_password: String,
}

// Enhanced login with session tracking - FIXED: convertito a State
pub async fn login(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    headers: HeaderMap,
    Json(credentials): Json<LoginCredentials>,
) -> Result<Json<LoginResponse>, (StatusCode, Json<ErrorResponse>)> {
    // Get user IP and user agent
    let ip_address = headers
        .get("x-forwarded-for")
        .and_then(|h| h.to_str().ok())
        .and_then(|s| s.split(',').next())
        .unwrap_or("unknown")
        .to_string();
    
    let user_agent = headers
        .get("user-agent")
        .and_then(|h| h.to_str().ok())
        .unwrap_or("unknown")
        .to_string();
    
    // Find user by username
    let user = sqlx::query_as!(
        User,
        r#"
        SELECT id, username, email, password_hash, role as "role: Role",
               reputation_score, avatar_url, last_login, failed_login_attempts,
               account_locked_until, two_factor_enabled, two_factor_secret,
               phone_number, bio, preferred_language, created_at, updated_at
        FROM users 
        WHERE username = $1
        "#,
        credentials.username
    )
    .fetch_optional(&*app_state.pool) // FIXED: app_state.pool
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?;
    
    let mut user = match user {
        Some(u) => u,
        None => {
            return Err((
                StatusCode::UNAUTHORIZED,
                Json(ErrorResponse {
                    error: "Invalid credentials".to_string(),
                }),
            ));
        }
    };

    // Verify password
    let is_valid = app_state.auth.verify_password(&credentials.password, &user.password_hash) // FIXED: app_state.auth
        .map_err(|_| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Password verification failed".to_string(),
            }),
        ))?;

    if !is_valid {
        return Err((
            StatusCode::UNAUTHORIZED,
            Json(ErrorResponse {
                error: "Invalid credentials".to_string(),
            }),
        ));
    }

    // Generate session token and expiry
    let session_token = format!("sess_{}", Uuid::new_v4());
    let expires_at = Utc::now() + Duration::hours(24);
    
    // Create session
    let session = sqlx::query_as!(
        UserSession,
        r#"
        INSERT INTO user_sessions (user_id, session_token, ip_address, user_agent, expires_at)
        VALUES ($1, $2, $3, $4, $5)
        RETURNING id, user_id, session_token, ip_address, user_agent, 
                  device_info, created_at, last_activity, expires_at, 
                  is_active, revoked_at, revoked_reason
        "#,
        user.id,
        session_token,
        ip_address,
        user_agent,
        expires_at
    )
    .fetch_one(&*app_state.pool) // FIXED: app_state.pool
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to create session: {}", e),
        }),
    ))?;

    // Create JWT token with session ID
    let token = app_state.auth.create_token_with_session(user.id, user.role.clone(), Some(session.id.to_string())) // FIXED: app_state.auth
        .map_err(|_| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to create token".to_string(),
            }),
        ))?;

    // Update last login
    sqlx::query!(
        "UPDATE users SET last_login = NOW() WHERE id = $1",
        user.id
    )
    .execute(&*app_state.pool) // FIXED: app_state.pool
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to update last login: {}", e),
        }),
    ))?;

    let response = LoginResponse {
        token,
        session_id: session.id.to_string(),
        user: UserInfo {
            id: user.id,
            username: user.username,
            email: user.email,
            role: user.role.as_str().to_string(),
            reputation_score: user.reputation_score.unwrap_or(0), // FIXED: gestione Option<i32>
            avatar_url: user.avatar_url,
        },
        expires_at: expires_at.to_rfc3339(),
    };

    Ok(Json(response))
}

// Logout - revoke session - FIXED: convertito a State
pub async fn logout(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    claims: Claims,
) -> Result<StatusCode, (StatusCode, Json<ErrorResponse>)> {
    if let Some(session_id) = claims.jti {
        let session_uuid = session_id.parse::<Uuid>().map_err(|_| (
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: "Invalid session ID".to_string(),
            }),
        ))?;

        sqlx::query!(
            r#"
            UPDATE user_sessions 
            SET is_active = false, revoked_at = NOW(), revoked_reason = 'user_logout'
            WHERE id = $1
            "#,
            session_uuid
        )
        .execute(&*app_state.pool) // FIXED: app_state.pool
        .await
        .map_err(|e| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Failed to revoke session: {}", e),
            }),
        ))?;
    }

    Ok(StatusCode::NO_CONTENT)
}

// Refresh token - FIXED: convertito a State
pub async fn refresh_token(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    claims: Claims,
) -> Result<Json<LoginResponse>, (StatusCode, Json<ErrorResponse>)> {
    let user_id = claims.sub.parse::<Uuid>().map_err(|_| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: "Invalid user ID".to_string(),
        }),
    ))?;

    // Get user data
    let user = sqlx::query_as!(
        User,
        r#"
        SELECT id, username, email, password_hash, role as "role: Role",
               reputation_score, avatar_url, last_login, failed_login_attempts,
               account_locked_until, two_factor_enabled, two_factor_secret,
               phone_number, bio, preferred_language, created_at, updated_at
        FROM users 
        WHERE id = $1
        "#,
        user_id
    )
    .fetch_optional(&*app_state.pool) // FIXED: app_state.pool
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "User not found".to_string(),
        }),
    ))?;

    // Create new token
    let new_token = app_state.auth.create_token_with_session(user.id, user.role.clone(), claims.jti) // FIXED: app_state.auth
        .map_err(|_| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to create token".to_string(),
            }),
        ))?;

    let expires_at = Utc::now() + Duration::hours(24);

    let response = LoginResponse {
        token: new_token,
        session_id: claims.jti.unwrap_or_default(),
        user: UserInfo {
            id: user.id,
            username: user.username,
            email: user.email,
            role: user.role.as_str().to_string(),
            reputation_score: user.reputation_score.unwrap_or(0), // FIXED: gestione Option<i32>
            avatar_url: user.avatar_url,
        },
        expires_at: expires_at.to_rfc3339(),
    };

    Ok(Json(response))
}