// src/handlers/auth.rs
// FIXED: Convertito da Extension a State e corretto reputation_score

use axum::{
    extract::State, // FIXED: State invece di Extension
    http::{StatusCode, HeaderMap},
    Json,
};
use serde::{Serialize, Deserialize};
use uuid::Uuid;
use chrono::{Utc, Duration};
use tower_cookies::Cookies;

use crate::auth::Claims;
use crate::models::user::{User, Role, LoginCredentials, UserSession, NewUser};
use crate::state::AppState; // FIXED: Import AppState
use crate::middleware::jwt_cookie::{set_jwt_cookie, set_refresh_token_cookie, clear_auth_cookies};

// Account lockout configuration
const MAX_FAILED_LOGIN_ATTEMPTS: i32 = 5;
const LOCKOUT_DURATION_MINUTES: i64 = 30;

#[derive(Serialize)]
pub struct LoginResponse {
    // Token removed - now sent via httpOnly cookie
    session_id: String,
    user: UserInfo,
    expires_at: String,
    message: String, // Informational message for frontend
}

#[derive(Serialize)]
pub struct UserInfo {
    id: Uuid,
    username: String,
    email: String,
    role: String,
    reputation_score: i32, // FIXED: i32 invece di Option<i32>
    avatar_url: Option<String>,
}

#[derive(Serialize)]
pub struct ErrorResponse {
    error: String,
}

// Password reset structs
#[derive(Deserialize)]
pub struct PasswordResetRequest {
    pub email: String,
}

#[allow(dead_code)]
#[derive(Deserialize)]
pub struct PasswordResetConfirm {
    pub token: String,
    pub new_password: String,
}

// Enhanced login with session tracking - FIXED: convertito a State
pub async fn login(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    cookies: Cookies,
    headers: HeaderMap,
    Json(credentials): Json<LoginCredentials>,
) -> Result<Json<LoginResponse>, (StatusCode, Json<ErrorResponse>)> {
    // Get user IP and user agent
    let ip_str = headers
        .get("x-forwarded-for")
        .and_then(|h| h.to_str().ok())
        .and_then(|s| s.split(',').next())
        .unwrap_or("unknown");

    // Parse IP address to IpNetwork (handle both single IP and CIDR notation)
    let ip_address = ip_str.parse::<ipnetwork::IpNetwork>().ok();

    let user_agent = headers
        .get("user-agent")
        .and_then(|h| h.to_str().ok())
        .map(|s| s.to_string());
    
    // Find user by username
    let user = sqlx::query_as!(
        User,
        r#"
        SELECT id, username, email, password_hash, role as "role: Role",
               reputation_score, avatar_url, last_login, failed_login_attempts,
               account_locked_until, two_factor_enabled, two_factor_secret,
               phone_number, bio, preferred_language, email_verified,
               email_verification_token, email_verification_sent_at,
               email_verification_expires_at, created_at, updated_at
        FROM users
        WHERE username = $1
        "#,
        credentials.username
    )
    .fetch_optional(&*app_state.pool) // FIXED: app_state.pool
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?;
    
    let user = match user {
        Some(u) => u,
        None => {
            return Err((
                StatusCode::UNAUTHORIZED,
                Json(ErrorResponse {
                    error: "Invalid credentials".to_string(),
                }),
            ));
        }
    };

    // Check if account is locked
    let now = Utc::now();
    if let Some(locked_until) = user.account_locked_until {
        if locked_until > now {
            // Account is still locked
            let remaining_minutes = (locked_until - now).num_minutes();
            return Err((
                StatusCode::FORBIDDEN,
                Json(ErrorResponse {
                    error: format!("Account is locked due to too many failed login attempts. Please try again in {} minutes.", remaining_minutes),
                }),
            ));
        } else {
            // Lockout period has expired, auto-unlock the account
            sqlx::query!(
                "UPDATE users SET account_locked_until = NULL, failed_login_attempts = 0 WHERE id = $1",
                user.id
            )
            .execute(&*app_state.pool)
            .await
            .ok(); // Ignore errors, we'll still proceed with login
        }
    }

    // Verify password
    let is_valid = app_state.auth.verify_password(&credentials.password, &user.password_hash) // FIXED: app_state.auth
        .map_err(|_| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Password verification failed".to_string(),
            }),
        ))?;

    if !is_valid {
        // Increment failed login attempts
        let new_failed_attempts = user.failed_login_attempts.unwrap_or(0) + 1;

        // Check if we need to lock the account
        if new_failed_attempts >= MAX_FAILED_LOGIN_ATTEMPTS {
            let lock_until = now + Duration::minutes(LOCKOUT_DURATION_MINUTES);
            sqlx::query!(
                "UPDATE users SET failed_login_attempts = $1, account_locked_until = $2 WHERE id = $3",
                new_failed_attempts,
                lock_until,
                user.id
            )
            .execute(&*app_state.pool)
            .await
            .ok(); // Ignore errors, we still return auth failure

            // Audit: Failed login attempt with account lock
            let ip_parsed = ip_str.parse().ok();
            crate::audit::audit(crate::audit::AuditAction::LoginFailed)
                .user_id(user.id)
                .ip_address(ip_parsed.unwrap_or(std::net::IpAddr::V4(std::net::Ipv4Addr::UNSPECIFIED)))
                .user_agent(user_agent.clone().unwrap_or_default())
                .new_values(&serde_json::json!({
                    "failed_attempts": new_failed_attempts,
                    "account_locked": true,
                    "locked_until": lock_until
                }))
                .log_async((*app_state.pool).clone());

            return Err((
                StatusCode::FORBIDDEN,
                Json(ErrorResponse {
                    error: format!("Too many failed login attempts. Account locked for {} minutes.", LOCKOUT_DURATION_MINUTES),
                }),
            ));
        } else {
            // Just increment failed attempts
            sqlx::query!(
                "UPDATE users SET failed_login_attempts = $1 WHERE id = $2",
                new_failed_attempts,
                user.id
            )
            .execute(&*app_state.pool)
            .await
            .ok(); // Ignore errors

            // Audit: Failed login attempt
            let ip_parsed = ip_str.parse().ok();
            crate::audit::audit(crate::audit::AuditAction::LoginFailed)
                .user_id(user.id)
                .ip_address(ip_parsed.unwrap_or(std::net::IpAddr::V4(std::net::Ipv4Addr::UNSPECIFIED)))
                .user_agent(user_agent.clone().unwrap_or_default())
                .new_values(&serde_json::json!({
                    "failed_attempts": new_failed_attempts,
                    "remaining_attempts": MAX_FAILED_LOGIN_ATTEMPTS - new_failed_attempts
                }))
                .log_async((*app_state.pool).clone());

            return Err((
                StatusCode::UNAUTHORIZED,
                Json(ErrorResponse {
                    error: format!("Invalid credentials. {} attempts remaining before account lockout.", MAX_FAILED_LOGIN_ATTEMPTS - new_failed_attempts),
                }),
            ));
        }
    }

    // Generate session token and expiry
    let session_token = format!("sess_{}", Uuid::new_v4());
    let expires_at = Utc::now() + Duration::hours(24);
    
    // Create session
    let session = sqlx::query_as!(
        UserSession,
        r#"
        INSERT INTO user_sessions (user_id, session_token, ip_address, user_agent, expires_at)
        VALUES ($1, $2, $3, $4, $5)
        RETURNING id, user_id, session_token, ip_address, user_agent,
                  device_info, created_at as "created_at!", last_activity as "last_activity!",
                  expires_at as "expires_at!", is_active, revoked_at, revoked_reason
        "#,
        user.id,
        session_token,
        ip_address,
        user_agent,
        expires_at
    )
    .fetch_one(&*app_state.pool) // FIXED: app_state.pool
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to create session: {}", e),
        }),
    ))?;

    // Create JWT token with session ID
    let token = app_state.auth.create_token_with_session(user.id, user.role.clone(), Some(session.id.to_string())) // FIXED: app_state.auth
        .map_err(|_| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to create token".to_string(),
            }),
        ))?;

    // Update last login and reset failed login attempts
    sqlx::query!(
        "UPDATE users SET last_login = NOW(), failed_login_attempts = 0, account_locked_until = NULL WHERE id = $1",
        user.id
    )
    .execute(&*app_state.pool) // FIXED: app_state.pool
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to update last login: {}", e),
        }),
    ))?;

    // Set JWT token as httpOnly cookie (secure!)
    set_jwt_cookie(&cookies, &token, &app_state.config.security.cookies);

    // Audit: Successful login
    let ip_parsed = ip_str.parse().ok();
    crate::audit::audit(crate::audit::AuditAction::Login)
        .user_id(user.id)
        .ip_address(ip_parsed.unwrap_or(std::net::IpAddr::V4(std::net::Ipv4Addr::UNSPECIFIED)))
        .user_agent(user_agent.clone().unwrap_or_default())
        .log_async((*app_state.pool).clone());

    // Generate and set refresh token if enabled
    if app_state.config.auth.enable_refresh_tokens {
        if let Some(refresh_duration) = app_state.config.auth.refresh_token_duration_hours {
            let refresh_token = format!("refresh_{}", Uuid::new_v4());
            // In production, store refresh token in database with user_id and expiry
            set_refresh_token_cookie(&cookies, &refresh_token, &app_state.config.security.cookies, refresh_duration as i64);
        }
    }

    // Check if email is verified and add warning message if not
    let email_verified = user.email_verified;
    let message = if email_verified {
        "Authentication successful. Token set in secure cookie.".to_string()
    } else {
        "Authentication successful. Token set in secure cookie. Warning: Please verify your email address to access all features.".to_string()
    };

    let response = LoginResponse {
        // Token no longer sent in response body - now in httpOnly cookie!
        session_id: session.id.to_string(),
        user: UserInfo {
            id: user.id,
            username: user.username,
            email: user.email,
            role: user.role.as_str().to_string(),
            reputation_score: user.reputation_score.unwrap_or(0), // FIXED: gestione Option<i32>
            avatar_url: user.avatar_url,
        },
        expires_at: expires_at.to_rfc3339(),
        message,
    };

    Ok(Json(response))
}

// Logout - revoke session - FIXED: convertito a State
pub async fn logout(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    cookies: Cookies,
    claims: Claims,
) -> Result<StatusCode, (StatusCode, Json<ErrorResponse>)> {
    if let Some(session_id) = claims.jti {
        let session_uuid = session_id.parse::<Uuid>().map_err(|_| (
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: "Invalid session ID".to_string(),
            }),
        ))?;

        sqlx::query!(
            r#"
            UPDATE user_sessions 
            SET is_active = false, revoked_at = NOW(), revoked_reason = 'user_logout'
            WHERE id = $1
            "#,
            session_uuid
        )
        .execute(&*app_state.pool) // FIXED: app_state.pool
        .await
        .map_err(|e| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Failed to revoke session: {}", e),
            }),
        ))?;
    }

    // Clear authentication cookies
    clear_auth_cookies(&cookies, &app_state.config.security.cookies);

    // Audit: Logout
    let user_id = claims.sub.parse::<Uuid>().ok();
    if let Some(uid) = user_id {
        crate::audit::audit(crate::audit::AuditAction::Logout)
            .user_id(uid)
            .log_async((*app_state.pool).clone());
    }

    Ok(StatusCode::NO_CONTENT)
}

// Refresh token - FIXED: convertito a State
pub async fn refresh_token(
    State(app_state): State<AppState>,
    cookies: Cookies,
    claims: Claims,
) -> Result<Json<LoginResponse>, (StatusCode, Json<ErrorResponse>)> {
    let user_id = claims.sub.parse::<Uuid>().map_err(|_| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: "Invalid user ID".to_string(),
        }),
    ))?;

    // Get user data
    let user = sqlx::query_as!(
        User,
        r#"
        SELECT id, username, email, password_hash, role as "role: Role",
               reputation_score, avatar_url, last_login, failed_login_attempts,
               account_locked_until, two_factor_enabled, two_factor_secret,
               phone_number, bio, preferred_language, email_verified,
               email_verification_token, email_verification_sent_at,
               email_verification_expires_at, created_at, updated_at
        FROM users
        WHERE id = $1
        "#,
        user_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "User not found".to_string(),
        }),
    ))?;

    // FIXED: Clone jti before using it
    let session_id = claims.jti.clone();
    
    // Create new token
    let new_token = app_state.auth.create_token_with_session(user.id, user.role.clone(), claims.jti)
        .map_err(|_| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to create token".to_string(),
            }),
        ))?;

    let expires_at = Utc::now() + Duration::hours(24);

    // Set JWT in httpOnly cookie
    set_jwt_cookie(&cookies, &new_token, &app_state.config.security.cookies);

    let response = LoginResponse {
        session_id: session_id.unwrap_or_default(), // FIXED: Use cloned value
        user: UserInfo {
            id: user.id,
            username: user.username,
            email: user.email,
            role: user.role.as_str().to_string(),
            reputation_score: user.reputation_score.unwrap_or(0),
            avatar_url: user.avatar_url,
        },
        expires_at: expires_at.to_rfc3339(),
        message: "Token refreshed successfully. New token set in secure cookie.".to_string(),
    };

    Ok(Json(response))
}

#[derive(Serialize)]
pub struct ForgotPasswordResponse {
    message: String,
}

/// Request password reset - sends email with reset link
/// For security, always returns success even if email doesn't exist
pub async fn forgot_password(
    State(app_state): State<AppState>,
    Json(request): Json<PasswordResetRequest>,
) -> Result<Json<ForgotPasswordResponse>, (StatusCode, Json<ErrorResponse>)> {
    // Check if user exists (but don't reveal this to the client)
    let user_exists = sqlx::query_scalar::<_, bool>(
        "SELECT EXISTS(SELECT 1 FROM users WHERE email = $1)"
    )
    .bind(&request.email)
    .fetch_one(&*app_state.pool)
    .await
    .unwrap_or(false);

    if user_exists {
        // TODO: In production, generate a reset token and send email
        // For now, just log the request
        tracing::info!("Password reset requested for email: {}", request.email);

        // In a real implementation:
        // 1. Generate a secure random token
        // 2. Store token in database with expiry (e.g., 1 hour)
        // 3. Send email with reset link containing the token
    }

    // Always return success for security (don't reveal if email exists)
    Ok(Json(ForgotPasswordResponse {
        message: "Se l'indirizzo email Ã¨ registrato, riceverai un'email con le istruzioni per reimpostare la password.".to_string(),
    }))
}

#[derive(Deserialize)]
pub struct VerifyEmailRequest {
    pub token: String,
}

#[derive(Serialize)]
pub struct VerifyEmailResponse {
    success: bool,
    message: String,
}

/// Verify email address with token
pub async fn verify_email(
    State(app_state): State<AppState>,
    Json(request): Json<VerifyEmailRequest>,
) -> Result<Json<VerifyEmailResponse>, (StatusCode, Json<ErrorResponse>)> {
    // Find user with this verification token
    let user = sqlx::query!(
        r#"
        SELECT id, email, email_verification_expires_at
        FROM users
        WHERE email_verification_token = $1 AND email_verified = false
        "#,
        request.token
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?;

    let user = match user {
        Some(u) => u,
        None => {
            return Err((
                StatusCode::BAD_REQUEST,
                Json(ErrorResponse {
                    error: "Invalid or expired verification token".to_string(),
                }),
            ));
        }
    };

    // Check if token has expired
    if let Some(expires_at) = user.email_verification_expires_at {
        if expires_at < Utc::now() {
            return Err((
                StatusCode::BAD_REQUEST,
                Json(ErrorResponse {
                    error: "Verification token has expired. Please request a new one.".to_string(),
                }),
            ));
        }
    }

    // Mark email as verified and clear token
    sqlx::query!(
        r#"
        UPDATE users
        SET email_verified = true,
            email_verification_token = NULL,
            email_verification_sent_at = NULL,
            email_verification_expires_at = NULL,
            updated_at = NOW()
        WHERE id = $1
        "#,
        user.id
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to verify email: {}", e),
        }),
    ))?;

    // Audit: Email verified
    crate::audit::audit(crate::audit::AuditAction::UserUpdated)
        .user_id(user.id)
        .entity("user", user.id)
        .new_values(&serde_json::json!({
            "email_verified": true,
            "email": user.email
        }))
        .log_async((*app_state.pool).clone());

    tracing::info!("Email verified successfully for user: {}", user.email);

    Ok(Json(VerifyEmailResponse {
        success: true,
        message: "Email verified successfully! You can now log in.".to_string(),
    }))
}

#[derive(Deserialize)]
pub struct ResendVerificationRequest {
    pub email: String,
}

#[derive(Serialize)]
pub struct ResendVerificationResponse {
    message: String,
}

/// Resend email verification
pub async fn resend_verification(
    State(app_state): State<AppState>,
    Json(request): Json<ResendVerificationRequest>,
) -> Result<Json<ResendVerificationResponse>, (StatusCode, Json<ErrorResponse>)> {
    // Find user by email (only if not already verified)
    let user = sqlx::query!(
        r#"
        SELECT id, email, email_verified
        FROM users
        WHERE email = $1
        "#,
        request.email
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?;

    // Always return success for security (don't reveal if email exists)
    if let Some(user) = user {
        // Check if already verified
        if user.email_verified {
            return Ok(Json(ResendVerificationResponse {
                message: "If your email is not verified, a new verification link has been sent.".to_string(),
            }));
        }

        // Generate new verification token
        let verification_token = format!("verify_{}", Uuid::new_v4());
        let verification_expires_at = Utc::now() + Duration::hours(24);

        // Update user with new token
        sqlx::query!(
            r#"
            UPDATE users
            SET email_verification_token = $1,
                email_verification_sent_at = NOW(),
                email_verification_expires_at = $2,
                updated_at = NOW()
            WHERE id = $3
            "#,
            verification_token,
            verification_expires_at,
            user.id
        )
        .execute(&*app_state.pool)
        .await
        .map_err(|e| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Failed to update verification token: {}", e),
            }),
        ))?;

        // TODO: Send verification email here
        // For now, log the token (in production, this should be sent via email)
        tracing::info!(
            "New verification token for {}: {} (expires at {})",
            user.email,
            verification_token,
            verification_expires_at
        );
    }

    // Always return success for security (don't reveal if email exists)
    Ok(Json(ResendVerificationResponse {
        message: "If your email is not verified, a new verification link has been sent.".to_string(),
#[derive(Serialize)]
pub struct RegisterResponse {
    user: UserInfo,
    message: String,
}

/// Self-registration endpoint - allows users to create an account
pub async fn register(
    State(app_state): State<AppState>,
    Json(new_user): Json<NewUser>,
) -> Result<Json<RegisterResponse>, (StatusCode, Json<ErrorResponse>)> {
    // Hash password
    let password_hash = app_state.auth.hash_password(&new_user.password)
        .map_err(|e| (
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: format!("Password validation failed: {}", e),
            }),
        ))?;

    // Default role is 'user' (regular user, not admin or team leader)
    let role = Role::User;

    // Create user in database
    let user = sqlx::query_as!(
        User,
        r#"
        INSERT INTO users (username, email, password_hash, role)
        VALUES ($1, $2, $3, $4)
        RETURNING id, username, email, password_hash, role as "role: Role",
                  reputation_score, avatar_url, last_login, failed_login_attempts,
                  account_locked_until, two_factor_enabled, two_factor_secret,
                  phone_number, bio, preferred_language, created_at, updated_at
        "#,
        new_user.username,
        new_user.email,
        password_hash,
        role as _
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| {
        let error_message = if e.to_string().contains("duplicate key") {
            if e.to_string().contains("username") {
                "Username already taken".to_string()
            } else {
                "Email already registered".to_string()
            }
        } else {
            format!("Registration failed: {}", e)
        };
        (
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse { error: error_message }),
        )
    })?;

    Ok(Json(RegisterResponse {
        user: UserInfo {
            id: user.id,
            username: user.username,
            email: user.email,
            role: user.role.as_str().to_string(),
            reputation_score: user.reputation_score.unwrap_or(0),
            avatar_url: user.avatar_url,
        },
        message: "Registration successful. You can now login.".to_string(),
    }))
}