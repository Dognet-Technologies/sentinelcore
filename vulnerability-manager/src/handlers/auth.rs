// src/handlers/auth.rs
// FIXED: Convertito da Extension a State e corretto reputation_score

use axum::{
    extract::State, // FIXED: State invece di Extension
    http::{StatusCode, HeaderMap},
    Json,
};
use serde::{Serialize, Deserialize};
use uuid::Uuid;
use chrono::{Utc, Duration};
use tower_cookies::Cookies;

use crate::auth::Claims;
use crate::models::user::{User, Role, LoginCredentials, UserSession, NewUser};
use crate::state::AppState; // FIXED: Import AppState
use crate::middleware::jwt_cookie::{set_jwt_cookie, set_refresh_token_cookie, clear_auth_cookies};

#[derive(Serialize)]
pub struct LoginResponse {
    // Token removed - now sent via httpOnly cookie
    session_id: String,
    user: UserInfo,
    expires_at: String,
    message: String, // Informational message for frontend
}

#[derive(Serialize)]
pub struct UserInfo {
    id: Uuid,
    username: String,
    email: String,
    role: String,
    reputation_score: i32, // FIXED: i32 invece di Option<i32>
    avatar_url: Option<String>,
}

#[derive(Serialize)]
pub struct ErrorResponse {
    error: String,
}

// Password reset structs
#[derive(Deserialize)]
pub struct PasswordResetRequest {
    pub email: String,
}

#[allow(dead_code)]
#[derive(Deserialize)]
pub struct PasswordResetConfirm {
    pub token: String,
    pub new_password: String,
}

// Enhanced login with session tracking - FIXED: convertito a State
pub async fn login(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    cookies: Cookies,
    headers: HeaderMap,
    Json(credentials): Json<LoginCredentials>,
) -> Result<Json<LoginResponse>, (StatusCode, Json<ErrorResponse>)> {
    // Get user IP and user agent
    let ip_str = headers
        .get("x-forwarded-for")
        .and_then(|h| h.to_str().ok())
        .and_then(|s| s.split(',').next())
        .unwrap_or("unknown");

    // Parse IP address to IpNetwork (handle both single IP and CIDR notation)
    let ip_address = ip_str.parse::<ipnetwork::IpNetwork>().ok();

    let user_agent = headers
        .get("user-agent")
        .and_then(|h| h.to_str().ok())
        .map(|s| s.to_string());
    
    // Find user by username
    let user = sqlx::query_as!(
        User,
        r#"
        SELECT id, username, email, password_hash, role as "role: Role",
               reputation_score, avatar_url, last_login, failed_login_attempts,
               account_locked_until, two_factor_enabled, two_factor_secret,
               phone_number, bio, preferred_language, created_at, updated_at
        FROM users 
        WHERE username = $1
        "#,
        credentials.username
    )
    .fetch_optional(&*app_state.pool) // FIXED: app_state.pool
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?;
    
    let user = match user {
        Some(u) => u,
        None => {
            return Err((
                StatusCode::UNAUTHORIZED,
                Json(ErrorResponse {
                    error: "Invalid credentials".to_string(),
                }),
            ));
        }
    };

    // Verify password
    let is_valid = app_state.auth.verify_password(&credentials.password, &user.password_hash) // FIXED: app_state.auth
        .map_err(|_| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Password verification failed".to_string(),
            }),
        ))?;

    if !is_valid {
        return Err((
            StatusCode::UNAUTHORIZED,
            Json(ErrorResponse {
                error: "Invalid credentials".to_string(),
            }),
        ));
    }

    // Generate session token and expiry
    let session_token = format!("sess_{}", Uuid::new_v4());
    let expires_at = Utc::now() + Duration::hours(24);
    
    // Create session
    let session = sqlx::query_as!(
        UserSession,
        r#"
        INSERT INTO user_sessions (user_id, session_token, ip_address, user_agent, expires_at)
        VALUES ($1, $2, $3, $4, $5)
        RETURNING id, user_id, session_token, ip_address, user_agent,
                  device_info, created_at as "created_at!", last_activity as "last_activity!",
                  expires_at as "expires_at!", is_active, revoked_at, revoked_reason
        "#,
        user.id,
        session_token,
        ip_address,
        user_agent,
        expires_at
    )
    .fetch_one(&*app_state.pool) // FIXED: app_state.pool
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to create session: {}", e),
        }),
    ))?;

    // Create JWT token with session ID
    let token = app_state.auth.create_token_with_session(user.id, user.role.clone(), Some(session.id.to_string())) // FIXED: app_state.auth
        .map_err(|_| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to create token".to_string(),
            }),
        ))?;

    // Update last login
    sqlx::query!(
        "UPDATE users SET last_login = NOW() WHERE id = $1",
        user.id
    )
    .execute(&*app_state.pool) // FIXED: app_state.pool
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to update last login: {}", e),
        }),
    ))?;

    // Set JWT token as httpOnly cookie (secure!)
    set_jwt_cookie(&cookies, &token, &app_state.config.security.cookies);

    // Generate and set refresh token if enabled
    if app_state.config.auth.enable_refresh_tokens {
        if let Some(refresh_duration) = app_state.config.auth.refresh_token_duration_hours {
            let refresh_token = format!("refresh_{}", Uuid::new_v4());
            // In production, store refresh token in database with user_id and expiry
            set_refresh_token_cookie(&cookies, &refresh_token, &app_state.config.security.cookies, refresh_duration as i64);
        }
    }

    let response = LoginResponse {
        // Token no longer sent in response body - now in httpOnly cookie!
        session_id: session.id.to_string(),
        user: UserInfo {
            id: user.id,
            username: user.username,
            email: user.email,
            role: user.role.as_str().to_string(),
            reputation_score: user.reputation_score.unwrap_or(0), // FIXED: gestione Option<i32>
            avatar_url: user.avatar_url,
        },
        expires_at: expires_at.to_rfc3339(),
        message: "Authentication successful. Token set in secure cookie.".to_string(),
    };

    Ok(Json(response))
}

// Logout - revoke session - FIXED: convertito a State
pub async fn logout(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    cookies: Cookies,
    claims: Claims,
) -> Result<StatusCode, (StatusCode, Json<ErrorResponse>)> {
    if let Some(session_id) = claims.jti {
        let session_uuid = session_id.parse::<Uuid>().map_err(|_| (
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: "Invalid session ID".to_string(),
            }),
        ))?;

        sqlx::query!(
            r#"
            UPDATE user_sessions 
            SET is_active = false, revoked_at = NOW(), revoked_reason = 'user_logout'
            WHERE id = $1
            "#,
            session_uuid
        )
        .execute(&*app_state.pool) // FIXED: app_state.pool
        .await
        .map_err(|e| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Failed to revoke session: {}", e),
            }),
        ))?;
    }

    // Clear authentication cookies
    clear_auth_cookies(&cookies, &app_state.config.security.cookies);

    Ok(StatusCode::NO_CONTENT)
}

// Refresh token - FIXED: convertito a State
pub async fn refresh_token(
    State(app_state): State<AppState>,
    cookies: Cookies,
    claims: Claims,
) -> Result<Json<LoginResponse>, (StatusCode, Json<ErrorResponse>)> {
    let user_id = claims.sub.parse::<Uuid>().map_err(|_| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: "Invalid user ID".to_string(),
        }),
    ))?;

    // Get user data
    let user = sqlx::query_as!(
        User,
        r#"
        SELECT id, username, email, password_hash, role as "role: Role",
               reputation_score, avatar_url, last_login, failed_login_attempts,
               account_locked_until, two_factor_enabled, two_factor_secret,
               phone_number, bio, preferred_language, created_at, updated_at
        FROM users 
        WHERE id = $1
        "#,
        user_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "User not found".to_string(),
        }),
    ))?;

    // FIXED: Clone jti before using it
    let session_id = claims.jti.clone();
    
    // Create new token
    let new_token = app_state.auth.create_token_with_session(user.id, user.role.clone(), claims.jti)
        .map_err(|_| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to create token".to_string(),
            }),
        ))?;

    let expires_at = Utc::now() + Duration::hours(24);

    // Set JWT in httpOnly cookie
    set_jwt_cookie(&cookies, &new_token, &app_state.config.security.cookies);

    let response = LoginResponse {
        session_id: session_id.unwrap_or_default(), // FIXED: Use cloned value
        user: UserInfo {
            id: user.id,
            username: user.username,
            email: user.email,
            role: user.role.as_str().to_string(),
            reputation_score: user.reputation_score.unwrap_or(0),
            avatar_url: user.avatar_url,
        },
        expires_at: expires_at.to_rfc3339(),
        message: "Token refreshed successfully. New token set in secure cookie.".to_string(),
    };

    Ok(Json(response))
}

#[derive(Serialize)]
pub struct ForgotPasswordResponse {
    message: String,
}

/// Request password reset - sends email with reset link
/// For security, always returns success even if email doesn't exist
pub async fn forgot_password(
    State(app_state): State<AppState>,
    Json(request): Json<PasswordResetRequest>,
) -> Result<Json<ForgotPasswordResponse>, (StatusCode, Json<ErrorResponse>)> {
    // Check if user exists (but don't reveal this to the client)
    let user_exists = sqlx::query_scalar::<_, bool>(
        "SELECT EXISTS(SELECT 1 FROM users WHERE email = $1)"
    )
    .bind(&request.email)
    .fetch_one(&*app_state.pool)
    .await
    .unwrap_or(false);

    if user_exists {
        // TODO: In production, generate a reset token and send email
        // For now, just log the request
        tracing::info!("Password reset requested for email: {}", request.email);

        // In a real implementation:
        // 1. Generate a secure random token
        // 2. Store token in database with expiry (e.g., 1 hour)
        // 3. Send email with reset link containing the token
    }

    // Always return success for security (don't reveal if email exists)
    Ok(Json(ForgotPasswordResponse {
        message: "Se l'indirizzo email Ã¨ registrato, riceverai un'email con le istruzioni per reimpostare la password.".to_string(),
    }))
}

#[derive(Serialize)]
pub struct RegisterResponse {
    user: UserInfo,
    message: String,
}

/// Self-registration endpoint - allows users to create an account
pub async fn register(
    State(app_state): State<AppState>,
    Json(new_user): Json<NewUser>,
) -> Result<Json<RegisterResponse>, (StatusCode, Json<ErrorResponse>)> {
    // Hash password
    let password_hash = app_state.auth.hash_password(&new_user.password)
        .map_err(|e| (
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: format!("Password validation failed: {}", e),
            }),
        ))?;

    // Default role is 'user' (regular user, not admin or team leader)
    let role = Role::User;

    // Create user in database
    let user = sqlx::query_as!(
        User,
        r#"
        INSERT INTO users (username, email, password_hash, role)
        VALUES ($1, $2, $3, $4)
        RETURNING id, username, email, password_hash, role as "role: Role",
                  reputation_score, avatar_url, last_login, failed_login_attempts,
                  account_locked_until, two_factor_enabled, two_factor_secret,
                  phone_number, bio, preferred_language, created_at, updated_at
        "#,
        new_user.username,
        new_user.email,
        password_hash,
        role as _
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| {
        let error_message = if e.to_string().contains("duplicate key") {
            if e.to_string().contains("username") {
                "Username already taken".to_string()
            } else {
                "Email already registered".to_string()
            }
        } else {
            format!("Registration failed: {}", e)
        };
        (
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse { error: error_message }),
        )
    })?;

    Ok(Json(RegisterResponse {
        user: UserInfo {
            id: user.id,
            username: user.username,
            email: user.email,
            role: user.role.as_str().to_string(),
            reputation_score: user.reputation_score.unwrap_or(0),
            avatar_url: user.avatar_url,
        },
        message: "Registration successful. You can now login.".to_string(),
    }))
}