// src/handlers/notification_rules.rs
// Notification routing rules management

use axum::{
    extract::{Path, State},
    http::StatusCode,
    Json,
};
use serde::{Deserialize, Serialize};
use uuid::Uuid;
use chrono::{DateTime, Utc, NaiveTime};

use crate::auth::Claims;
use crate::state::AppState;

#[derive(Debug, Serialize, Deserialize)]
pub struct NotificationChannel {
    pub id: Uuid,
    pub name: String,
    pub channel_type: String,
    pub is_enabled: bool,
    pub configuration: serde_json::Value,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct NotificationRule {
    pub id: Uuid,
    pub name: String,
    pub description: Option<String>,
    pub priority: i32,
    pub is_enabled: bool,
    pub conditions: serde_json::Value,
    pub channels: Vec<Uuid>,
    pub email_recipients: Option<Vec<String>>,
    pub user_ids: Option<Vec<Uuid>>,
    pub team_ids: Option<Vec<Uuid>>,
    pub role_filter: Option<String>,
    pub immediate: bool,
    pub throttle_minutes: i32,
    pub quiet_hours_start: Option<NaiveTime>,
    pub quiet_hours_end: Option<NaiveTime>,
    pub message_template: Option<String>,
    pub include_details: bool,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Debug, Deserialize)]
pub struct CreateNotificationRule {
    pub name: String,
    pub description: Option<String>,
    pub priority: Option<i32>,
    pub is_enabled: Option<bool>,
    pub conditions: serde_json::Value,
    pub channels: Vec<Uuid>,
    pub email_recipients: Option<Vec<String>>,
    pub user_ids: Option<Vec<Uuid>>,
    pub team_ids: Option<Vec<Uuid>>,
    pub role_filter: Option<String>,
    pub immediate: Option<bool>,
    pub throttle_minutes: Option<i32>,
    pub quiet_hours_start: Option<NaiveTime>,
    pub quiet_hours_end: Option<NaiveTime>,
    pub message_template: Option<String>,
    pub include_details: Option<bool>,
}

#[derive(Debug, Deserialize)]
pub struct UpdateNotificationRule {
    pub name: Option<String>,
    pub description: Option<String>,
    pub priority: Option<i32>,
    pub is_enabled: Option<bool>,
    pub conditions: Option<serde_json::Value>,
    pub channels: Option<Vec<Uuid>>,
    pub email_recipients: Option<Vec<String>>,
    pub user_ids: Option<Vec<Uuid>>,
    pub team_ids: Option<Vec<Uuid>>,
    pub role_filter: Option<String>,
    pub immediate: Option<bool>,
    pub throttle_minutes: Option<i32>,
    pub quiet_hours_start: Option<NaiveTime>,
    pub quiet_hours_end: Option<NaiveTime>,
    pub message_template: Option<String>,
    pub include_details: Option<bool>,
}

#[derive(Debug, Deserialize)]
pub struct CreateNotificationChannel {
    pub name: String,
    pub channel_type: String,
    pub is_enabled: Option<bool>,
    pub configuration: serde_json::Value,
}

#[derive(Debug, Deserialize)]
pub struct TestRuleRequest {
    pub vulnerability_data: serde_json::Value,
}

#[derive(Debug, Serialize)]
pub struct TestRuleResponse {
    pub matches: bool,
    pub message: String,
}

#[derive(Debug, Serialize)]
pub struct ErrorResponse {
    pub error: String,
}

// List all notification rules
pub async fn list_notification_rules(
    State(app_state): State<AppState>,
    _claims: Claims,
) -> Result<Json<Vec<NotificationRule>>, (StatusCode, Json<ErrorResponse>)> {
    let rules = sqlx::query_as!(
        NotificationRule,
        r#"
        SELECT
            id,
            name,
            description,
            priority,
            is_enabled,
            conditions,
            channels,
            email_recipients,
            user_ids,
            team_ids,
            role_filter,
            immediate,
            throttle_minutes,
            quiet_hours_start,
            quiet_hours_end,
            message_template,
            include_details,
            created_at,
            updated_at
        FROM notification_rules
        ORDER BY priority ASC, created_at DESC
        "#
    )
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to list notification rules: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to list notification rules".to_string(),
            }),
        )
    })?;

    Ok(Json(rules))
}

// Get notification rule by ID
pub async fn get_notification_rule(
    State(app_state): State<AppState>,
    Path(rule_id): Path<Uuid>,
    _claims: Claims,
) -> Result<Json<NotificationRule>, (StatusCode, Json<ErrorResponse>)> {
    let rule = sqlx::query_as!(
        NotificationRule,
        r#"
        SELECT
            id,
            name,
            description,
            priority,
            is_enabled,
            conditions,
            channels,
            email_recipients,
            user_ids,
            team_ids,
            role_filter,
            immediate,
            throttle_minutes,
            quiet_hours_start,
            quiet_hours_end,
            message_template,
            include_details,
            created_at,
            updated_at
        FROM notification_rules
        WHERE id = $1
        "#,
        rule_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch notification rule: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to fetch notification rule".to_string(),
            }),
        )
    })?
    .ok_or_else(|| {
        (
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Notification rule not found".to_string(),
            }),
        )
    })?;

    Ok(Json(rule))
}

// Create notification rule
pub async fn create_notification_rule(
    State(app_state): State<AppState>,
    claims: Claims,
    Json(payload): Json<CreateNotificationRule>,
) -> Result<Json<NotificationRule>, (StatusCode, Json<ErrorResponse>)> {
    let user_id = claims.sub.parse::<Uuid>().map_err(|_| {
        (
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: "Invalid user ID".to_string(),
            }),
        )
    })?;

    let rule = sqlx::query_as!(
        NotificationRule,
        r#"
        INSERT INTO notification_rules (
            name, description, priority, is_enabled, conditions, channels,
            email_recipients, user_ids, team_ids, role_filter, immediate,
            throttle_minutes, quiet_hours_start, quiet_hours_end,
            message_template, include_details, created_by
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17)
        RETURNING
            id,
            name,
            description,
            priority,
            is_enabled,
            conditions,
            channels,
            email_recipients,
            user_ids,
            team_ids,
            role_filter,
            immediate,
            throttle_minutes,
            quiet_hours_start,
            quiet_hours_end,
            message_template,
            include_details,
            created_at,
            updated_at
        "#,
        payload.name,
        payload.description,
        payload.priority.unwrap_or(100),
        payload.is_enabled.unwrap_or(true),
        payload.conditions,
        &payload.channels,
        payload.email_recipients.as_deref(),
        payload.user_ids.as_deref(),
        payload.team_ids.as_deref(),
        payload.role_filter,
        payload.immediate.unwrap_or(true),
        payload.throttle_minutes.unwrap_or(0),
        payload.quiet_hours_start,
        payload.quiet_hours_end,
        payload.message_template,
        payload.include_details.unwrap_or(true),
        user_id
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to create notification rule: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Failed to create notification rule: {}", e),
            }),
        )
    })?;

    Ok(Json(rule))
}

// Update notification rule
pub async fn update_notification_rule(
    State(app_state): State<AppState>,
    Path(rule_id): Path<Uuid>,
    _claims: Claims,
    Json(payload): Json<UpdateNotificationRule>,
) -> Result<Json<NotificationRule>, (StatusCode, Json<ErrorResponse>)> {
    let rule = sqlx::query_as!(
        NotificationRule,
        r#"
        UPDATE notification_rules
        SET
            name = COALESCE($2, name),
            description = COALESCE($3, description),
            priority = COALESCE($4, priority),
            is_enabled = COALESCE($5, is_enabled),
            conditions = COALESCE($6, conditions),
            channels = COALESCE($7, channels),
            email_recipients = COALESCE($8, email_recipients),
            user_ids = COALESCE($9, user_ids),
            team_ids = COALESCE($10, team_ids),
            role_filter = COALESCE($11, role_filter),
            immediate = COALESCE($12, immediate),
            throttle_minutes = COALESCE($13, throttle_minutes),
            quiet_hours_start = COALESCE($14, quiet_hours_start),
            quiet_hours_end = COALESCE($15, quiet_hours_end),
            message_template = COALESCE($16, message_template),
            include_details = COALESCE($17, include_details),
            updated_at = NOW()
        WHERE id = $1
        RETURNING
            id,
            name,
            description,
            priority,
            is_enabled,
            conditions,
            channels,
            email_recipients,
            user_ids,
            team_ids,
            role_filter,
            immediate,
            throttle_minutes,
            quiet_hours_start,
            quiet_hours_end,
            message_template,
            include_details,
            created_at,
            updated_at
        "#,
        rule_id,
        payload.name,
        payload.description,
        payload.priority,
        payload.is_enabled,
        payload.conditions,
        payload.channels.as_deref(),
        payload.email_recipients.as_deref(),
        payload.user_ids.as_deref(),
        payload.team_ids.as_deref(),
        payload.role_filter,
        payload.immediate,
        payload.throttle_minutes,
        payload.quiet_hours_start,
        payload.quiet_hours_end,
        payload.message_template,
        payload.include_details
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to update notification rule: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to update notification rule".to_string(),
            }),
        )
    })?
    .ok_or_else(|| {
        (
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Notification rule not found".to_string(),
            }),
        )
    })?;

    Ok(Json(rule))
}

// Delete notification rule
pub async fn delete_notification_rule(
    State(app_state): State<AppState>,
    Path(rule_id): Path<Uuid>,
    _claims: Claims,
) -> Result<StatusCode, (StatusCode, Json<ErrorResponse>)> {
    let result = sqlx::query!(
        "DELETE FROM notification_rules WHERE id = $1",
        rule_id
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to delete notification rule: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to delete notification rule".to_string(),
            }),
        )
    })?;

    if result.rows_affected() == 0 {
        return Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Notification rule not found".to_string(),
            }),
        ));
    }

    Ok(StatusCode::NO_CONTENT)
}

// Test notification rule
pub async fn test_notification_rule(
    State(app_state): State<AppState>,
    Path(rule_id): Path<Uuid>,
    _claims: Claims,
    Json(payload): Json<TestRuleRequest>,
) -> Result<Json<TestRuleResponse>, (StatusCode, Json<ErrorResponse>)> {
    // Get the rule
    let rule = sqlx::query!(
        "SELECT conditions FROM notification_rules WHERE id = $1",
        rule_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch rule: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to fetch rule".to_string(),
            }),
        )
    })?
    .ok_or_else(|| {
        (
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Rule not found".to_string(),
            }),
        )
    })?;

    // Test the rule using the database function
    let matches = sqlx::query_scalar!(
        "SELECT evaluate_rule_conditions($1, $2)",
        rule.conditions,
        payload.vulnerability_data
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to evaluate rule: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to evaluate rule".to_string(),
            }),
        )
    })?
    .unwrap_or(false);

    Ok(Json(TestRuleResponse {
        matches,
        message: if matches {
            "Rule matches the provided vulnerability data".to_string()
        } else {
            "Rule does not match the provided vulnerability data".to_string()
        },
    }))
}

// List notification channels
pub async fn list_notification_channels(
    State(app_state): State<AppState>,
    _claims: Claims,
) -> Result<Json<Vec<NotificationChannel>>, (StatusCode, Json<ErrorResponse>)> {
    let channels = sqlx::query_as!(
        NotificationChannel,
        r#"
        SELECT id, name, channel_type, is_enabled, configuration, created_at, updated_at
        FROM notification_channels
        ORDER BY name ASC
        "#
    )
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to list notification channels: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to list notification channels".to_string(),
            }),
        )
    })?;

    Ok(Json(channels))
}

// Create notification channel
pub async fn create_notification_channel(
    State(app_state): State<AppState>,
    _claims: Claims,
    Json(payload): Json<CreateNotificationChannel>,
) -> Result<Json<NotificationChannel>, (StatusCode, Json<ErrorResponse>)> {
    let channel = sqlx::query_as!(
        NotificationChannel,
        r#"
        INSERT INTO notification_channels (name, channel_type, is_enabled, configuration)
        VALUES ($1, $2, $3, $4)
        RETURNING id, name, channel_type, is_enabled, configuration, created_at, updated_at
        "#,
        payload.name,
        payload.channel_type,
        payload.is_enabled.unwrap_or(true),
        payload.configuration
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to create notification channel: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Failed to create notification channel: {}", e),
            }),
        )
    })?;

    Ok(Json(channel))
}

// Delete notification channel
pub async fn delete_notification_channel(
    State(app_state): State<AppState>,
    Path(channel_id): Path<Uuid>,
    _claims: Claims,
) -> Result<StatusCode, (StatusCode, Json<ErrorResponse>)> {
    let result = sqlx::query!(
        "DELETE FROM notification_channels WHERE id = $1",
        channel_id
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to delete notification channel: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to delete notification channel".to_string(),
            }),
        )
    })?;

    if result.rows_affected() == 0 {
        return Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Notification channel not found".to_string(),
            }),
        ));
    }

    Ok(StatusCode::NO_CONTENT)
}
