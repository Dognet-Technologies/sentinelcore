use axum::{
    extract::{Path, Extension},
    http::StatusCode,
    Json,
};
use sqlx::PgPool;
use std::sync::Arc;
use serde::Serialize;
use uuid::Uuid;

use crate::models::{Team, TeamMember, NewTeam, UpdateTeam, NewTeamMember};

#[derive(Debug, Serialize)]
pub struct ErrorResponse {
    pub error: String,
}

// LIST - Ottieni lista team
pub async fn list_teams(
    Extension(pool): Extension<Arc<PgPool>>,
) -> Result<Json<Vec<Team>>, (StatusCode, Json<ErrorResponse>)> {
    let teams = sqlx::query_as!(
        Team,
        r#"
        SELECT id, name, description, contact_email, slack_webhook, 
               telegram_chat_id, created_at, updated_at
        FROM teams
        ORDER BY name ASC
        "#
    )
    .fetch_all(&*pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore nel recupero dei team: {}", e),
        }),
    ))?;

    Ok(Json(teams))
}

// GET - Ottieni singolo team
pub async fn get_team(
    Extension(pool): Extension<Arc<PgPool>>,
    Path(team_id): Path<Uuid>,
) -> Result<Json<Team>, (StatusCode, Json<ErrorResponse>)> {
    let team = sqlx::query_as!(
        Team,
        r#"
        SELECT id, name, description, contact_email, slack_webhook, 
               telegram_chat_id, created_at, updated_at
        FROM teams
        WHERE id = $1
        "#,
        team_id
    )
    .fetch_optional(&*pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore database: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Team non trovato".to_string(),
        }),
    ))?;

    Ok(Json(team))
}

// CREATE - Crea nuovo team
pub async fn create_team(
    Extension(pool): Extension<Arc<PgPool>>,
    Json(new_team): Json<NewTeam>,
) -> Result<Json<Team>, (StatusCode, Json<ErrorResponse>)> {
    let team = sqlx::query_as!(
        Team,
        r#"
        INSERT INTO teams (name, description, contact_email, slack_webhook, telegram_chat_id)
        VALUES ($1, $2, $3, $4, $5)
        RETURNING id, name, description, contact_email, slack_webhook, 
                  telegram_chat_id, created_at, updated_at
        "#,
        new_team.name,
        new_team.description,
        new_team.contact_email,
        new_team.slack_webhook,
        new_team.telegram_chat_id
    )
    .fetch_one(&*pool)
    .await
    .map_err(|e| {
        let error_message = if e.to_string().contains("duplicate key") {
            "Nome team già esistente".to_string()
        } else {
            format!("Errore durante la creazione: {}", e)
        };
        (
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse { error: error_message }),
        )
    })?;

    Ok(Json(team))
}

// UPDATE - Aggiorna team
pub async fn update_team(
    Extension(pool): Extension<Arc<PgPool>>,
    Path(team_id): Path<Uuid>,
    Json(update_data): Json<UpdateTeam>,
) -> Result<Json<Team>, (StatusCode, Json<ErrorResponse>)> {
    let team = sqlx::query_as!(
        Team,
        r#"
        UPDATE teams
        SET 
            name = COALESCE($2, name),
            description = COALESCE($3, description),
            contact_email = COALESCE($4, contact_email),
            slack_webhook = COALESCE($5, slack_webhook),
            telegram_chat_id = COALESCE($6, telegram_chat_id),
            updated_at = NOW()
        WHERE id = $1
        RETURNING id, name, description, contact_email, slack_webhook, 
                  telegram_chat_id, created_at, updated_at
        "#,
        team_id,
        update_data.name,
        update_data.description,
        update_data.contact_email,
        update_data.slack_webhook,
        update_data.telegram_chat_id
    )
    .fetch_optional(&*pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore durante l'aggiornamento: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Team non trovato".to_string(),
        }),
    ))?;

    Ok(Json(team))
}

// DELETE - Elimina team (CORRETTO)
pub async fn delete_team(
    Extension(pool): Extension<Arc<PgPool>>,
    Path(team_id): Path<Uuid>,
) -> Result<StatusCode, (StatusCode, Json<ErrorResponse>)> {
    // Prima verifica se ci sono vulnerabilità assegnate al team
    let assigned_vulns = sqlx::query_scalar!(
        "SELECT COUNT(*) FROM vulnerabilities WHERE assigned_team_id = $1",
        team_id
    )
    .fetch_one(&*pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore durante il controllo: {}", e),
        }),
    ))?
    .unwrap_or(0);

    if assigned_vulns > 0 {
        return Err((
            StatusCode::CONFLICT,
            Json(ErrorResponse {
                error: format!("Impossibile eliminare: il team ha {} vulnerabilità assegnate", assigned_vulns),
            }),
        ));
    }

    let result = sqlx::query!(
        "DELETE FROM teams WHERE id = $1",
        team_id
    )
    .execute(&*pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore durante l'eliminazione: {}", e),
        }),
    ))?;

    if result.rows_affected() == 0 {
        return Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Team non trovato".to_string(),
            }),
        ));
    }

    Ok(StatusCode::NO_CONTENT)
}

// Aggiungi membro al team
pub async fn add_team_member(
    Extension(pool): Extension<Arc<PgPool>>,
    Path(team_id): Path<Uuid>,
    Json(new_member): Json<NewTeamMember>,
) -> Result<Json<TeamMember>, (StatusCode, Json<ErrorResponse>)> {
    // Verifica che il team esista
    let team_exists = sqlx::query_scalar!(
        "SELECT EXISTS(SELECT 1 FROM teams WHERE id = $1)",
        team_id
    )
    .fetch_one(&*pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore database: {}", e),
        }),
    ))?;

    if !team_exists.unwrap_or(false) {
        return Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Team non trovato".to_string(),
            }),
        ));
    }

    let member = sqlx::query_as!(
        TeamMember,
        r#"
        INSERT INTO team_members (team_id, name, email)
        VALUES ($1, $2, $3)
        RETURNING id, team_id, name, email, created_at
        "#,
        team_id,
        new_member.name,
        new_member.email
    )
    .fetch_one(&*pool)
    .await
    .map_err(|e| {
        let error_message = if e.to_string().contains("duplicate key") {
            "Membro già presente nel team".to_string()
        } else {
            format!("Errore durante l'aggiunta: {}", e)
        };
        (
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse { error: error_message }),
        )
    })?;

    Ok(Json(member))
}

// Rimuovi membro dal team
pub async fn remove_team_member(
    Extension(pool): Extension<Arc<PgPool>>,
    Path((team_id, member_id)): Path<(Uuid, Uuid)>,
) -> Result<StatusCode, (StatusCode, Json<ErrorResponse>)> {
    let result = sqlx::query!(
        "DELETE FROM team_members WHERE team_id = $1 AND id = $2",
        team_id,
        member_id
    )
    .execute(&*pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore durante la rimozione: {}", e),
        }),
    ))?;

    if result.rows_affected() == 0 {
        return Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Membro non trovato nel team".to_string(),
            }),
        ));
    }

    Ok(StatusCode::NO_CONTENT)
}

// Ottieni membri del team
pub async fn get_team_members(
    Extension(pool): Extension<Arc<PgPool>>,
    Path(team_id): Path<Uuid>,
) -> Result<Json<Vec<TeamMember>>, (StatusCode, Json<ErrorResponse>)> {
    let members = sqlx::query_as!(
        TeamMember,
        r#"
        SELECT id, team_id, name, email, created_at
        FROM team_members
        WHERE team_id = $1
        ORDER BY name ASC
        "#,
        team_id
    )
    .fetch_all(&*pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore nel recupero dei membri: {}", e),
        }),
    ))?;

    Ok(Json(members))
}