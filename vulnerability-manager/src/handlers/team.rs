// src/handlers/team.rs - FIXED: Convertito a State
use axum::{
    extract::{Path, State}, // FIXED: State invece di Extension
    http::StatusCode,
    Json,
};
use serde::Serialize;
use uuid::Uuid;

use crate::models::{Team, TeamMember, NewTeam, UpdateTeam, NewTeamMember};
use crate::state::AppState;

#[derive(Debug, Serialize)]
pub struct ErrorResponse {
    pub error: String,
}

// LIST - Ottieni lista team - FIXED: State
pub async fn list_teams(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
) -> Result<Json<Vec<Team>>, (StatusCode, Json<ErrorResponse>)> {
    let teams = sqlx::query_as!(
        Team,
        r#"
        SELECT id, name, description, contact_email, slack_webhook, 
               telegram_chat_id, created_at, updated_at
        FROM teams
        WHERE deleted_at IS NULL
        ORDER BY name ASC
        "#
    )
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore nel recupero dei team: {}", e),
        }),
    ))?;

    Ok(Json(teams))
}

// GET - Ottieni singolo team - FIXED: State
pub async fn get_team(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    Path(team_id): Path<Uuid>,
) -> Result<Json<Team>, (StatusCode, Json<ErrorResponse>)> {
    let team = sqlx::query_as!(
        Team,
        r#"
        SELECT id, name, description, contact_email, slack_webhook, 
               telegram_chat_id, created_at, updated_at
        FROM teams
        WHERE id = $1 AND deleted_at IS NULL
        "#,
        team_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore database: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Team non trovato".to_string(),
        }),
    ))?;

    Ok(Json(team))
}

// CREATE - Crea nuovo team - FIXED: State
pub async fn create_team(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    claims: crate::auth::Claims,
    Json(new_team): Json<NewTeam>,
) -> Result<Json<Team>, (StatusCode, Json<ErrorResponse>)> {
    let team = sqlx::query_as!(
        Team,
        r#"
        INSERT INTO teams (name, description, contact_email, slack_webhook, telegram_chat_id)
        VALUES ($1, $2, $3, $4, $5)
        RETURNING id, name, description, contact_email, slack_webhook,
                  telegram_chat_id, created_at, updated_at
        "#,
        new_team.name,
        new_team.description,
        new_team.contact_email,
        new_team.slack_webhook,
        new_team.telegram_chat_id
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| {
        let error_message = if e.to_string().contains("duplicate key") {
            "Nome team già esistente".to_string()
        } else {
            format!("Errore durante la creazione: {}", e)
        };
        (
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse { error: error_message }),
        )
    })?;

    // Audit: Team created
    let user_id = claims.sub.parse::<uuid::Uuid>().ok();
    if let Some(uid) = user_id {
        crate::audit::audit(crate::audit::AuditAction::TeamCreated)
            .user_id(uid)
            .entity("team", team.id)
            .new_values(&team)
            .log_async((*app_state.pool).clone());
    }

    Ok(Json(team))
}

// UPDATE - Aggiorna team - FIXED: State
pub async fn update_team(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    claims: crate::auth::Claims,
    Path(team_id): Path<Uuid>,
    Json(update_data): Json<UpdateTeam>,
) -> Result<Json<Team>, (StatusCode, Json<ErrorResponse>)> {
    // Fetch old team for audit logging
    let old_team = sqlx::query_as!(
        Team,
        r#"
        SELECT id, name, description, contact_email, slack_webhook,
               telegram_chat_id, created_at, updated_at
        FROM teams
        WHERE id = $1 AND deleted_at IS NULL
        "#,
        team_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore database: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Team non trovato".to_string(),
        }),
    ))?;

    let team = sqlx::query_as!(
        Team,
        r#"
        UPDATE teams
        SET
            name = COALESCE($2, name),
            description = COALESCE($3, description),
            contact_email = COALESCE($4, contact_email),
            slack_webhook = COALESCE($5, slack_webhook),
            telegram_chat_id = COALESCE($6, telegram_chat_id),
            updated_at = NOW()
        WHERE id = $1
        RETURNING id, name, description, contact_email, slack_webhook,
                  telegram_chat_id, created_at, updated_at
        "#,
        team_id,
        update_data.name,
        update_data.description,
        update_data.contact_email,
        update_data.slack_webhook,
        update_data.telegram_chat_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore durante l'aggiornamento: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Team non trovato".to_string(),
        }),
    ))?;

    // Audit: Team updated
    let user_id = claims.sub.parse::<uuid::Uuid>().ok();
    if let Some(uid) = user_id {
        crate::audit::audit(crate::audit::AuditAction::TeamUpdated)
            .user_id(uid)
            .entity("team", team.id)
            .old_values(&old_team)
            .new_values(&team)
            .log_async((*app_state.pool).clone());
    }

    Ok(Json(team))
}

// DELETE - Elimina team - FIXED: State
pub async fn delete_team(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    claims: crate::auth::Claims,
    Path(team_id): Path<Uuid>,
) -> Result<StatusCode, (StatusCode, Json<ErrorResponse>)> {
    // Prima verifica se ci sono vulnerabilità assegnate al team
    let assigned_vulns = sqlx::query_scalar::<_, i64>(
        "SELECT COUNT(*) FROM vulnerabilities WHERE assigned_team_id = $1 AND deleted_at IS NULL"
    )
    .bind(team_id)
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore durante il controllo: {}", e),
        }),
    ))?;

    if assigned_vulns > 0 {
        return Err((
            StatusCode::CONFLICT,
            Json(ErrorResponse {
                error: format!("Impossibile eliminare: il team ha {} vulnerabilità assegnate", assigned_vulns),
            }),
        ));
    }

    // Soft delete: set deleted_at timestamp instead of hard delete
    let result = sqlx::query(
        "UPDATE teams SET deleted_at = NOW() WHERE id = $1 AND deleted_at IS NULL"
    )
    .bind(team_id)
    .execute(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore durante l'eliminazione: {}", e),
        }),
    ))?;

    if result.rows_affected() == 0 {
        return Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Team non trovato o già eliminato".to_string(),
            }),
        ));
    }

    // Audit: Team deleted
    let user_id = claims.sub.parse::<uuid::Uuid>().ok();
    if let Some(uid) = user_id {
        crate::audit::audit(crate::audit::AuditAction::TeamDeleted)
            .user_id(uid)
            .entity("team", team_id)
            .log_async((*app_state.pool).clone());
    }

    Ok(StatusCode::NO_CONTENT)
}

// Aggiungi membro al team - FIXED: State
pub async fn add_team_member(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    Path(team_id): Path<Uuid>,
    Json(new_member): Json<NewTeamMember>,
) -> Result<Json<TeamMember>, (StatusCode, Json<ErrorResponse>)> {
    // Verifica che il team esista
    let team_exists = sqlx::query_scalar!(
        "SELECT EXISTS(SELECT 1 FROM teams WHERE id = $1)",
        team_id
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore database: {}", e),
        }),
    ))?;

    if !team_exists.unwrap_or(false) {
        return Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Team non trovato".to_string(),
            }),
        ));
    }

    // Support adding by user_id OR user_email OR by name+email
    let (actual_user_id, member_name, member_email) = if let Some(user_id) = new_member.user_id {
        // Lookup user by ID
        let user: Option<(String, String)> = sqlx::query_as(
            "SELECT username, email FROM users WHERE id = $1 AND deleted_at IS NULL"
        )
        .bind(user_id)
        .fetch_optional(&*app_state.pool)
        .await
        .map_err(|e| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Database error: {}", e),
            }),
        ))?;

        let (username, email) = user.ok_or_else(|| (
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "User not found".to_string(),
            }),
        ))?;

        (Some(user_id), username, email)
    } else if let Some(user_email) = &new_member.user_email {
        // Lookup user by email
        let user: Option<(Uuid, String, String)> = sqlx::query_as(
            "SELECT id, username, email FROM users WHERE email = $1 AND deleted_at IS NULL"
        )
        .bind(user_email)
        .fetch_optional(&*app_state.pool)
        .await
        .map_err(|e| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Database error: {}", e),
            }),
        ))?;

        let (uid, username, email) = user.ok_or_else(|| (
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: format!("User with email {} not found", user_email),
            }),
        ))?;

        (Some(uid), username, email)
    } else if let (Some(name), Some(email)) = (&new_member.name, &new_member.email) {
        // Use provided name and email for external members
        (None, name.clone(), email.clone())
    } else {
        return Err((
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: "Either user_id OR user_email OR both name and email must be provided".to_string(),
            }),
        ));
    };

    let member = sqlx::query_as!(
        TeamMember,
        r#"
        INSERT INTO team_members (team_id, user_id, name, email, role)
        VALUES ($1, $2, $3, $4, $5)
        RETURNING id, team_id, user_id, name, email, role, joined_at, removed_at, created_at
        "#,
        team_id,
        actual_user_id,
        member_name,
        member_email,
        new_member.role.as_deref()
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| {
        let error_message = if e.to_string().contains("duplicate key") {
            "Utente già presente nel team".to_string()
        } else {
            format!("Errore durante l'aggiunta: {}", e)
        };
        (
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse { error: error_message }),
        )
    })?;

    Ok(Json(member))
}

// Rimuovi membro dal team - FIXED: State
pub async fn remove_team_member(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    Path((team_id, member_id)): Path<(Uuid, Uuid)>,
) -> Result<StatusCode, (StatusCode, Json<ErrorResponse>)> {
    let result = sqlx::query!(
        "DELETE FROM team_members WHERE team_id = $1 AND id = $2",
        team_id,
        member_id
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore durante la rimozione: {}", e),
        }),
    ))?;

    if result.rows_affected() == 0 {
        return Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Membro non trovato nel team".to_string(),
            }),
        ));
    }

    Ok(StatusCode::NO_CONTENT)
}

// Ottieni membri del team - FIXED: State
pub async fn get_team_members(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    Path(team_id): Path<Uuid>,
) -> Result<Json<Vec<TeamMember>>, (StatusCode, Json<ErrorResponse>)> {
    let members = sqlx::query_as!(
        TeamMember,
        r#"
        SELECT id, team_id, user_id, name, email, role, joined_at, removed_at, created_at
        FROM team_members
        WHERE team_id = $1 AND removed_at IS NULL
        ORDER BY name ASC
        "#,
        team_id
    )
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore nel recupero dei membri: {}", e),
        }),
    ))?;

    Ok(Json(members))
}

// Assegna un utente a un team - FIXED: State
pub async fn assign_user_to_team(
    State(app_state): State<AppState>,
    Path(team_id): Path<Uuid>,
    Json(request): Json<crate::models::team::AssignUserToTeamRequest>,
) -> Result<Json<TeamMember>, (StatusCode, Json<ErrorResponse>)> {
    // Verifica che il team esista
    let team_exists = sqlx::query_scalar!(
        "SELECT EXISTS(SELECT 1 FROM teams WHERE id = $1)",
        team_id
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore database: {}", e),
        }),
    ))?;

    if !team_exists.unwrap_or(false) {
        return Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Team non trovato".to_string(),
            }),
        ));
    }

    // Verifica che l'utente esista
    let user = sqlx::query!(
        "SELECT username, email FROM users WHERE id = $1",
        request.user_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore database: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Utente non trovato".to_string(),
        }),
    ))?;

    let role = request.role.unwrap_or_else(|| "contributor".to_string());

    let member = sqlx::query_as!(
        TeamMember,
        r#"
        INSERT INTO team_members (team_id, user_id, name, email, role)
        VALUES ($1, $2, $3, $4, $5)
        ON CONFLICT (team_id, user_id) WHERE user_id IS NOT NULL AND removed_at IS NULL
        DO UPDATE
        SET
            role = EXCLUDED.role,
            removed_at = NULL,
            joined_at = NOW()
        RETURNING id, team_id, user_id, name, email, role, joined_at, removed_at, created_at
        "#,
        team_id,
        request.user_id,
        user.username,
        user.email,
        role
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore nell'assegnazione dell'utente: {}", e),
        }),
    ))?;

    Ok(Json(member))
}

// Aggiorna il ruolo di un membro nel team
pub async fn update_team_member_role(
    State(app_state): State<AppState>,
    Path((team_id, member_id)): Path<(Uuid, Uuid)>,
    Json(request): Json<crate::models::team::UpdateTeamMemberRole>,
) -> Result<Json<TeamMember>, (StatusCode, Json<ErrorResponse>)> {
    // Validazione del ruolo
    if !["contributor", "team_lead", "viewer"].contains(&request.role.as_str()) {
        return Err((
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: "Ruolo non valido. Deve essere 'contributor', 'team_lead' o 'viewer'".to_string(),
            }),
        ));
    }

    let member = sqlx::query_as!(
        TeamMember,
        r#"
        UPDATE team_members
        SET role = $3
        WHERE team_id = $1 AND id = $2 AND removed_at IS NULL
        RETURNING id, team_id, user_id, name, email, role, joined_at, removed_at, created_at
        "#,
        team_id,
        member_id,
        request.role
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore database: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Membro non trovato nel team".to_string(),
        }),
    ))?;

    Ok(Json(member))
}

// Rimuovi utente da team (soft delete)
pub async fn remove_user_from_team(
    State(app_state): State<AppState>,
    Path((team_id, user_id)): Path<(Uuid, Uuid)>,
) -> Result<StatusCode, (StatusCode, Json<ErrorResponse>)> {
    let result = sqlx::query!(
        "UPDATE team_members SET removed_at = NOW() WHERE team_id = $1 AND user_id = $2 AND removed_at IS NULL",
        team_id,
        user_id
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore nella rimozione: {}", e),
        }),
    ))?;

    if result.rows_affected() == 0 {
        return Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Utente non trovato nel team".to_string(),
            }),
        ));
    }

    Ok(StatusCode::NO_CONTENT)
}