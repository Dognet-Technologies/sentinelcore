// src/handlers/scanner_import.rs
// API handlers for importing vulnerability scan data from various security scanners

use crate::scanners::{ScannerRegistry, ParsedVulnerability};
use crate::state::AppState;
use axum::{
    extract::{Path, State, Multipart},
    http::StatusCode,
    Json,
};
use serde::{Deserialize, Serialize};
use std::sync::Arc;

#[derive(Debug, Serialize)]
pub struct ScanImportResponse {
    pub success: bool,
    pub scanner: String,
    pub format: String,
    pub vulnerabilities_found: usize,
    pub vulnerabilities_imported: usize,
    pub errors: Vec<String>,
}

#[derive(Debug, Deserialize)]
pub struct ScanImportRequest {
    pub scanner: String,
    pub format: String,
    pub data: String,
}

/// Import scan data from JSON request body
/// POST /api/scanners/import
pub async fn import_scan_json(
    State(app_state): State<AppState>,
    Json(request): Json<ScanImportRequest>,
) -> Result<Json<ScanImportResponse>, (StatusCode, String)> {
    tracing::info!(
        "Importing {} scan data ({} format, {} bytes)",
        request.scanner,
        request.format,
        request.data.len()
    );

    // Get scanner plugin from registry
    let registry = ScannerRegistry::new();
    let scanner = registry
        .get(&request.scanner)
        .ok_or_else(|| {
            (
                StatusCode::BAD_REQUEST,
                format!("Unknown scanner: {}", request.scanner),
            )
        })?;

    // Validate the data format
    let data_bytes = request.data.as_bytes();
    let is_valid = scanner
        .validate(data_bytes, &request.format)
        .map_err(|e| (StatusCode::BAD_REQUEST, format!("Validation error: {}", e)))?;

    if !is_valid {
        return Err((
            StatusCode::BAD_REQUEST,
            format!(
                "Data does not appear to be valid {} {} format",
                request.scanner, request.format
            ),
        ));
    }

    // Parse the scan data
    let vulnerabilities = scanner
        .parse(data_bytes, &request.format)
        .await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, format!("Parse error: {}", e)))?;

    let found_count = vulnerabilities.len();
    tracing::info!("Parsed {} vulnerabilities from scan", found_count);

    // TODO: Import vulnerabilities to database
    // For now, just return the count
    let imported_count = found_count; // Will be actual DB insert count later

    Ok(Json(ScanImportResponse {
        success: true,
        scanner: request.scanner,
        format: request.format,
        vulnerabilities_found: found_count,
        vulnerabilities_imported: imported_count,
        errors: vec![],
    }))
}

/// Import scan data from file upload
/// POST /api/scanners/import/:scanner/:format
pub async fn import_scan_file(
    State(app_state): State<AppState>,
    Path((scanner_name, format)): Path<(String, String)>,
    mut multipart: Multipart,
) -> Result<Json<ScanImportResponse>, (StatusCode, String)> {
    tracing::info!(
        "Importing {} scan file ({} format)",
        scanner_name,
        format
    );

    // Get scanner plugin from registry
    let registry = ScannerRegistry::new();
    let scanner = registry
        .get(&scanner_name)
        .ok_or_else(|| {
            (
                StatusCode::BAD_REQUEST,
                format!("Unknown scanner: {}", scanner_name),
            )
        })?;

    // Extract file data from multipart
    let mut file_data: Option<Vec<u8>> = None;

    while let Some(field) = multipart
        .next_field()
        .await
        .map_err(|e| (StatusCode::BAD_REQUEST, format!("Multipart error: {}", e)))?
    {
        if field.name() == Some("file") {
            let data = field
                .bytes()
                .await
                .map_err(|e| (StatusCode::BAD_REQUEST, format!("Failed to read file: {}", e)))?;
            file_data = Some(data.to_vec());
            break;
        }
    }

    let data = file_data.ok_or_else(|| {
        (
            StatusCode::BAD_REQUEST,
            "No file field found in request".to_string(),
        )
    })?;

    tracing::info!("Received file: {} bytes", data.len());

    // Validate the data format
    let is_valid = scanner
        .validate(&data, &format)
        .map_err(|e| (StatusCode::BAD_REQUEST, format!("Validation error: {}", e)))?;

    if !is_valid {
        return Err((
            StatusCode::BAD_REQUEST,
            format!(
                "File does not appear to be valid {} {} format",
                scanner_name, format
            ),
        ));
    }

    // Parse the scan data
    let vulnerabilities = scanner
        .parse(&data, &format)
        .await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, format!("Parse error: {}", e)))?;

    let found_count = vulnerabilities.len();
    tracing::info!("Parsed {} vulnerabilities from file", found_count);

    // TODO: Import vulnerabilities to database
    let imported_count = found_count;

    Ok(Json(ScanImportResponse {
        success: true,
        scanner: scanner_name,
        format,
        vulnerabilities_found: found_count,
        vulnerabilities_imported: imported_count,
        errors: vec![],
    }))
}

/// List available scanner plugins
/// GET /api/scanners
pub async fn list_scanners() -> Json<Vec<ScannerInfo>> {
    let registry = ScannerRegistry::new();
    let scanners = registry.list();

    let scanner_info: Vec<ScannerInfo> = scanners
        .iter()
        .map(|meta| ScannerInfo {
            name: meta.name.clone(),
            display_name: meta.display_name.clone(),
            vendor: meta.vendor.clone(),
            version: meta.version.clone(),
            description: meta.description.clone(),
            supported_formats: meta.supported_formats.clone(),
        })
        .collect();

    Json(scanner_info)
}

#[derive(Debug, Serialize)]
pub struct ScannerInfo {
    pub name: String,
    pub display_name: String,
    pub vendor: String,
    pub version: String,
    pub description: String,
    pub supported_formats: Vec<String>,
}
