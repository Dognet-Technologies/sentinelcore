// src/handlers/scanner_import.rs
// API handlers for importing vulnerability scan data from various security scanners

use crate::scanners::ScannerRegistry;
use crate::state::AppState;
use crate::models::{NewVulnerability, VulnerabilitySeverity, VulnerabilityStatus};
use axum::{
    extract::{Path, State, Multipart},
    http::StatusCode,
    Json,
};
use ipnetwork::IpNetwork;
use serde::{Deserialize, Serialize};
use std::str::FromStr;
use uuid::Uuid;

#[derive(Debug, Serialize)]
pub struct ScanImportResponse {
    pub success: bool,
    pub scanner: String,
    pub format: String,
    pub vulnerabilities_found: usize,
    pub vulnerabilities_imported: usize,
    pub errors: Vec<String>,
}

#[derive(Debug, Deserialize)]
pub struct ScanImportRequest {
    pub scanner: String,
    pub format: String,
    pub data: String,
}

/// Import scan data from JSON request body
/// POST /api/scanners/import
pub async fn import_scan_json(
    State(app_state): State<AppState>,
    Json(request): Json<ScanImportRequest>,
) -> Result<Json<ScanImportResponse>, (StatusCode, String)> {
    tracing::info!(
        "Importing {} scan data ({} format, {} bytes)",
        request.scanner,
        request.format,
        request.data.len()
    );

    // Get scanner plugin from registry
    let registry = ScannerRegistry::new();
    let scanner = registry
        .get(&request.scanner)
        .ok_or_else(|| {
            (
                StatusCode::BAD_REQUEST,
                format!("Unknown scanner: {}", request.scanner),
            )
        })?;

    // Validate the data format
    let data_bytes = request.data.as_bytes();
    let is_valid = scanner
        .validate(data_bytes, &request.format)
        .map_err(|e| (StatusCode::BAD_REQUEST, format!("Validation error: {}", e)))?;

    if !is_valid {
        return Err((
            StatusCode::BAD_REQUEST,
            format!(
                "Data does not appear to be valid {} {} format",
                request.scanner, request.format
            ),
        ));
    }

    // Parse the scan data
    let vulnerabilities = scanner
        .parse(data_bytes, &request.format)
        .await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, format!("Parse error: {}", e)))?;

    let found_count = vulnerabilities.len();
    tracing::info!("Parsed {} vulnerabilities from scan", found_count);

    // Import vulnerabilities to database
    let import_result = import_vulnerabilities_to_db(
        &app_state,
        &request.scanner,
        &request.format,
        None,
        vulnerabilities,
    )
    .await
    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e))?;

    Ok(Json(ScanImportResponse {
        success: true,
        scanner: request.scanner,
        format: request.format,
        vulnerabilities_found: import_result.total_vulnerabilities as usize,
        vulnerabilities_imported: import_result.imported_count as usize,
        errors: import_result.errors,
    }))
}

/// Import scan data from file upload
/// POST /api/scanners/import/:scanner/:format
pub async fn import_scan_file(
    State(app_state): State<AppState>,
    Path((scanner_name, format)): Path<(String, String)>,
    mut multipart: Multipart,
) -> Result<Json<ScanImportResponse>, (StatusCode, String)> {
    tracing::info!(
        "Importing {} scan file ({} format)",
        scanner_name,
        format
    );

    // Get scanner plugin from registry
    let registry = ScannerRegistry::new();
    let scanner = registry
        .get(&scanner_name)
        .ok_or_else(|| {
            (
                StatusCode::BAD_REQUEST,
                format!("Unknown scanner: {}", scanner_name),
            )
        })?;

    // Extract file data from multipart
    let mut file_data: Option<Vec<u8>> = None;

    while let Some(field) = multipart
        .next_field()
        .await
        .map_err(|e| (StatusCode::BAD_REQUEST, format!("Multipart error: {}", e)))?
    {
        if field.name() == Some("file") {
            let data = field
                .bytes()
                .await
                .map_err(|e| (StatusCode::BAD_REQUEST, format!("Failed to read file: {}", e)))?;
            file_data = Some(data.to_vec());
            break;
        }
    }

    let data = file_data.ok_or_else(|| {
        (
            StatusCode::BAD_REQUEST,
            "No file field found in request".to_string(),
        )
    })?;

    tracing::info!("Received file: {} bytes", data.len());

    // Validate the data format
    let is_valid = scanner
        .validate(&data, &format)
        .map_err(|e| (StatusCode::BAD_REQUEST, format!("Validation error: {}", e)))?;

    if !is_valid {
        return Err((
            StatusCode::BAD_REQUEST,
            format!(
                "File does not appear to be valid {} {} format",
                scanner_name, format
            ),
        ));
    }

    // Parse the scan data
    let vulnerabilities = scanner
        .parse(&data, &format)
        .await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, format!("Parse error: {}", e)))?;

    let found_count = vulnerabilities.len();
    tracing::info!("Parsed {} vulnerabilities from file", found_count);

    // Import vulnerabilities to database
    let import_result = import_vulnerabilities_to_db(
        &app_state,
        &scanner_name,
        &format,
        None,
        vulnerabilities,
    )
    .await
    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e))?;

    Ok(Json(ScanImportResponse {
        success: true,
        scanner: scanner_name,
        format,
        vulnerabilities_found: import_result.total_vulnerabilities as usize,
        vulnerabilities_imported: import_result.imported_count as usize,
        errors: import_result.errors,
    }))
}

/// List available scanner plugins
/// GET /api/scanners
pub async fn list_scanners() -> Json<Vec<ScannerInfo>> {
    let registry = ScannerRegistry::new();
    let scanners = registry.list();

    let scanner_info: Vec<ScannerInfo> = scanners
        .iter()
        .map(|meta| ScannerInfo {
            name: meta.name,
            display_name: meta.display_name,
            vendor: meta.vendor,
            version: meta.version,
            description: meta.description,
            supported_formats: meta.supported_formats.to_vec(),
        })
        .collect();

    Json(scanner_info)
}

#[derive(Debug, Serialize)]
pub struct ScannerInfo {
    pub name: &'static str,
    pub display_name: &'static str,
    pub vendor: &'static str,
    pub version: &'static str,
    pub description: &'static str,
    pub supported_formats: Vec<&'static str>,
}

#[derive(Debug, Serialize)]
struct ImportResult {
    pub total_vulnerabilities: i32,
    pub imported_count: i32,
    pub errors: Vec<String>,
}

async fn import_vulnerabilities_to_db(
    app_state: &AppState,
    scanner_name: &str,
    format: &str,
    source_filename: Option<String>,
    vulnerabilities: Vec<ParsedVulnerability>,
) -> Result<ImportResult, String> {
    let total_count = vulnerabilities.len() as i32;
    let mut imported_count = 0i32;
    let mut errors: Vec<String> = vec![];

    // Create scanner import record
    let import_id = Uuid::new_v4();
    let _ = sqlx::query(
        r#"
        INSERT INTO scanner_imports (id, scanner_name, format, source_filename, total_vulnerabilities)
        VALUES ($1, $2, $3, $4, $5)
        "#
    )
    .bind(import_id)
    .bind(scanner_name)
    .bind(format)
    .bind(&source_filename)
    .bind(total_count)
    .execute(&*app_state.pool)
    .await
    .map_err(|e| format!("Failed to create scanner import record: {}", e))?;

    // Insert each vulnerability
    for parsed_vuln in vulnerabilities {
        match parse_vulnerability(&parsed_vuln) {
            Ok(new_vuln) => {
                match insert_vulnerability(app_state, &new_vuln, &parsed_vuln, import_id).await {
                    Ok(_) => {
                        imported_count += 1;
                    }
                    Err(e) => {
                        let error_msg = format!(
                            "Failed to import {}: {}",
                            parsed_vuln.scanner_id, e
                        );
                        tracing::warn!("{}", error_msg);
                        errors.push(error_msg);
                    }
                }
            }
            Err(e) => {
                let error_msg = format!(
                    "Failed to parse {}: {}",
                    parsed_vuln.scanner_id, e
                );
                tracing::warn!("{}", error_msg);
                errors.push(error_msg);
            }
        }
    }

    // Update scanner import counts
    let _ = sqlx::query(
        "UPDATE scanner_imports SET imported_count = $1, skipped_count = $2 WHERE id = $3"
    )
    .bind(imported_count)
    .bind(total_count - imported_count)
    .bind(import_id)
    .execute(&*app_state.pool)
    .await;

    tracing::info!(
        "Scanner import completed: {}/{} vulnerabilities imported",
        imported_count,
        total_count
    );

    Ok(ImportResult {
        total_vulnerabilities: total_count,
        imported_count,
        errors,
    })
}

fn parse_vulnerability(parsed: &ParsedVulnerability) -> Result<NewVulnerability, String> {
    // Parse IP address from host
    let ip_network = IpNetwork::from_str(&parsed.host)
        .or_else(|_| {
            // If it's a hostname or service name, try to parse as a generic INET
            IpNetwork::from_str("0.0.0.0/32")
        })
        .map_err(|e| format!("Invalid host: {}", e))?;

    let cvss_score = parsed.cvss_score.unwrap_or(0.0);

    Ok(NewVulnerability {
        title: parsed.title.clone(),
        description: parsed.description.clone(),
        cvss_score,
        epss_score: None,
        ip_address: ip_network,
        hostname: Some(parsed.host.clone()),
        port: parsed.port.map(|p| p as i32),
        protocol: parsed.protocol.clone(),
        cve_id: parsed.cve_ids.first().cloned(),
        cwe_id: parsed.cwe_ids.first().cloned(),
        remediation: parsed.solution.clone(),
        source: "scanner_import".to_string(),
        discovered_at: parsed.first_detected,
        asset_id: None,
    })
}

async fn insert_vulnerability(
    app_state: &AppState,
    new_vuln: &NewVulnerability,
    parsed_vuln: &ParsedVulnerability,
    import_id: Uuid,
) -> Result<Uuid, String> {
    let vuln_id = Uuid::new_v4();
    let severity_str = match &parsed_vuln.severity {
        crate::scanners::VulnerabilitySeverity::Critical => "critical",
        crate::scanners::VulnerabilitySeverity::High => "high",
        crate::scanners::VulnerabilitySeverity::Medium => "medium",
        crate::scanners::VulnerabilitySeverity::Low => "low",
        crate::scanners::VulnerabilitySeverity::Info => "info",
    };

    let _ = sqlx::query(
        r#"
        INSERT INTO vulnerabilities (
            id, title, description, cvss_score, ip_address, hostname, port,
            protocol, status, severity, cve_id, cwe_id, remediation, source, discovered_at
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)
        "#
    )
    .bind(vuln_id)
    .bind(&new_vuln.title)
    .bind(&new_vuln.description)
    .bind(new_vuln.cvss_score)
    .bind(new_vuln.ip_address.to_string())
    .bind(&new_vuln.hostname)
    .bind(new_vuln.port)
    .bind(&new_vuln.protocol)
    .bind("open")
    .bind(severity_str)
    .bind(&new_vuln.cve_id)
    .bind(&new_vuln.cwe_id)
    .bind(&new_vuln.remediation)
    .bind(&new_vuln.source)
    .bind(new_vuln.discovered_at)
    .execute(&*app_state.pool)
    .await
    .map_err(|e| format!("Failed to insert vulnerability: {}", e))?;

    // Track import relationship
    let _ = sqlx::query(
        "INSERT INTO scanner_import_vulnerabilities (import_id, vulnerability_id, scanner_vulnerability_id) VALUES ($1, $2, $3)"
    )
    .bind(import_id)
    .bind(vuln_id)
    .bind(&parsed_vuln.scanner_id)
    .execute(&*app_state.pool)
    .await;

    Ok(vuln_id)
}
