use axum::{
    extract::{State, Path, Query},
    http::StatusCode,
    Json,
};
use serde_json::json;
use uuid::Uuid;
use serde::{Deserialize, Serialize};
use chrono::Utc;
use sqlx::types::BigDecimal;
use std::str::FromStr;

use crate::state::AppState;
use crate::auth::Claims;
use crate::models::resolution_stats::*;

#[derive(Serialize)]
pub struct ErrorResponse {
    error: String,
}

#[derive(Deserialize)]
pub struct PaginationQuery {
    page: Option<i64>,
    limit: Option<i64>,
}

pub async fn record_vulnerability_resolution(
    State(app_state): State<AppState>,
    claims: Claims,
    Json(request): Json<CreateResolutionRequest>,
) -> Result<Json<VulnerabilityResolution>, (StatusCode, Json<ErrorResponse>)> {
    let user_id = claims.sub.parse::<Uuid>().map_err(|_| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: "Invalid user ID".to_string(),
        }),
    ))?;

    // Verify vulnerability exists and is assigned to user
    let vuln = sqlx::query!(
        "SELECT id, assigned_user_id, severity::TEXT as severity FROM vulnerabilities WHERE id = $1",
        request.vulnerability_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|_| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: "Database error".to_string(),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Vulnerability non trovata".to_string(),
        }),
    ))?;

    // Calculate time to resolve
    let now = Utc::now();
    let assigned_at = sqlx::query_scalar::<_, chrono::DateTime<Utc>>(
        "SELECT created_at FROM vulnerabilities WHERE id = $1"
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|_| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: "Database error".to_string(),
        }),
    ))?;

    let time_to_resolve_hours = (now - assigned_at).num_hours() as f64;
    
    // Calculate resolution score based on time and severity
    let resolution_score = calculate_resolution_score(&time_to_resolve_hours, &vuln.severity);

    let row = sqlx::query!(
        r#"
        INSERT INTO vulnerability_resolutions (
            vulnerability_id, resolved_by, resolution_method, resolution_notes,
            assigned_at, resolved_at_actual, time_to_resolve_hours, resolution_score,
            quality_rating, quality_notes
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
        RETURNING id, vulnerability_id, resolved_by, resolved_at, resolution_method, 
                  resolution_notes, assigned_at, resolved_at_actual, time_to_resolve_hours,
                  sla_due_date, sla_met, sla_overdue_hours, verified_by, verified_at,
                  resolution_score, quality_rating, quality_notes, created_at, updated_at
        "#,
        request.vulnerability_id,
        user_id,
        request.resolution_method,
        request.resolution_notes,
        assigned_at,
        now,
        BigDecimal::from_str(&format!("{}", time_to_resolve_hours)).unwrap_or_default(),
        resolution_score,
        request.quality_rating,
        request.quality_notes
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore nel salvataggio della risoluzione: {}", e),
        }),
    ))?;

    let resolution = VulnerabilityResolution {
        id: row.id,
        vulnerability_id: row.vulnerability_id,
        resolved_by: row.resolved_by,
        resolved_at: row.resolved_at,
        resolution_method: row.resolution_method,
        resolution_notes: row.resolution_notes,
        assigned_at: row.assigned_at,
        resolved_at_actual: row.resolved_at_actual,
        time_to_resolve_hours: row.time_to_resolve_hours.map(|v| v.to_string()),
        sla_due_date: row.sla_due_date,
        sla_met: row.sla_met,
        sla_overdue_hours: row.sla_overdue_hours.map(|v| v.to_string()),
        verified_by: row.verified_by,
        verified_at: row.verified_at,
        resolution_score: row.resolution_score,
        quality_rating: row.quality_rating,
        quality_notes: row.quality_notes,
        created_at: row.created_at,
        updated_at: row.updated_at,
    };

    // Update vulnerability status
    sqlx::query!(
        "UPDATE vulnerabilities SET status = 'resolved' WHERE id = $1",
        request.vulnerability_id
    )
    .execute(&*app_state.pool)
    .await
    .ok();

    // Update user stats
    update_user_resolution_stats(&app_state, user_id, resolution_score.unwrap_or(0)).await.ok();

    Ok(Json(resolution))
}

pub async fn verify_resolution(
    State(app_state): State<AppState>,
    claims: Claims,
    Path(resolution_id): Path<Uuid>,
    Json(request): Json<VerifyResolutionRequest>,
) -> Result<Json<serde_json::Value>, (StatusCode, Json<ErrorResponse>)> {
    let verifier_id = claims.sub.parse::<Uuid>().map_err(|_| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: "Invalid user ID".to_string(),
        }),
    ))?;

    let now = Utc::now();

    sqlx::query!(
        "UPDATE vulnerability_resolutions 
         SET verified_by = $1, verified_at = $2, quality_rating = $3, quality_notes = $4
         WHERE id = $5",
        verifier_id,
        now,
        request.quality_rating,
        request.quality_notes,
        resolution_id
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore nella verifica: {}", e),
        }),
    ))?;

    Ok(Json(json!({
        "message": "Risoluzione verificata con successo"
    })))
}

pub async fn get_user_resolution_stats(
    State(app_state): State<AppState>,
    claims: Claims,
) -> Result<Json<UserResolutionStats>, (StatusCode, Json<ErrorResponse>)> {
    let user_id = claims.sub.parse::<Uuid>().map_err(|_| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: "Invalid user ID".to_string(),
        }),
    ))?;

    let row = sqlx::query!(
        "SELECT id, user_id, total_resolutions, verified_resolutions, unverified_resolutions,
                total_resolution_score, average_resolution_score, average_time_to_resolve_hours,
                fastest_resolution_hours, slowest_resolution_hours, sla_met_count, sla_missed_count,
                sla_compliance_percentage, average_quality_rating, high_quality_resolutions,
                current_resolution_streak, max_resolution_streak, resolutions_this_month,
                resolutions_this_quarter, created_at, updated_at
         FROM user_resolution_stats WHERE user_id = $1",
        user_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|_| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: "Database error".to_string(),
        }),
    ))?;

    let stats = match row {
        Some(r) => UserResolutionStats {
            id: r.id,
            user_id: r.user_id,
            total_resolutions: r.total_resolutions,
            verified_resolutions: r.verified_resolutions,
            unverified_resolutions: r.unverified_resolutions,
            total_resolution_score: r.total_resolution_score,
            average_resolution_score: r.average_resolution_score.map(|v| v.to_string()),
            average_time_to_resolve_hours: r.average_time_to_resolve_hours.map(|v| v.to_string()),
            fastest_resolution_hours: r.fastest_resolution_hours.map(|v| v.to_string()),
            slowest_resolution_hours: r.slowest_resolution_hours.map(|v| v.to_string()),
            sla_met_count: r.sla_met_count,
            sla_missed_count: r.sla_missed_count,
            sla_compliance_percentage: r.sla_compliance_percentage.map(|v| v.to_string()),
            average_quality_rating: r.average_quality_rating.map(|v| v.to_string()),
            high_quality_resolutions: r.high_quality_resolutions,
            current_resolution_streak: r.current_resolution_streak,
            max_resolution_streak: r.max_resolution_streak,
            resolutions_this_month: r.resolutions_this_month,
            resolutions_this_quarter: r.resolutions_this_quarter,
            created_at: r.created_at,
            updated_at: r.updated_at,
        },
        None => UserResolutionStats {
            id: Uuid::new_v4(),
            user_id,
            total_resolutions: Some(0),
            verified_resolutions: Some(0),
            unverified_resolutions: Some(0),
            total_resolution_score: Some(0),
            average_resolution_score: Some("0".to_string()),
            average_time_to_resolve_hours: Some("0".to_string()),
            fastest_resolution_hours: None,
            slowest_resolution_hours: None,
            sla_met_count: Some(0),
            sla_missed_count: Some(0),
            sla_compliance_percentage: Some("0".to_string()),
            average_quality_rating: Some("0".to_string()),
            high_quality_resolutions: Some(0),
            current_resolution_streak: Some(0),
            max_resolution_streak: Some(0),
            resolutions_this_month: Some(0),
            resolutions_this_quarter: Some(0),
            created_at: Utc::now(),
            updated_at: Utc::now(),
        },
    };

    Ok(Json(stats))
}

pub async fn get_team_resolution_stats(
    State(app_state): State<AppState>,
    Path(team_id): Path<Uuid>,
) -> Result<Json<TeamResolutionStats>, (StatusCode, Json<ErrorResponse>)> {
    let row = sqlx::query!(
        "SELECT id, team_id, total_resolutions, verified_resolutions, total_team_resolution_score,
                average_resolution_score, average_time_to_resolve_hours, sla_met_count, sla_missed_count,
                sla_compliance_percentage, average_quality_rating, active_contributors, 
                top_performer_user_id, resolutions_this_month, resolutions_this_quarter,
                created_at, updated_at
         FROM team_resolution_stats WHERE team_id = $1",
        team_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|_| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: "Database error".to_string(),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Team stats not found".to_string(),
        }),
    ))?;

    let stats = TeamResolutionStats {
        id: row.id,
        team_id: row.team_id,
        total_resolutions: row.total_resolutions,
        verified_resolutions: row.verified_resolutions,
        total_team_resolution_score: row.total_team_resolution_score,
        average_resolution_score: row.average_resolution_score.map(|v| v.to_string()),
        average_time_to_resolve_hours: row.average_time_to_resolve_hours.map(|v| v.to_string()),
        sla_met_count: row.sla_met_count,
        sla_missed_count: row.sla_missed_count,
        sla_compliance_percentage: row.sla_compliance_percentage.map(|v| v.to_string()),
        average_quality_rating: row.average_quality_rating.map(|v| v.to_string()),
        active_contributors: row.active_contributors,
        top_performer_user_id: row.top_performer_user_id,
        resolutions_this_month: row.resolutions_this_month,
        resolutions_this_quarter: row.resolutions_this_quarter,
        created_at: row.created_at,
        updated_at: row.updated_at,
    };

    Ok(Json(stats))
}

pub async fn get_resolution_leaderboard(
    State(app_state): State<AppState>,
    Query(params): Query<PaginationQuery>,
) -> Result<Json<Vec<ResolutionLeaderboardEntry>>, (StatusCode, Json<ErrorResponse>)> {
    let limit = params.limit.unwrap_or(10).min(100);
    let offset = (params.page.unwrap_or(1) - 1) * limit;

    let rows = sqlx::query!(
        r#"
        SELECT rl.id, rl.username, rl.avatar_url, rl.total_resolutions, rl.verified_resolutions,
               rl.total_resolution_score, rl.average_resolution_score, rl.average_time_to_resolve_hours,
               rl.sla_compliance_percentage, rl.average_quality_rating, rl.current_resolution_streak,
               ROW_NUMBER() OVER (ORDER BY rl.total_resolution_score DESC) as rank
        FROM resolution_leaderboard rl
        LIMIT $1 OFFSET $2
        "#,
        limit,
        offset
    )
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|_| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: "Database error".to_string(),
        }),
    ))?;

    let leaderboard = rows.into_iter().map(|row| {
        ResolutionLeaderboardEntry {
            id: row.id,
            username: row.username,
            avatar_url: row.avatar_url,
            total_resolutions: row.total_resolutions,
            verified_resolutions: row.verified_resolutions,
            total_resolution_score: row.total_resolution_score,
            average_resolution_score: row.average_resolution_score.map(|v| v.to_string()),
            average_time_to_resolve_hours: row.average_time_to_resolve_hours.map(|v| v.to_string()),
            sla_compliance_percentage: row.sla_compliance_percentage.map(|v| v.to_string()),
            average_quality_rating: row.average_quality_rating.map(|v| v.to_string()),
            current_resolution_streak: row.current_resolution_streak,
            rank: row.rank.map(|r| r as i64),
        }
    }).collect::<Vec<_>>();

    Ok(Json(leaderboard))
}

pub async fn get_team_leaderboard(
    State(app_state): State<AppState>,
    Query(params): Query<PaginationQuery>,
) -> Result<Json<Vec<TeamResolutionLeaderboardEntry>>, (StatusCode, Json<ErrorResponse>)> {
    let limit = params.limit.unwrap_or(10).min(100);
    let offset = (params.page.unwrap_or(1) - 1) * limit;

    let rows = sqlx::query!(
        r#"
        SELECT trl.id, trl.name, trl.total_resolutions, trl.verified_resolutions, trl.total_team_resolution_score,
               trl.average_resolution_score, trl.average_time_to_resolve_hours, trl.sla_compliance_percentage,
               trl.average_quality_rating, trl.active_contributors,
               ROW_NUMBER() OVER (ORDER BY trl.total_team_resolution_score DESC) as rank
        FROM team_resolution_leaderboard trl
        LIMIT $1 OFFSET $2
        "#,
        limit,
        offset
    )
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|_| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: "Database error".to_string(),
        }),
    ))?;

    let leaderboard = rows.into_iter().map(|row| {
        TeamResolutionLeaderboardEntry {
            id: row.id,
            name: row.name,
            total_resolutions: row.total_resolutions,
            verified_resolutions: row.verified_resolutions,
            total_team_resolution_score: row.total_team_resolution_score,
            average_resolution_score: row.average_resolution_score.map(|v| v.to_string()),
            average_time_to_resolve_hours: row.average_time_to_resolve_hours.map(|v| v.to_string()),
            sla_compliance_percentage: row.sla_compliance_percentage.map(|v| v.to_string()),
            average_quality_rating: row.average_quality_rating.map(|v| v.to_string()),
            active_contributors: row.active_contributors,
            rank: row.rank.map(|r| r as i64),
        }
    }).collect::<Vec<_>>();

    Ok(Json(leaderboard))
}

// Helper functions
fn calculate_resolution_score(time_hours: &f64, severity: &Option<String>) -> Option<i32> {
    let base_score = match severity {
        Some(s) if s.to_lowercase() == "critical" => 100,
        Some(s) if s.to_lowercase() == "high" => 80,
        Some(s) if s.to_lowercase() == "medium" => 60,
        Some(s) if s.to_lowercase() == "low" => 40,
        _ => 50,
    };

    // Bonus for fast resolution
    let time_bonus = if *time_hours < 24.0 { 20 } else if *time_hours < 72.0 { 10 } else { 0 };

    Some(base_score + time_bonus)
}

async fn update_user_resolution_stats(
    app_state: &AppState,
    user_id: Uuid,
    score: i32,
) -> Result<(), Box<dyn std::error::Error>> {
    sqlx::query(
        "INSERT INTO user_resolution_stats (user_id, total_resolutions, total_resolution_score)
         VALUES ($1, 1, $2)
         ON CONFLICT (user_id) DO UPDATE
         SET total_resolutions = user_resolution_stats.total_resolutions + 1,
             total_resolution_score = user_resolution_stats.total_resolution_score + $2"
    )
    .bind(user_id)
    .bind(score)
    .execute(&*app_state.pool)
    .await?;

    Ok(())
}
