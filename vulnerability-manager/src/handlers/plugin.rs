// src/handlers/plugin.rs - FIXED: Convertito a State
use axum::{
    extract::{Path, State}, // FIXED: State invece di Extension
    http::StatusCode,
    Json,
};
use sqlx::PgPool;
use std::sync::Arc;
use serde::Serialize;
use uuid::Uuid;

use crate::models::{PluginMetadata, PluginType, NewPlugin, UpdatePlugin};

#[derive(Debug, Serialize)]
pub struct ErrorResponse {
    pub error: String,
}

// LIST - Ottieni lista plugin - FIXED: State
pub async fn list_plugins(
    State(pool): State<Arc<PgPool>>, // FIXED: State invece di Extension
) -> Result<Json<Vec<PluginMetadata>>, (StatusCode, Json<ErrorResponse>)> {
    let plugins = sqlx::query_as!(
        PluginMetadata,
        r#"
        SELECT id, name, display_name, version, author, description,
               plugin_type as "plugin_type: PluginType", language, enabled, path, 
               config, created_at, updated_at
        FROM plugins
        ORDER BY display_name ASC
        "#
    )
    .fetch_all(&*pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore nel recupero dei plugin: {}", e),
        }),
    ))?;

    Ok(Json(plugins))
}

// GET - Ottieni singolo plugin - FIXED: State
pub async fn get_plugin(
    State(pool): State<Arc<PgPool>>, // FIXED: State invece di Extension
    Path(plugin_id): Path<Uuid>,
) -> Result<Json<PluginMetadata>, (StatusCode, Json<ErrorResponse>)> {
    let plugin = sqlx::query_as!(
        PluginMetadata,
        r#"
        SELECT id, name, display_name, version, author, description,
               plugin_type as "plugin_type: PluginType", language, enabled, path, 
               config, created_at, updated_at
        FROM plugins
        WHERE id = $1
        "#,
        plugin_id
    )
    .fetch_optional(&*pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore database: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Plugin non trovato".to_string(),
        }),
    ))?;

    Ok(Json(plugin))
}

// INSTALL - Installa nuovo plugin - FIXED: State
pub async fn install_plugin(
    State(pool): State<Arc<PgPool>>, // FIXED: State invece di Extension
    Json(new_plugin): Json<NewPlugin>,
) -> Result<Json<PluginMetadata>, (StatusCode, Json<ErrorResponse>)> {
    // Verifica che il file del plugin esista
    if !std::path::Path::new(&new_plugin.path).exists() {
        return Err((
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: format!("File plugin non trovato: {}", new_plugin.path),
            }),
        ));
    }

    let config = new_plugin.config.unwrap_or(serde_json::json!({}));
    
    let plugin = sqlx::query_as!(
        PluginMetadata,
        r#"
        INSERT INTO plugins (
            name, display_name, version, author, description,
            plugin_type, language, path, config, enabled
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
        RETURNING id, name, display_name, version, author, description,
                  plugin_type as "plugin_type: PluginType", language, enabled, path, 
                  config, created_at, updated_at
        "#,
        new_plugin.name,
        new_plugin.display_name,
        new_plugin.version,
        new_plugin.author,
        new_plugin.description,
        new_plugin.plugin_type as _,
        new_plugin.language,
        new_plugin.path,
        config,
        false // I plugin sono disabilitati di default
    )
    .fetch_one(&*pool)
    .await
    .map_err(|e| {
        let error_message = if e.to_string().contains("duplicate key") {
            "Plugin con questo nome già installato".to_string()
        } else {
            format!("Errore durante l'installazione: {}", e)
        };
        (
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse { error: error_message }),
        )
    })?;

    Ok(Json(plugin))
}

// UPDATE - Aggiorna plugin - FIXED: State
pub async fn update_plugin(
    State(pool): State<Arc<PgPool>>, // FIXED: State invece di Extension
    Path(plugin_id): Path<Uuid>,
    Json(update_data): Json<UpdatePlugin>,
) -> Result<Json<PluginMetadata>, (StatusCode, Json<ErrorResponse>)> {
    let plugin = sqlx::query_as!(
        PluginMetadata,
        r#"
        UPDATE plugins
        SET 
            display_name = COALESCE($2, display_name),
            version = COALESCE($3, version),
            description = COALESCE($4, description),
            enabled = COALESCE($5, enabled),
            config = COALESCE($6, config),
            updated_at = NOW()
        WHERE id = $1
        RETURNING id, name, display_name, version, author, description,
                  plugin_type as "plugin_type: PluginType", language, enabled, path, 
                  config, created_at, updated_at
        "#,
        plugin_id,
        update_data.display_name,
        update_data.version,
        update_data.description,
        update_data.enabled,
        update_data.config
    )
    .fetch_optional(&*pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore durante l'aggiornamento: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Plugin non trovato".to_string(),
        }),
    ))?;

    Ok(Json(plugin))
}

// UNINSTALL - Disinstalla plugin - FIXED: State
pub async fn uninstall_plugin(
    State(pool): State<Arc<PgPool>>, // FIXED: State invece di Extension
    Path(plugin_id): Path<Uuid>,
) -> Result<StatusCode, (StatusCode, Json<ErrorResponse>)> {
    // Prima verifica che il plugin non sia attivo
    let is_enabled: Option<bool> = sqlx::query_scalar!(
        "SELECT enabled FROM plugins WHERE id = $1",
        plugin_id
    )
    .fetch_optional(&*pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore database: {}", e),
        }),
    ))?;

    let is_enabled = match is_enabled {
        Some(enabled) => enabled,
        None => return Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Plugin non trovato".to_string(),
            }),
        )),
    };

    if is_enabled {
        return Err((
            StatusCode::CONFLICT,
            Json(ErrorResponse {
                error: "Impossibile disinstallare un plugin attivo. Disabilitalo prima.".to_string(),
            }),
        ));
    }

    let result = sqlx::query!(
        "DELETE FROM plugins WHERE id = $1",
        plugin_id
    )
    .execute(&*pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore durante la disinstallazione: {}", e),
        }),
    ))?;

    if result.rows_affected() == 0 {
        return Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Plugin non trovato".to_string(),
            }),
        ));
    }

    Ok(StatusCode::NO_CONTENT)
}

// Abilita/Disabilita plugin - FIXED: State
pub async fn toggle_plugin(
    State(pool): State<Arc<PgPool>>, // FIXED: State invece di Extension
    Path(plugin_id): Path<Uuid>,
) -> Result<Json<PluginMetadata>, (StatusCode, Json<ErrorResponse>)> {
    // Prima ottieni lo stato corrente
    let current_state: Option<bool> = sqlx::query_scalar!(
        "SELECT enabled FROM plugins WHERE id = $1",
        plugin_id
    )
    .fetch_optional(&*pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore database: {}", e),
        }),
    ))?;

    let current_state = current_state.ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Plugin non trovato".to_string(),
        }),
    ))?;

    // Inverti lo stato
    let plugin = sqlx::query_as!(
        PluginMetadata,
        r#"
        UPDATE plugins
        SET enabled = $2, updated_at = NOW()
        WHERE id = $1
        RETURNING id, name, display_name, version, author, description,
                  plugin_type as "plugin_type: PluginType", language, enabled, path, 
                  config, created_at, updated_at
        "#,
        plugin_id,
        !current_state
    )
    .fetch_one(&*pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore durante l'aggiornamento: {}", e),
        }),
    ))?;

    Ok(Json(plugin))
}

// Questo file è src/handlers/plugin.rs, non mod.rs
// Il contenuto mod.rs è separato