// src/handlers/plugin.rs - FIXED: Convertito a State
use axum::{
    extract::{Path, State, Multipart}, // FIXED: State invece di Extension
    http::StatusCode,
    Json,
};
use serde::{Serialize, Deserialize};
use uuid::Uuid;
use std::fs;
use std::path::PathBuf;

use crate::models::{PluginMetadata, PluginType, NewPlugin, UpdatePlugin};
use crate::state::AppState;

#[derive(Debug, Serialize)]
pub struct ErrorResponse {
    pub error: String,
}

// LIST - Ottieni lista plugin - FIXED: State
pub async fn list_plugins(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
) -> Result<Json<Vec<PluginMetadata>>, (StatusCode, Json<ErrorResponse>)> {
    let plugins = sqlx::query_as!(
        PluginMetadata,
        r#"
        SELECT id, name, display_name, version, author, description,
               plugin_type as "plugin_type: PluginType", language, enabled, path, 
               config, created_at, updated_at
        FROM plugins
        ORDER BY display_name ASC
        "#
    )
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore nel recupero dei plugin: {}", e),
        }),
    ))?;

    Ok(Json(plugins))
}

// GET - Ottieni singolo plugin - FIXED: State
pub async fn get_plugin(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    Path(plugin_id): Path<Uuid>,
) -> Result<Json<PluginMetadata>, (StatusCode, Json<ErrorResponse>)> {
    let plugin = sqlx::query_as!(
        PluginMetadata,
        r#"
        SELECT id, name, display_name, version, author, description,
               plugin_type as "plugin_type: PluginType", language, enabled, path, 
               config, created_at, updated_at
        FROM plugins
        WHERE id = $1
        "#,
        plugin_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore database: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Plugin non trovato".to_string(),
        }),
    ))?;

    Ok(Json(plugin))
}

// INSTALL - Installa nuovo plugin - FIXED: State
pub async fn install_plugin(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    Json(new_plugin): Json<NewPlugin>,
) -> Result<Json<PluginMetadata>, (StatusCode, Json<ErrorResponse>)> {
    // Verifica che il file del plugin esista
    if !std::path::Path::new(&new_plugin.path).exists() {
        return Err((
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: format!("File plugin non trovato: {}", new_plugin.path),
            }),
        ));
    }

    let config = new_plugin.config.unwrap_or(serde_json::json!({}));
    
    let plugin = sqlx::query_as!(
        PluginMetadata,
        r#"
        INSERT INTO plugins (
            name, display_name, version, author, description,
            plugin_type, language, path, config, enabled
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
        RETURNING id, name, display_name, version, author, description,
                  plugin_type as "plugin_type: PluginType", language, enabled, path, 
                  config, created_at, updated_at
        "#,
        new_plugin.name,
        new_plugin.display_name,
        new_plugin.version,
        new_plugin.author,
        new_plugin.description,
        new_plugin.plugin_type as _,
        new_plugin.language,
        new_plugin.path,
        config,
        false // I plugin sono disabilitati di default
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| {
        let error_message = if e.to_string().contains("duplicate key") {
            "Plugin con questo nome già installato".to_string()
        } else {
            format!("Errore durante l'installazione: {}", e)
        };
        (
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse { error: error_message }),
        )
    })?;

    Ok(Json(plugin))
}

// UPDATE - Aggiorna plugin - FIXED: State
pub async fn update_plugin(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    Path(plugin_id): Path<Uuid>,
    Json(update_data): Json<UpdatePlugin>,
) -> Result<Json<PluginMetadata>, (StatusCode, Json<ErrorResponse>)> {
    let plugin = sqlx::query_as!(
        PluginMetadata,
        r#"
        UPDATE plugins
        SET 
            display_name = COALESCE($2, display_name),
            version = COALESCE($3, version),
            description = COALESCE($4, description),
            enabled = COALESCE($5, enabled),
            config = COALESCE($6, config),
            updated_at = NOW()
        WHERE id = $1
        RETURNING id, name, display_name, version, author, description,
                  plugin_type as "plugin_type: PluginType", language, enabled, path, 
                  config, created_at, updated_at
        "#,
        plugin_id,
        update_data.display_name,
        update_data.version,
        update_data.description,
        update_data.enabled,
        update_data.config
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore durante l'aggiornamento: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Plugin non trovato".to_string(),
        }),
    ))?;

    Ok(Json(plugin))
}

// UNINSTALL - Disinstalla plugin - FIXED: State
pub async fn uninstall_plugin(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    Path(plugin_id): Path<Uuid>,
) -> Result<StatusCode, (StatusCode, Json<ErrorResponse>)> {
    // Prima verifica che il plugin non sia attivo
    let is_enabled: Option<bool> = sqlx::query_scalar!(
        "SELECT enabled FROM plugins WHERE id = $1",
        plugin_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore database: {}", e),
        }),
    ))?;

    let is_enabled = match is_enabled {
        Some(enabled) => enabled,
        None => return Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Plugin non trovato".to_string(),
            }),
        )),
    };

    if is_enabled {
        return Err((
            StatusCode::CONFLICT,
            Json(ErrorResponse {
                error: "Impossibile disinstallare un plugin attivo. Disabilitalo prima.".to_string(),
            }),
        ));
    }

    let result = sqlx::query!(
        "DELETE FROM plugins WHERE id = $1",
        plugin_id
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore durante la disinstallazione: {}", e),
        }),
    ))?;

    if result.rows_affected() == 0 {
        return Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Plugin non trovato".to_string(),
            }),
        ));
    }

    Ok(StatusCode::NO_CONTENT)
}

// Abilita/Disabilita plugin - FIXED: State
pub async fn toggle_plugin(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    Path(plugin_id): Path<Uuid>,
) -> Result<Json<PluginMetadata>, (StatusCode, Json<ErrorResponse>)> {
    // Prima ottieni lo stato corrente
    let current_state: Option<bool> = sqlx::query_scalar!(
        "SELECT enabled FROM plugins WHERE id = $1",
        plugin_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore database: {}", e),
        }),
    ))?;

    let current_state = current_state.ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Plugin non trovato".to_string(),
        }),
    ))?;

    // Inverti lo stato
    let plugin = sqlx::query_as!(
        PluginMetadata,
        r#"
        UPDATE plugins
        SET enabled = $2, updated_at = NOW()
        WHERE id = $1
        RETURNING id, name, display_name, version, author, description,
                  plugin_type as "plugin_type: PluginType", language, enabled, path, 
                  config, created_at, updated_at
        "#,
        plugin_id,
        !current_state
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore durante l'aggiornamento: {}", e),
        }),
    ))?;

    Ok(Json(plugin))
}

// Execute plugin action
#[derive(Debug, Deserialize)]
pub struct ExecutePluginRequest {
    pub action: String,
    pub data: serde_json::Value,
}

pub async fn execute_plugin(
    State(app_state): State<AppState>,
    Path(plugin_id): Path<Uuid>,
    Json(request): Json<ExecutePluginRequest>,
) -> Result<Json<serde_json::Value>, (StatusCode, Json<ErrorResponse>)> {
    // Verify plugin exists and is enabled
    let plugin = sqlx::query_as!(
        PluginMetadata,
        r#"
        SELECT id, name, display_name, version, author, description,
               plugin_type as "plugin_type: PluginType", language, enabled, path,
               config, created_at, updated_at
        FROM plugins
        WHERE id = $1
        "#,
        plugin_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Plugin not found".to_string(),
        }),
    ))?;

    if !plugin.enabled {
        return Err((
            StatusCode::FORBIDDEN,
            Json(ErrorResponse {
                error: "Plugin is disabled".to_string(),
            }),
        ));
    }

    // Verify plugin file exists
    if !PathBuf::from(&plugin.path).exists() {
        return Err((
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Plugin file not found: {}", plugin.path),
            }),
        ));
    }

    // TODO: Implement actual plugin execution based on language
    // For now, just return a mock response
    tracing::info!(
        "Executing action '{}' on plugin {} ({})",
        request.action,
        plugin.display_name,
        plugin.language
    );

    Ok(Json(serde_json::json!({
        "success": true,
        "plugin": plugin.display_name,
        "action": request.action,
        "message": format!("Action '{}' executed successfully", request.action),
        "result": {
            "status": "completed",
            "data": request.data
        }
    })))
}

// Upload plugin file
pub async fn upload_plugin(
    State(app_state): State<AppState>,
    mut multipart: Multipart,
) -> Result<Json<PluginMetadata>, (StatusCode, Json<ErrorResponse>)> {
    while let Some(field) = multipart.next_field().await.map_err(|e| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: format!("Failed to read multipart data: {}", e),
        }),
    ))? {
        if field.name() == Some("plugin") {
            let filename = field.file_name()
                .ok_or_else(|| (
                    StatusCode::BAD_REQUEST,
                    Json(ErrorResponse {
                        error: "Missing filename".to_string(),
                    }),
                ))?
                .to_string();

            let data = field.bytes().await.map_err(|e| (
                StatusCode::BAD_REQUEST,
                Json(ErrorResponse {
                    error: format!("Failed to read file data: {}", e),
                }),
            ))?;

            // Validate file size (10MB limit for plugins)
            if data.len() > 10 * 1024 * 1024 {
                return Err((
                    StatusCode::BAD_REQUEST,
                    Json(ErrorResponse {
                        error: "Plugin file too large (max 10MB)".to_string(),
                    }),
                ));
            }

            // Validate file extension
            let path = PathBuf::from(&filename);
            let extension = path
                .extension()
                .and_then(|e| e.to_str())
                .ok_or_else(|| (
                    StatusCode::BAD_REQUEST,
                    Json(ErrorResponse {
                        error: "Invalid file extension".to_string(),
                    }),
                ))?;

            // Supported plugin languages/extensions
            let language = match extension {
                "py" => "python",
                "js" => "javascript",
                "sh" => "bash",
                "rb" => "ruby",
                "pl" => "perl",
                _ => {
                    return Err((
                        StatusCode::BAD_REQUEST,
                        Json(ErrorResponse {
                            error: format!("Unsupported plugin format: .{}", extension),
                        }),
                    ));
                }
            };

            // Create plugins directory if it doesn't exist
            let plugins_dir = "plugins";
            fs::create_dir_all(plugins_dir).map_err(|e| (
                StatusCode::INTERNAL_SERVER_ERROR,
                Json(ErrorResponse {
                    error: format!("Failed to create plugins directory: {}", e),
                }),
            ))?;

            // Generate unique filename
            let unique_filename = format!("{}-{}", Uuid::new_v4(), filename);
            let file_path = format!("{}/{}", plugins_dir, unique_filename);

            // Save plugin file to disk
            fs::write(&file_path, &data).map_err(|e| (
                StatusCode::INTERNAL_SERVER_ERROR,
                Json(ErrorResponse {
                    error: format!("Failed to save plugin file: {}", e),
                }),
            ))?;

            // Try to extract metadata from file
            // For now, use filename as display name
            let plugin_name = PathBuf::from(&filename)
                .file_stem()
                .and_then(|s| s.to_str())
                .unwrap_or("unknown")
                .to_string();

            // Register plugin in database
            let plugin = sqlx::query_as!(
                PluginMetadata,
                r#"
                INSERT INTO plugins (
                    name, display_name, version, author, description,
                    plugin_type, language, path, config, enabled
                )
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
                RETURNING id, name, display_name, version, author, description,
                          plugin_type as "plugin_type: PluginType", language, enabled, path,
                          config, created_at, updated_at
                "#,
                plugin_name,
                plugin_name,
                "1.0.0",
                "Unknown",
                Some(format!("Uploaded plugin: {}", filename)),
                PluginType::Other as _,
                language,
                file_path,
                serde_json::json!({}),
                false // Disabled by default
            )
            .fetch_one(&*app_state.pool)
            .await
            .map_err(|e| {
                // Delete uploaded file if database insert fails
                let _ = fs::remove_file(&file_path);

                let error_message = if e.to_string().contains("duplicate key") {
                    "Plugin with this name already exists".to_string()
                } else {
                    format!("Failed to register plugin: {}", e)
                };
                (
                    StatusCode::BAD_REQUEST,
                    Json(ErrorResponse { error: error_message }),
                )
            })?;

            tracing::info!("Plugin uploaded successfully: {} ({})", plugin.display_name, file_path);

            return Ok(Json(plugin));
        }
    }

    Err((
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: "No plugin file found in request".to_string(),
        }),
    ))
}

// Scan plugin directory and register any new plugins
pub async fn scan_plugins(
    State(app_state): State<AppState>,
) -> Result<Json<Vec<PluginMetadata>>, (StatusCode, Json<ErrorResponse>)> {
    let plugins_dir = "plugins";

    // Create directory if it doesn't exist
    if !PathBuf::from(plugins_dir).exists() {
        fs::create_dir_all(plugins_dir).map_err(|e| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Failed to create plugins directory: {}", e),
            }),
        ))?;
    }

    // Read all files in plugins directory
    let entries = fs::read_dir(plugins_dir).map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to read plugins directory: {}", e),
        }),
    ))?;

    let mut discovered_plugins = Vec::new();

    for entry in entries {
        let entry = entry.map_err(|e| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Failed to read directory entry: {}", e),
            }),
        ))?;

        let path = entry.path();
        if !path.is_file() {
            continue;
        }

        let filename = path.file_name()
            .and_then(|n| n.to_str())
            .unwrap_or("")
            .to_string();

        let extension = path.extension()
            .and_then(|e| e.to_str())
            .unwrap_or("");

        let language = match extension {
            "py" => "python",
            "js" => "javascript",
            "sh" => "bash",
            "rb" => "ruby",
            "pl" => "perl",
            _ => continue, // Skip unsupported files
        };

        let plugin_name = path.file_stem()
            .and_then(|s| s.to_str())
            .unwrap_or("unknown")
            .to_string();

        let file_path = path.to_string_lossy().to_string();

        // Check if plugin already exists in database
        let exists = sqlx::query_scalar!(
            "SELECT EXISTS(SELECT 1 FROM plugins WHERE path = $1)",
            file_path
        )
        .fetch_one(&*app_state.pool)
        .await
        .map_err(|e| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Database error: {}", e),
            }),
        ))?
        .unwrap_or(false);

        if !exists {
            // Register new plugin
            let plugin = sqlx::query_as!(
                PluginMetadata,
                r#"
                INSERT INTO plugins (
                    name, display_name, version, author, description,
                    plugin_type, language, path, config, enabled
                )
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
                RETURNING id, name, display_name, version, author, description,
                          plugin_type as "plugin_type: PluginType", language, enabled, path,
                          config, created_at, updated_at
                "#,
                plugin_name.clone(),
                plugin_name.clone(),
                "1.0.0",
                "Unknown",
                Some(format!("Discovered plugin: {}", filename)),
                PluginType::Other as _,
                language,
                file_path,
                serde_json::json!({}),
                false
            )
            .fetch_one(&*app_state.pool)
            .await
            .ok();

            if let Some(p) = plugin {
                discovered_plugins.push(p);
            }
        }
    }

    tracing::info!("Discovered {} new plugins", discovered_plugins.len());

    Ok(Json(discovered_plugins))
}

// Questo file è src/handlers/plugin.rs, non mod.rs
// Il contenuto mod.rs è separato