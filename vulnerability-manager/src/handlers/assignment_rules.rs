// src/handlers/assignment_rules.rs
// Assignment rules CRUD and evaluation engine

use axum::{
    extract::{Path, State},
    http::StatusCode,
    Json,
};
use uuid::Uuid;
use chrono::Utc;
use serde_json::json;

use crate::auth::Claims;
use crate::state::AppState;
use crate::models::assignment_rules::*;

/// Create assignment rule
pub async fn create_assignment_rule(
    State(app_state): State<AppState>,
    Claims { sub, .. }: Claims,
    Json(payload): Json<CreateAssignmentRuleRequest>,
) -> Result<Json<AssignmentRuleResponse>, (StatusCode, Json<serde_json::Value>)> {
    let user_id = Uuid::parse_str(&sub).unwrap_or(Uuid::nil());
    let pool = &*app_state.pool;

    let priority = payload.priority.unwrap_or(100);
    let skills = payload.required_skills.unwrap_or_default();
    let strategy = payload.load_balancing_strategy.unwrap_or_else(|| "round_robin".to_string());

    let rule_id = Uuid::new_v4();

    sqlx::query(
        r#"
        INSERT INTO assignment_rules 
        (id, name, description, priority, conditions, team_id, team_member_role, 
         require_skill_match, required_skills, load_balancing_strategy, created_by)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
        "#
    )
    .bind(rule_id)
    .bind(&payload.name)
    .bind(&payload.description)
    .bind(priority)
    .bind(&payload.conditions)
    .bind(payload.team_id)
    .bind(&payload.team_member_role)
    .bind(payload.require_skill_match.unwrap_or(false))
    .bind(&skills)
    .bind(&strategy)
    .bind(user_id)
    .execute(pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(json!({"error": format!("Database error: {}", e)}))
    ))?;

    // Fetch team name if team_id is set
    let team_name = if let Some(team_id) = payload.team_id {
        sqlx::query_scalar::<_, String>("SELECT name FROM teams WHERE id = $1")
            .bind(team_id)
            .fetch_optional(pool)
            .await
            .ok()
            .flatten()
    } else {
        None
    };

    Ok(Json(AssignmentRuleResponse {
        id: rule_id,
        name: payload.name,
        description: payload.description,
        priority,
        is_enabled: true,
        conditions: payload.conditions,
        team_id: payload.team_id,
        team_name,
        team_member_role: payload.team_member_role,
        required_skills: skills,
        load_balancing_strategy: strategy,
        created_by: user_id,
        created_at: Utc::now(),
        updated_at: Utc::now(),
    }))
}

/// List assignment rules
pub async fn list_assignment_rules(
    State(app_state): State<AppState>,
    _claims: Claims,
) -> Result<Json<Vec<AssignmentRuleResponse>>, (StatusCode, Json<serde_json::Value>)> {
    let pool = &*app_state.pool;

    let rules: Vec<(
        Uuid, String, Option<String>, i32, bool, serde_json::Value,
        Option<Uuid>, Option<String>, Option<bool>, Vec<String>,
        String, Uuid, chrono::DateTime<Utc>, chrono::DateTime<Utc>,
        Option<String>
    )> = sqlx::query_as(
        r#"
        SELECT 
            ar.id, ar.name, ar.description, ar.priority, ar.is_enabled, ar.conditions,
            ar.team_id, ar.team_member_role, ar.require_skill_match, ar.required_skills,
            ar.load_balancing_strategy, ar.created_by, ar.created_at, ar.updated_at,
            t.name as team_name
        FROM assignment_rules ar
        LEFT JOIN teams t ON ar.team_id = t.id
        WHERE ar.is_enabled = true
        ORDER BY ar.priority DESC, ar.created_at DESC
        "#
    )
    .fetch_all(pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(json!({"error": format!("Database error: {}", e)}))
    ))?;

    let responses = rules.into_iter().map(|(id, name, description, priority, is_enabled, conditions, team_id, team_member_role, _require_skill_match, required_skills, load_balancing_strategy, created_by, created_at, updated_at, team_name)| {
        AssignmentRuleResponse {
            id,
            name,
            description,
            priority,
            is_enabled,
            conditions,
            team_id,
            team_name,
            team_member_role,
            required_skills,
            load_balancing_strategy,
            created_by,
            created_at,
            updated_at,
        }
    }).collect();

    Ok(Json(responses))
}

/// Get assignment rule by ID
pub async fn get_assignment_rule(
    State(app_state): State<AppState>,
    Path(rule_id): Path<Uuid>,
    _claims: Claims,
) -> Result<Json<AssignmentRuleResponse>, (StatusCode, Json<serde_json::Value>)> {
    let pool = &*app_state.pool;

    let (id, name, description, priority, is_enabled, conditions, team_id, team_member_role, _require_skill_match, required_skills, load_balancing_strategy, created_by, created_at, updated_at, team_name)
    : (Uuid, String, Option<String>, i32, bool, serde_json::Value, Option<Uuid>, Option<String>, Option<bool>, Vec<String>, String, Uuid, chrono::DateTime<Utc>, chrono::DateTime<Utc>, Option<String>)
    = sqlx::query_as(
        r#"
        SELECT 
            ar.id, ar.name, ar.description, ar.priority, ar.is_enabled, ar.conditions,
            ar.team_id, ar.team_member_role, ar.require_skill_match, ar.required_skills,
            ar.load_balancing_strategy, ar.created_by, ar.created_at, ar.updated_at,
            t.name as team_name
        FROM assignment_rules ar
        LEFT JOIN teams t ON ar.team_id = t.id
        WHERE ar.id = $1
        "#
    )
    .bind(rule_id)
    .fetch_one(pool)
    .await
    .map_err(|_| (
        StatusCode::NOT_FOUND,
        Json(json!({"error": "Assignment rule not found"}))
    ))?;

    Ok(Json(AssignmentRuleResponse {
        id,
        name,
        description,
        priority,
        is_enabled,
        conditions,
        team_id,
        team_name,
        team_member_role,
        required_skills,
        load_balancing_strategy,
        created_by,
        created_at,
        updated_at,
    }))
}

/// Update assignment rule
pub async fn update_assignment_rule(
    State(app_state): State<AppState>,
    Path(rule_id): Path<Uuid>,
    _claims: Claims,
    Json(payload): Json<UpdateAssignmentRuleRequest>,
) -> Result<Json<AssignmentRuleResponse>, (StatusCode, Json<serde_json::Value>)> {
    let pool = &*app_state.pool;

    sqlx::query(
        r#"
        UPDATE assignment_rules 
        SET name = COALESCE($2, name),
            description = COALESCE($3, description),
            priority = COALESCE($4, priority),
            conditions = COALESCE($5, conditions),
            team_id = COALESCE($6, team_id),
            team_member_role = COALESCE($7, team_member_role),
            require_skill_match = COALESCE($8, require_skill_match),
            required_skills = COALESCE($9, required_skills),
            load_balancing_strategy = COALESCE($10, load_balancing_strategy),
            is_enabled = COALESCE($11, is_enabled),
            updated_at = NOW()
        WHERE id = $1
        "#
    )
    .bind(rule_id)
    .bind(payload.name)
    .bind(payload.description)
    .bind(payload.priority)
    .bind(payload.conditions)
    .bind(payload.team_id)
    .bind(payload.team_member_role)
    .bind(payload.require_skill_match)
    .bind(payload.required_skills.as_ref())
    .bind(payload.load_balancing_strategy)
    .bind(payload.is_enabled)
    .execute(pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(json!({"error": format!("Database error: {}", e)}))
    ))?;

    // Fetch and return updated rule
    get_assignment_rule(State(app_state), Path(rule_id), crate::auth::Claims {
        sub: Uuid::nil().to_string(),
        role: "user".to_string(),
        exp: 0,
        iat: 0,
        jti: None,
    }).await
}

/// Delete assignment rule
pub async fn delete_assignment_rule(
    State(app_state): State<AppState>,
    Path(rule_id): Path<Uuid>,
    _claims: Claims,
) -> Result<StatusCode, (StatusCode, Json<serde_json::Value>)> {
    let pool = &*app_state.pool;

    sqlx::query("DELETE FROM assignment_rules WHERE id = $1")
        .bind(rule_id)
        .execute(pool)
        .await
        .map_err(|e| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(json!({"error": format!("Database error: {}", e)}))
        ))?;

    Ok(StatusCode::NO_CONTENT)
}

/// Test assignment rule evaluation
pub async fn test_assignment_rule(
    State(app_state): State<AppState>,
    _claims: Claims,
    Json(payload): Json<TestAssignmentRuleRequest>,
) -> Result<Json<TestAssignmentRuleResponse>, (StatusCode, Json<serde_json::Value>)> {
    let pool = &*app_state.pool;

    // Get rule
    let (rule_name, conditions): (String, serde_json::Value) = sqlx::query_as(
        "SELECT name, conditions FROM assignment_rules WHERE id = $1"
    )
    .bind(payload.rule_id)
    .fetch_one(pool)
    .await
    .map_err(|_| (
        StatusCode::NOT_FOUND,
        Json(json!({"error": "Rule not found"}))
    ))?;

    // Get vulnerability
    let (severity, cve_id, asset_id): (String, Option<String>, Option<Uuid>) = sqlx::query_as(
        "SELECT severity, cve_id, asset_id FROM vulnerabilities WHERE id = $1"
    )
    .bind(payload.vulnerability_id)
    .fetch_one(pool)
    .await
    .map_err(|_| (
        StatusCode::NOT_FOUND,
        Json(json!({"error": "Vulnerability not found"}))
    ))?;

    // Evaluate conditions
    let matches = evaluate_rule(&conditions, &severity, cve_id.as_deref(), asset_id, pool).await
        .unwrap_or(false);

    let (team_name, team_role) = if matches {
        let (tn, tr): (Option<String>, Option<String>) = sqlx::query_as(
            "SELECT t.name, ar.team_member_role FROM assignment_rules ar LEFT JOIN teams t ON ar.team_id = t.id WHERE ar.id = $1"
        )
        .bind(payload.rule_id)
        .fetch_optional(pool)
        .await
        .ok()
        .flatten()
        .unzip();
        (tn, tr)
    } else {
        (None, None)
    };

    Ok(Json(TestAssignmentRuleResponse {
        matches,
        rule_name,
        would_assign_to_team: team_name,
        would_assign_to_role: team_role,
        reasoning: if matches {
            "Rule conditions matched".to_string()
        } else {
            "Rule conditions did not match".to_string()
        },
    }))
}

/// Evaluate rule conditions against vulnerability
async fn evaluate_rule(
    conditions: &serde_json::Value,
    severity: &str,
    cve_id: Option<&str>,
    asset_id: Option<Uuid>,
    pool: &sqlx::PgPool,
) -> Result<bool, String> {
    if let Some(vuln_obj) = conditions.get("vulnerability") {
        if let Some(sev) = vuln_obj.get("severity").and_then(|v| v.as_str()) {
            if sev != severity {
                return Ok(false);
            }
        }
    }

    if let Some(asset_obj) = conditions.get("asset") {
        if let Some(tags) = asset_obj.get("tags").and_then(|v| v.as_array()) {
            if let Some(asset_uuid) = asset_id {
                let asset_tags: Vec<String> = sqlx::query_scalar(
                    "SELECT UNNEST(tags) FROM assets WHERE id = $1"
                )
                .bind(asset_uuid)
                .fetch_all(pool)
                .await
                .unwrap_or_default();

                let has_match = tags.iter().any(|tag| {
                    tag.as_str().map_or(false, |t| asset_tags.contains(&t.to_string()))
                });

                if !has_match {
                    return Ok(false);
                }
            }
        }
    }

    Ok(true)
}
