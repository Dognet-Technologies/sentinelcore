// src/handlers/risk_scoring.rs
// Risk scoring and SLA management handlers

use axum::{
    extract::{Path, Query, State},
    http::StatusCode,
    Json,
};
use serde::{Deserialize, Serialize};
use uuid::Uuid;
use chrono::{DateTime, Utc};

use crate::auth::Claims;
use crate::state::AppState;
use crate::scoring::{
    RiskCalculator, RiskScore, RiskTier,
    BusinessImpact, AssetCriticality,
    AssetExposure, ExposureLevel,
    ExploitAvailability, ExploitStatus,
};

#[derive(Debug, Serialize)]
pub struct RiskScoreResponse {
    pub vulnerability_id: Uuid,
    pub risk_score: RiskScore,
    pub calculated_at: DateTime<Utc>,
}

#[derive(Debug, Serialize)]
pub struct SLABreach {
    pub vulnerability_id: Option<Uuid>,
    pub title: Option<String>,
    pub risk_tier: Option<String>,
    pub sla_deadline: Option<DateTime<Utc>>,
    pub days_overdue: Option<i32>,
}

#[derive(Debug, Serialize)]
pub struct SLABreachesResponse {
    pub breaches: Vec<SLABreach>,
    pub total: i64,
}

#[derive(Debug, Deserialize)]
pub struct CalculateRiskRequest {
    pub cvss_score: f32,
    pub epss_score: f32,
    pub asset_criticality: String,
    pub has_sensitive_data: bool,
    pub revenue_impact_per_hour: f32,
    pub network_zone: String,
    pub exploit_status: String,
    pub is_zero_day: Option<bool>,
    pub is_ransomware_targeted: Option<bool>,
    pub in_active_campaigns: Option<bool>,
}

#[derive(Debug, Serialize)]
pub struct RiskTierStats {
    pub tier: String,
    pub count: i64,
    pub percentage: f32,
}

#[derive(Debug, Serialize)]
pub struct RiskStatsResponse {
    pub total_vulnerabilities: i64,
    pub by_tier: Vec<RiskTierStats>,
    pub avg_risk_score: f32,
    pub critical_count: i64,
    pub sla_breached_count: i64,
}

#[derive(Debug, Deserialize)]
pub struct RiskStatsQuery {
    pub team_id: Option<Uuid>,
}

// Calculate risk score for vulnerability
pub async fn calculate_risk_score(
    State(app_state): State<AppState>,
    Path(vulnerability_id): Path<Uuid>,
    _claims: Claims,
) -> Result<Json<RiskScoreResponse>, StatusCode> {
    // Fetch vulnerability data
    let vuln = sqlx::query!(
        r#"
        SELECT
            v.cvss_score,
            v.epss_score,
            v.exploit_status,
            v.is_zero_day,
            v.is_ransomware_targeted,
            v.in_active_campaigns,
            v.ip_address,
            a.criticality,
            a.has_sensitive_data,
            a.revenue_impact_per_hour,
            a.network_zone
        FROM vulnerabilities v
        LEFT JOIN assets a ON a.ip_address = v.ip_address
        WHERE v.id = $1
        "#,
        vulnerability_id
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|_| StatusCode::NOT_FOUND)?;

    // Parse asset criticality
    let criticality = match vuln.criticality.as_deref() {
        Some("Critical") => AssetCriticality::Critical,
        Some("High") => AssetCriticality::High,
        Some("Medium") => AssetCriticality::Medium,
        Some("Low") => AssetCriticality::Low,
        _ => AssetCriticality::Medium,
    };

    let business_impact = BusinessImpact::new(
        criticality,
        vuln.has_sensitive_data.unwrap_or(false),
        vuln.revenue_impact_per_hour.unwrap_or(0.0),
    );

    // Parse exposure level
    let exposure_level = match vuln.network_zone.as_deref() {
        Some("Internet-Facing") => ExposureLevel::InternetFacing,
        Some("DMZ") => ExposureLevel::DMZ,
        Some("Isolated") => ExposureLevel::Isolated,
        _ => ExposureLevel::Internal,
    };

    let asset_exposure = AssetExposure::new(exposure_level, vec![]);

    // Parse exploit status
    let exploit_status = match vuln.exploit_status.as_deref() {
        Some("PublicExploitActiveCampaigns") => ExploitStatus::PublicExploitActiveCampaigns,
        Some("PublicExploit") => ExploitStatus::PublicExploit,
        Some("PoCAvailable") => ExploitStatus::PoCAvailable,
        Some("TheoreticalExploit") => ExploitStatus::TheoreticalExploit,
        _ => ExploitStatus::NoExploit,
    };

    let exploit_availability = ExploitAvailability::new(exploit_status);

    // Calculate risk score
    let mut risk_score = RiskCalculator::calculate(
        vuln.cvss_score,
        vuln.epss_score.unwrap_or(0.0),
        business_impact,
        asset_exposure,
        exploit_availability,
    );

    // Apply overrides
    RiskCalculator::apply_overrides(
        &mut risk_score,
        vuln.is_zero_day.unwrap_or(false),
        vuln.is_ransomware_targeted.unwrap_or(false),
        false, // compliance_critical - would come from separate table
        vuln.in_active_campaigns.unwrap_or(false),
    );

    // Update vulnerability in database
    sqlx::query!(
        r#"
        UPDATE vulnerabilities
        SET
            risk_score = $1,
            risk_tier = $2,
            sla_days = $3,
            cvss_component = $4,
            epss_component = $5,
            business_component = $6,
            exposure_component = $7,
            exploit_component = $8,
            sla_deadline = first_detected + ($3 || ' days')::INTERVAL
        WHERE id = $9
        "#,
        risk_score.total as i32,
        format!("{:?}", risk_score.tier),
        risk_score.sla_days as i32,
        risk_score.cvss_component,
        risk_score.epss_component,
        risk_score.business_component,
        risk_score.exposure_component,
        risk_score.exploit_component,
        vulnerability_id
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to update risk score: {}", e);
        StatusCode::INTERNAL_SERVER_ERROR
    })?;

    Ok(Json(RiskScoreResponse {
        vulnerability_id,
        risk_score,
        calculated_at: Utc::now(),
    }))
}

// Get SLA breaches
pub async fn get_sla_breaches(
    State(app_state): State<AppState>,
    _claims: Claims,
) -> Result<Json<SLABreachesResponse>, StatusCode> {
    let breaches = sqlx::query_as!(
        SLABreach,
        r#"
        SELECT * FROM check_sla_breaches()
        "#
    )
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch SLA breaches: {}", e);
        StatusCode::INTERNAL_SERVER_ERROR
    })?;

    let total = breaches.len() as i64;

    Ok(Json(SLABreachesResponse { breaches, total }))
}

// Mark SLA breaches (manual trigger)
pub async fn mark_sla_breaches(
    State(app_state): State<AppState>,
    claims: Claims,
) -> Result<Json<serde_json::Value>, StatusCode> {
    // Only admins can manually mark breaches
    if claims.role != "admin" {
        return Err(StatusCode::FORBIDDEN);
    }

    let count = sqlx::query_scalar::<_, i32>("SELECT mark_sla_breaches()")
        .fetch_one(&*app_state.pool)
        .await
        .map_err(|e| {
            tracing::error!("Failed to mark SLA breaches: {}", e);
            StatusCode::INTERNAL_SERVER_ERROR
        })?;

    Ok(Json(serde_json::json!({
        "breaches_marked": count,
        "marked_at": Utc::now()
    })))
}

// Get risk statistics
pub async fn get_risk_statistics(
    State(app_state): State<AppState>,
    Query(query): Query<RiskStatsQuery>,
    _claims: Claims,
) -> Result<Json<RiskStatsResponse>, StatusCode> {
    // Fetch stats based on whether team_id is provided
    let (total, avg_score, critical_count, breached_count, tier_critical, tier_high, tier_medium, tier_low, tier_info) =
        if let Some(team_id) = query.team_id {
            // Team-specific stats
            let stats = sqlx::query!(
                r#"
                SELECT
                    COUNT(*) as total,
                    ROUND(AVG(risk_score)::numeric, 2) as avg_score,
                    COUNT(*) FILTER (WHERE risk_tier = 'Critical') as critical_count,
                    COUNT(*) FILTER (WHERE sla_breached = TRUE) as breached_count,
                    COUNT(*) FILTER (WHERE risk_tier = 'Critical') as tier_critical,
                    COUNT(*) FILTER (WHERE risk_tier = 'High') as tier_high,
                    COUNT(*) FILTER (WHERE risk_tier = 'Medium') as tier_medium,
                    COUNT(*) FILTER (WHERE risk_tier = 'Low') as tier_low,
                    COUNT(*) FILTER (WHERE risk_tier = 'Info') as tier_info
                FROM vulnerabilities v
                WHERE v.assigned_to_team_id = $1
                    AND v.status NOT IN ('resolved', 'closed')
                "#,
                team_id
            )
            .fetch_one(&*app_state.pool)
            .await
            .map_err(|e| {
                tracing::error!("Failed to fetch risk statistics: {}", e);
                StatusCode::INTERNAL_SERVER_ERROR
            })?;

            (
                stats.total.unwrap_or(0),
                stats.avg_score,
                stats.critical_count.unwrap_or(0),
                stats.breached_count.unwrap_or(0),
                stats.tier_critical.unwrap_or(0),
                stats.tier_high.unwrap_or(0),
                stats.tier_medium.unwrap_or(0),
                stats.tier_low.unwrap_or(0),
                stats.tier_info.unwrap_or(0),
            )
        } else {
            // Global stats
            let stats = sqlx::query!(
                r#"
                SELECT
                    COUNT(*) as total,
                    ROUND(AVG(risk_score)::numeric, 2) as avg_score,
                    COUNT(*) FILTER (WHERE risk_tier = 'Critical') as critical_count,
                    COUNT(*) FILTER (WHERE sla_breached = TRUE) as breached_count,
                    COUNT(*) FILTER (WHERE risk_tier = 'Critical') as tier_critical,
                    COUNT(*) FILTER (WHERE risk_tier = 'High') as tier_high,
                    COUNT(*) FILTER (WHERE risk_tier = 'Medium') as tier_medium,
                    COUNT(*) FILTER (WHERE risk_tier = 'Low') as tier_low,
                    COUNT(*) FILTER (WHERE risk_tier = 'Info') as tier_info
                FROM vulnerabilities v
                WHERE v.status NOT IN ('resolved', 'closed')
                "#
            )
            .fetch_one(&*app_state.pool)
            .await
            .map_err(|e| {
                tracing::error!("Failed to fetch risk statistics: {}", e);
                StatusCode::INTERNAL_SERVER_ERROR
            })?;

            (
                stats.total.unwrap_or(0),
                stats.avg_score,
                stats.critical_count.unwrap_or(0),
                stats.breached_count.unwrap_or(0),
                stats.tier_critical.unwrap_or(0),
                stats.tier_high.unwrap_or(0),
                stats.tier_medium.unwrap_or(0),
                stats.tier_low.unwrap_or(0),
                stats.tier_info.unwrap_or(0),
            )
        };

    let total_f = total as f32;

    let by_tier = vec![
        RiskTierStats {
            tier: "Critical".to_string(),
            count: tier_critical,
            percentage: if total > 0 {
                (tier_critical as f32 / total_f) * 100.0
            } else {
                0.0
            },
        },
        RiskTierStats {
            tier: "High".to_string(),
            count: tier_high,
            percentage: if total > 0 {
                (tier_high as f32 / total_f) * 100.0
            } else {
                0.0
            },
        },
        RiskTierStats {
            tier: "Medium".to_string(),
            count: tier_medium,
            percentage: if total > 0 {
                (tier_medium as f32 / total_f) * 100.0
            } else {
                0.0
            },
        },
        RiskTierStats {
            tier: "Low".to_string(),
            count: tier_low,
            percentage: if total > 0 {
                (tier_low as f32 / total_f) * 100.0
            } else {
                0.0
            },
        },
        RiskTierStats {
            tier: "Info".to_string(),
            count: tier_info,
            percentage: if total > 0 {
                (tier_info as f32 / total_f) * 100.0
            } else {
                0.0
            },
        },
    ];

    Ok(Json(RiskStatsResponse {
        total_vulnerabilities: total,
        by_tier,
        avg_risk_score: avg_score.unwrap_or(serde_json::Number::from(0)).as_f64().unwrap_or(0.0) as f32,
        critical_count,
        sla_breached_count: breached_count,
    }))
}
