// src/handlers/vulnerability.rs
// FIXED: Convertito da Extension a State per Axum 0.6

use axum::{
    extract::{Path, Query, State}, // FIXED: State invece di Extension
    http::StatusCode,
    Json,
};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use crate::auth::Claims;
use crate::models::vulnerability::{
    Vulnerability, VulnerabilityStatus, VulnerabilitySeverity, 
    NewVulnerability, UpdateVulnerability, VulnerabilityFilter
};
use crate::state::AppState;

#[derive(Serialize)]
pub struct ErrorResponse {
    error: String,
}

#[derive(Deserialize)]
pub struct AssignToTeamRequest {
    team_id: Uuid,
}

#[derive(Deserialize)]
pub struct AssignToUserRequest {
    user_id: Uuid,
}

// List vulnerabilities with filtering - FIXED: State and simplified query
pub async fn list_vulnerabilities(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    _claims: Claims,
    filter: Option<Query<VulnerabilityFilter>>,
) -> Result<Json<Vec<Vulnerability>>, (StatusCode, Json<ErrorResponse>)> {
    let filter = filter.map(|Query(f)| f).unwrap_or_default();

    // Dynamic query builder with JOIN for user/team names
    use sqlx::QueryBuilder;

    let mut query = QueryBuilder::new(
        r#"SELECT v.id, v.title, v.description, v.cvss_score, v.epss_score, v.ip_address,
               v.hostname, v.port, v.protocol, v.status, v.severity,
               v.cve_id, v.cwe_id, v.remediation, v.source, v.discovered_at,
               v.created_at, v.updated_at, v.asset_id, v.assigned_team_id, v.assigned_user_id,
               u.username as assigned_user_name,
               t.name as assigned_team_name,
               v.deleted_at
        FROM vulnerabilities v
        LEFT JOIN users u ON v.assigned_user_id = u.id AND u.deleted_at IS NULL
        LEFT JOIN teams t ON v.assigned_team_id = t.id AND t.deleted_at IS NULL
        WHERE v.deleted_at IS NULL"#
    );

    let mut has_where = true;

    // Build WHERE clause dynamically based on provided filters
    // Support multiple filters with AND conditions
    if let Some(status) = &filter.status {
        query.push(if has_where { " AND " } else { " WHERE " });
        query.push("v.status = ");
        query.push_bind(status.as_str());
        has_where = true;
    }

    if let Some(severity) = &filter.severity {
        query.push(if has_where { " AND " } else { " WHERE " });
        query.push("v.severity = ");
        query.push_bind(severity.as_str());
        has_where = true;
    }

    if let Some(ip) = &filter.ip_address {
        query.push(if has_where { " AND " } else { " WHERE " });
        query.push("v.ip_address::TEXT ILIKE ");
        query.push_bind(format!("%{}%", ip));
        has_where = true;
    }

    if let Some(hostname) = &filter.hostname {
        query.push(if has_where { " AND " } else { " WHERE " });
        query.push("v.hostname ILIKE ");
        query.push_bind(format!("%{}%", hostname));
        has_where = true;
    }

    if let Some(cve_id) = &filter.cve_id {
        query.push(if has_where { " AND " } else { " WHERE " });
        query.push("v.cve_id = ");
        query.push_bind(cve_id);
        has_where = true;
    }

    if let Some(team_id) = &filter.assigned_team_id {
        query.push(if has_where { " AND " } else { " WHERE " });
        query.push("v.assigned_team_id = ");
        query.push_bind(team_id);
        has_where = true;
    }

    if let Some(asset_id) = &filter.asset_id {
        query.push(if has_where { " AND " } else { " WHERE " });
        query.push("v.asset_id = ");
        query.push_bind(asset_id);
        has_where = true;
    }

    // Add ORDER BY and LIMIT
    query.push(" ORDER BY cvss_score DESC, created_at DESC LIMIT 100");

    let vulnerabilities = query
        .build_query_as::<Vulnerability>()
        .fetch_all(&*app_state.pool)
        .await
        .map_err(|e| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Failed to fetch vulnerabilities: {}", e),
            }),
        ))?;

    Ok(Json(vulnerabilities))
}

// Get single vulnerability - FIXED: State
pub async fn get_vulnerability(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    _claims: Claims,
    Path(vuln_id): Path<Uuid>,
) -> Result<Json<Vulnerability>, (StatusCode, Json<ErrorResponse>)> {
    let vulnerability = sqlx::query_as!(
        Vulnerability,
        r#"
        SELECT v.id, v.title, v.description, v.cvss_score, v.epss_score, v.ip_address,
               v.hostname, v.port, v.protocol,
               v.status as "status: VulnerabilityStatus",
               v.severity as "severity: VulnerabilitySeverity",
               v.cve_id, v.cwe_id, v.remediation, v.source, v.discovered_at,
               v.created_at, v.updated_at, v.asset_id, v.assigned_team_id, v.assigned_user_id,
               u.username as assigned_user_name,
               t.name as assigned_team_name,
               v.deleted_at
        FROM vulnerabilities v
        LEFT JOIN users u ON v.assigned_user_id = u.id AND u.deleted_at IS NULL
        LEFT JOIN teams t ON v.assigned_team_id = t.id AND t.deleted_at IS NULL
        WHERE v.id = $1
        "#,
        vuln_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Vulnerability not found".to_string(),
        }),
    ))?;

    Ok(Json(vulnerability))
}

// Create vulnerability - FIXED: State
pub async fn create_vulnerability(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    claims: Claims,
    Json(new_vuln): Json<NewVulnerability>,
) -> Result<Json<Vulnerability>, (StatusCode, Json<ErrorResponse>)> {
    // Auto-determine severity from CVSS score
    let severity = VulnerabilitySeverity::from_cvss(new_vuln.cvss_score);

    // First create the vulnerability
    let vuln_id: Uuid = sqlx::query_scalar!(
        r#"
        INSERT INTO vulnerabilities (
            title, description, cvss_score, epss_score, ip_address,
            hostname, port, protocol, severity, cve_id, cwe_id,
            remediation, source, discovered_at, asset_id
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)
        RETURNING id
        "#,
        new_vuln.title,
        new_vuln.description,
        new_vuln.cvss_score,
        new_vuln.epss_score,
        new_vuln.ip_address,
        new_vuln.hostname,
        new_vuln.port,
        new_vuln.protocol,
        severity as _,
        new_vuln.cve_id,
        new_vuln.cwe_id,
        new_vuln.remediation,
        new_vuln.source,
        new_vuln.discovered_at,
        new_vuln.asset_id
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: format!("Failed to create vulnerability: {}", e),
        }),
    ))?;

    // Then fetch with JOINs (will be NULL for new vulnerabilities, but keeps structure consistent)
    let vulnerability = sqlx::query_as!(
        Vulnerability,
        r#"
        SELECT v.id, v.title, v.description, v.cvss_score, v.epss_score, v.ip_address,
               v.hostname, v.port, v.protocol,
               v.status as "status: VulnerabilityStatus",
               v.severity as "severity: VulnerabilitySeverity",
               v.cve_id, v.cwe_id, v.remediation, v.source, v.discovered_at,
               v.created_at, v.updated_at, v.asset_id, v.assigned_team_id, v.assigned_user_id,
               u.username as assigned_user_name,
               t.name as assigned_team_name,
               v.deleted_at
        FROM vulnerabilities v
        LEFT JOIN users u ON v.assigned_user_id = u.id AND u.deleted_at IS NULL
        LEFT JOIN teams t ON v.assigned_team_id = t.id AND t.deleted_at IS NULL
        WHERE v.id = $1
        "#,
        vuln_id
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to fetch created vulnerability: {}", e),
        }),
    ))?;

    // Audit: Vulnerability created
    let user_id = claims.sub.parse::<Uuid>().ok();
    if let Some(uid) = user_id {
        crate::audit::audit(crate::audit::AuditAction::VulnerabilityCreated)
            .user_id(uid)
            .entity("vulnerability", vulnerability.id)
            .new_values(&vulnerability)
            .log_async((*app_state.pool).clone());
    }

    Ok(Json(vulnerability))
}

// Update vulnerability - FIXED: State
pub async fn update_vulnerability(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    claims: Claims,
    Path(vuln_id): Path<Uuid>,
    Json(update_data): Json<UpdateVulnerability>,
) -> Result<Json<Vulnerability>, (StatusCode, Json<ErrorResponse>)> {
    // Fetch old vulnerability for audit logging
    let old_vulnerability = sqlx::query_as!(
        Vulnerability,
        r#"
        SELECT v.id, v.title, v.description, v.cvss_score, v.epss_score, v.ip_address,
               v.hostname, v.port, v.protocol,
               v.status as "status: VulnerabilityStatus",
               v.severity as "severity: VulnerabilitySeverity",
               v.cve_id, v.cwe_id, v.remediation, v.source, v.discovered_at,
               v.created_at, v.updated_at, v.asset_id, v.assigned_team_id, v.assigned_user_id,
               u.username as assigned_user_name,
               t.name as assigned_team_name,
               v.deleted_at
        FROM vulnerabilities v
        LEFT JOIN users u ON v.assigned_user_id = u.id AND u.deleted_at IS NULL
        LEFT JOIN teams t ON v.assigned_team_id = t.id AND t.deleted_at IS NULL
        WHERE v.id = $1
        "#,
        vuln_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Vulnerability not found".to_string(),
        }),
    ))?;

    // If CVSS score is being updated, recalculate severity
    let new_severity = if let Some(cvss_score) = update_data.cvss_score {
        Some(VulnerabilitySeverity::from_cvss(cvss_score))
    } else {
        None
    };

    // First update the vulnerability
    let result = sqlx::query!(
        r#"
        UPDATE vulnerabilities
        SET
            title = COALESCE($2, title),
            description = COALESCE($3, description),
            cvss_score = COALESCE($4, cvss_score),
            epss_score = COALESCE($5, epss_score),
            status = COALESCE($6, status),
            severity = COALESCE($7, severity),
            remediation = COALESCE($8, remediation),
            asset_id = COALESCE($9, asset_id),
            assigned_team_id = COALESCE($10, assigned_team_id),
            assigned_user_id = COALESCE($11, assigned_user_id),
            updated_at = NOW()
        WHERE id = $1
        "#,
        vuln_id,
        update_data.title,
        update_data.description,
        update_data.cvss_score,
        update_data.epss_score,
        update_data.status as _,
        new_severity as _,
        update_data.remediation,
        update_data.asset_id,
        update_data.assigned_team_id,
        update_data.assigned_user_id
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to update vulnerability: {}", e),
        }),
    ))?;

    if result.rows_affected() == 0 {
        return Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Vulnerability not found".to_string(),
            }),
        ));
    }

    // Then fetch with JOINs to get user/team names
    let vulnerability = sqlx::query_as!(
        Vulnerability,
        r#"
        SELECT v.id, v.title, v.description, v.cvss_score, v.epss_score, v.ip_address,
               v.hostname, v.port, v.protocol,
               v.status as "status: VulnerabilityStatus",
               v.severity as "severity: VulnerabilitySeverity",
               v.cve_id, v.cwe_id, v.remediation, v.source, v.discovered_at,
               v.created_at, v.updated_at, v.asset_id, v.assigned_team_id, v.assigned_user_id,
               u.username as assigned_user_name,
               t.name as assigned_team_name,
               v.deleted_at
        FROM vulnerabilities v
        LEFT JOIN users u ON v.assigned_user_id = u.id AND u.deleted_at IS NULL
        LEFT JOIN teams t ON v.assigned_team_id = t.id AND t.deleted_at IS NULL
        WHERE v.id = $1
        "#,
        vuln_id
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to fetch updated vulnerability: {}", e),
        }),
    ))?;

    // Audit: Vulnerability updated
    let user_id = claims.sub.parse::<Uuid>().ok();
    if let Some(uid) = user_id {
        crate::audit::audit(crate::audit::AuditAction::VulnerabilityUpdated)
            .user_id(uid)
            .entity("vulnerability", vulnerability.id)
            .old_values(&old_vulnerability)
            .new_values(&vulnerability)
            .log_async((*app_state.pool).clone());
    }

    Ok(Json(vulnerability))
}

// Delete vulnerability - FIXED: State - Now uses soft delete
pub async fn delete_vulnerability(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    claims: Claims,
    Path(vuln_id): Path<Uuid>,
) -> Result<StatusCode, (StatusCode, Json<ErrorResponse>)> {
    // Soft delete: set deleted_at timestamp instead of hard delete
    let result = sqlx::query(
        "UPDATE vulnerabilities SET deleted_at = NOW() WHERE id = $1 AND deleted_at IS NULL"
    )
    .bind(vuln_id)
    .execute(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to delete vulnerability: {}", e),
        }),
    ))?;

    if result.rows_affected() == 0 {
        return Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Vulnerability not found or already deleted".to_string(),
            }),
        ));
    }

    // Audit: Vulnerability deleted
    let user_id = claims.sub.parse::<Uuid>().ok();
    if let Some(uid) = user_id {
        crate::audit::audit(crate::audit::AuditAction::VulnerabilityDeleted)
            .user_id(uid)
            .entity("vulnerability", vuln_id)
            .log_async((*app_state.pool).clone());
    }

    Ok(StatusCode::NO_CONTENT)
}

// Get vulnerabilities assigned to current user's teams - FIXED: New endpoint
pub async fn get_my_assigned_vulnerabilities(
    State(app_state): State<AppState>,
    claims: Claims,
) -> Result<Json<Vec<Vulnerability>>, (StatusCode, Json<ErrorResponse>)> {
    // First, get the user's email from their ID
    let user_id = Uuid::parse_str(&claims.sub).map_err(|e| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: format!("Invalid user ID: {}", e),
        }),
    ))?;

    let user_email: Option<String> = sqlx::query_scalar(
        "SELECT email FROM users WHERE id = $1 AND deleted_at IS NULL"
    )
    .bind(user_id)
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to fetch user email: {}", e),
        }),
    ))?;

    let user_email = user_email.ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "User not found".to_string(),
        }),
    ))?;

    // Get all teams where the current user is a member (by user_id)
    let team_ids: Vec<Uuid> = sqlx::query_scalar(
        "SELECT DISTINCT team_id FROM team_members WHERE user_id = $1 AND removed_at IS NULL"
    )
    .bind(user_id)
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to fetch user teams: {}", e),
        }),
    ))?;

    // Get all vulnerabilities assigned to any of these teams OR directly to the user
    // Using non-macro version to avoid compile-time verification issues
    let vulnerabilities: Vec<Vulnerability> = if team_ids.is_empty() {
        // If user is not in any teams, only get vulnerabilities assigned directly to user
        sqlx::query_as(
            r#"
            SELECT v.id, v.title, v.description, v.cvss_score, v.epss_score, v.ip_address,
                   v.hostname, v.port, v.protocol,
                   v.status, v.severity,
                   v.cve_id, v.cwe_id, v.remediation, v.source, v.discovered_at,
                   v.created_at, v.updated_at, v.asset_id, v.assigned_team_id, v.assigned_user_id, v.deleted_at,
                   u.username as assigned_user_name,
                   t.name as assigned_team_name
            FROM vulnerabilities v
            LEFT JOIN users u ON v.assigned_user_id = u.id AND u.deleted_at IS NULL
            LEFT JOIN teams t ON v.assigned_team_id = t.id AND t.deleted_at IS NULL
            WHERE v.assigned_user_id = $1
            ORDER BY v.cvss_score DESC, v.created_at DESC
            "#
        )
        .bind(user_id)
        .fetch_all(&*app_state.pool)
        .await
        .map_err(|e| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Failed to fetch assigned vulnerabilities: {}", e),
            }),
        ))?
    } else {
        // Get vulnerabilities assigned to teams OR directly to user
        sqlx::query_as(
            r#"
            SELECT v.id, v.title, v.description, v.cvss_score, v.epss_score, v.ip_address,
                   v.hostname, v.port, v.protocol,
                   v.status, v.severity,
                   v.cve_id, v.cwe_id, v.remediation, v.source, v.discovered_at,
                   v.created_at, v.updated_at, v.asset_id, v.assigned_team_id, v.assigned_user_id, v.deleted_at,
                   u.username as assigned_user_name,
                   t.name as assigned_team_name
            FROM vulnerabilities v
            LEFT JOIN users u ON v.assigned_user_id = u.id AND u.deleted_at IS NULL
            LEFT JOIN teams t ON v.assigned_team_id = t.id AND t.deleted_at IS NULL
            WHERE v.assigned_team_id = ANY($1) OR v.assigned_user_id = $2
            ORDER BY v.cvss_score DESC, v.created_at DESC
            "#
        )
        .bind(&team_ids)
        .bind(user_id)
        .fetch_all(&*app_state.pool)
        .await
        .map_err(|e| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Failed to fetch assigned vulnerabilities: {}", e),
            }),
        ))?
    };

    Ok(Json(vulnerabilities))
}

// Assign vulnerability to team - FIXED: State
pub async fn assign_to_team(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    claims: Claims,
    Path(vuln_id): Path<Uuid>,
    Json(assign_data): Json<AssignToTeamRequest>,
) -> Result<Json<Vulnerability>, (StatusCode, Json<ErrorResponse>)> {
    // Verify team exists
    let team_exists = sqlx::query_scalar!(
        "SELECT EXISTS(SELECT 1 FROM teams WHERE id = $1)",
        assign_data.team_id
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?
    .unwrap_or(false);

    if !team_exists {
        return Err((
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: "Team not found".to_string(),
            }),
        ));
    }

    // Update vulnerability with team assignment and fetch with JOINs
    // First update, then fetch with JOIN to get team name
    sqlx::query!(
        r#"
        UPDATE vulnerabilities
        SET
            assigned_team_id = $2,
            status = CASE
                WHEN status = 'open' THEN 'in_progress'::vulnerability_status
                ELSE status
            END,
            updated_at = NOW()
        WHERE id = $1
        "#,
        vuln_id,
        assign_data.team_id
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to assign vulnerability: {}", e),
        }),
    ))?;

    // Fetch updated vulnerability with JOINs
    let vulnerability = sqlx::query_as!(
        Vulnerability,
        r#"
        SELECT v.id, v.title, v.description, v.cvss_score, v.epss_score, v.ip_address,
               v.hostname, v.port, v.protocol,
               v.status as "status: VulnerabilityStatus",
               v.severity as "severity: VulnerabilitySeverity",
               v.cve_id, v.cwe_id, v.remediation, v.source, v.discovered_at,
               v.created_at, v.updated_at, v.asset_id, v.assigned_team_id, v.assigned_user_id,
               u.username as assigned_user_name,
               t.name as assigned_team_name,
               v.deleted_at
        FROM vulnerabilities v
        LEFT JOIN users u ON v.assigned_user_id = u.id AND u.deleted_at IS NULL
        LEFT JOIN teams t ON v.assigned_team_id = t.id AND t.deleted_at IS NULL
        WHERE v.id = $1
        "#,
        vuln_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to fetch updated vulnerability: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Vulnerability not found".to_string(),
        }),
    ))?;

    // Audit: Vulnerability assigned to team
    let user_id = claims.sub.parse::<Uuid>().ok();
    if let Some(uid) = user_id {
        crate::audit::audit(crate::audit::AuditAction::VulnerabilityAssigned)
            .user_id(uid)
            .entity("vulnerability", vulnerability.id)
            .new_values(&serde_json::json!({
                "assigned_team_id": assign_data.team_id,
                "status": vulnerability.status
            }))
            .log_async((*app_state.pool).clone());
    }

    Ok(Json(vulnerability))
}

// Assign vulnerability to user - NEW endpoint for user assignment
pub async fn assign_to_user(
    State(app_state): State<AppState>,
    claims: Claims,
    Path(vuln_id): Path<Uuid>,
    Json(assign_data): Json<AssignToUserRequest>,
) -> Result<Json<Vulnerability>, (StatusCode, Json<ErrorResponse>)> {
    // Verify user exists
    let user_exists: Option<bool> = sqlx::query_scalar(
        "SELECT EXISTS(SELECT 1 FROM users WHERE id = $1 AND deleted_at IS NULL)"
    )
    .bind(assign_data.user_id)
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?;

    if !user_exists.unwrap_or(false) {
        return Err((
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: "User not found".to_string(),
            }),
        ));
    }

    // Check if already assigned
    let current_assignment: Option<(Option<Uuid>, Option<String>)> = sqlx::query_as(
        "SELECT assigned_user_id, (SELECT username FROM users WHERE id = assigned_user_id) as assigned_user_name FROM vulnerabilities WHERE id = $1"
    )
    .bind(vuln_id)
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?;

    if let Some((Some(current_user_id), Some(current_user_name))) = current_assignment {
        if current_user_id != assign_data.user_id {
            return Err((
                StatusCode::CONFLICT,
                Json(ErrorResponse {
                    error: format!("Vulnerabilità già assegnata a {}", current_user_name),
                }),
            ));
        }
    }

    // Update vulnerability with user assignment and fetch with JOINs
    // First update, then fetch with JOIN to get user name
    sqlx::query(
        r#"
        UPDATE vulnerabilities
        SET
            assigned_user_id = $2,
            status = CASE
                WHEN status = 'open' THEN 'in_progress'
                ELSE status
            END,
            updated_at = NOW()
        WHERE id = $1
        "#
    )
    .bind(vuln_id)
    .bind(assign_data.user_id)
    .execute(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to assign vulnerability: {}", e),
        }),
    ))?;

    // Fetch updated vulnerability with JOINs
    let vulnerability: Vec<Vulnerability> = sqlx::query_as(
        r#"
        SELECT v.id, v.title, v.description, v.cvss_score, v.epss_score, v.ip_address,
               v.hostname, v.port, v.protocol,
               v.status, v.severity,
               v.cve_id, v.cwe_id, v.remediation, v.source, v.discovered_at,
               v.created_at, v.updated_at, v.asset_id, v.assigned_team_id, v.assigned_user_id,
               u.username as assigned_user_name,
               t.name as assigned_team_name,
               v.deleted_at
        FROM vulnerabilities v
        LEFT JOIN users u ON v.assigned_user_id = u.id AND u.deleted_at IS NULL
        LEFT JOIN teams t ON v.assigned_team_id = t.id AND t.deleted_at IS NULL
        WHERE v.id = $1
        "#
    )
    .bind(vuln_id)
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to fetch updated vulnerability: {}", e),
        }),
    ))?;

    let vulnerability = vulnerability.into_iter().next().ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Vulnerability not found".to_string(),
        }),
    ))?;

    // Audit: Vulnerability assigned to user
    let user_id = claims.sub.parse::<Uuid>().ok();
    if let Some(uid) = user_id {
        crate::audit::audit(crate::audit::AuditAction::VulnerabilityAssigned)
            .user_id(uid)
            .entity("vulnerability", vulnerability.id)
            .new_values(&serde_json::json!({
                "assigned_user_id": assign_data.user_id,
                "status": vulnerability.status
            }))
            .log_async((*app_state.pool).clone());
    }

    Ok(Json(vulnerability))
}

// Check for new vulnerabilities from scanners
#[derive(Serialize)]
pub struct CheckNewResponse {
    pub found: i32,
    pub imported: i32,
}

pub async fn check_new_vulnerabilities(
    State(_app_state): State<AppState>,
    _claims: Claims,
) -> Result<Json<CheckNewResponse>, (StatusCode, Json<ErrorResponse>)> {
    // TODO: Implement scanner integration
    // This is a stub that will be implemented when scanner integration is added
    Ok(Json(CheckNewResponse {
        found: 0,
        imported: 0,
    }))
}

// GET /api/vulnerabilities/:id/timeline
// Get timeline of events for a vulnerability
#[derive(Serialize)]
pub struct TimelineEvent {
    pub id: Uuid,
    pub event_type: String,
    pub old_value: Option<serde_json::Value>,
    pub new_value: Option<serde_json::Value>,
    pub message: String,
    pub metadata: Option<serde_json::Value>,
    pub actor_type: String,
    pub actor_id: Option<Uuid>,
    pub actor_name: String,
    pub created_at: chrono::DateTime<chrono::Utc>,
}

pub async fn get_vulnerability_timeline(
    State(app_state): State<AppState>,
    Path(vuln_id): Path<Uuid>,
    _claims: Claims,
) -> Result<Json<Vec<TimelineEvent>>, (StatusCode, Json<ErrorResponse>)> {
    #[derive(sqlx::FromRow)]
    struct TimelineRow {
        id: Uuid,
        event_type: String,
        old_value: Option<serde_json::Value>,
        new_value: Option<serde_json::Value>,
        message: Option<String>,
        metadata: Option<serde_json::Value>,
        actor_type: String,
        actor_id: Option<Uuid>,
        actor_name: Option<String>,
        created_at: chrono::DateTime<chrono::Utc>,
    }

    let timeline = sqlx::query_as::<_, TimelineRow>(
        r#"
        SELECT
            id,
            event_type,
            old_value,
            new_value,
            message,
            metadata,
            actor_type,
            actor_id,
            actor_name,
            created_at
        FROM vulnerability_timeline
        WHERE vulnerability_id = $1
        ORDER BY created_at DESC
        "#
    )
    .bind(vuln_id)
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| {
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Database error: {}", e),
            }),
        )
    })?;

    let events: Vec<TimelineEvent> = timeline
        .into_iter()
        .map(|row| TimelineEvent {
            id: row.id,
            event_type: row.event_type,
            old_value: row.old_value,
            new_value: row.new_value,
            message: row.message.unwrap_or_else(|| "No message".to_string()),
            metadata: row.metadata,
            actor_type: row.actor_type,
            actor_id: row.actor_id,
            actor_name: row.actor_name.unwrap_or_else(|| "Unknown".to_string()),
            created_at: row.created_at,
        })
        .collect();

    Ok(Json(events))
}
// POST /api/vulnerabilities/:id/timeline
// Add manual timeline entry
pub async fn add_timeline_entry(
    State(app_state): State<AppState>,
    claims: Claims,
    Path(vuln_id): Path<Uuid>,
    Json(request): Json<serde_json::Value>,
) -> Result<Json<serde_json::Value>, (StatusCode, Json<ErrorResponse>)> {
    let user_id = Uuid::parse_str(&claims.sub).map_err(|_| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: "Invalid user ID".to_string(),
        }),
    ))?;

    // Get username for actor_name
    let username: Option<String> = sqlx::query_scalar(
        "SELECT username FROM users WHERE id = $1"
    )
    .bind(user_id)
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to fetch user: {}", e),
        }),
    ))?;

    let actor_name = username.unwrap_or_else(|| "Unknown".to_string());

    let event_type = request.get("event_type")
        .and_then(|v| v.as_str())
        .unwrap_or("comment_added");
    let message = request.get("message")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    // Insert timeline entry
    let entry_id: Uuid = sqlx::query_scalar(
        r#"
        SELECT add_timeline_entry(
            $1, $2, $3, $4, $5, $6, $7, $8
        )
        "#
    )
    .bind(vuln_id)
    .bind(event_type)
    .bind(message)
    .bind(user_id)
    .bind(&actor_name)
    .bind(request.get("old_value"))
    .bind(request.get("new_value"))
    .bind(request.get("metadata"))
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to create timeline entry: {}", e),
        }),
    ))?;

    Ok(Json(serde_json::json!({
        "id": entry_id,
        "message": "Timeline entry created successfully"
    })))
}

// Unassign vulnerability (Release) - NEW endpoint
pub async fn unassign_vulnerability(
    State(app_state): State<AppState>,
    claims: Claims,
    Path(vuln_id): Path<Uuid>,
) -> Result<Json<Vulnerability>, (StatusCode, Json<ErrorResponse>)> {
    // Verify the user owns this vulnerability or is admin
    let user_id = Uuid::parse_str(&claims.sub).map_err(|_| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse { error: "Invalid user ID".to_string() }),
    ))?;

    // Check ownership or admin role
    let vuln_check: Option<(Option<Uuid>, String)> = sqlx::query_as(
        "SELECT assigned_user_id, (SELECT role::TEXT FROM users WHERE id = $2) as user_role FROM vulnerabilities WHERE id = $1"
    )
    .bind(vuln_id)
    .bind(user_id)
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse { error: format!("Database error: {}", e) }),
    ))?;

    let (assigned_user_id, user_role) = vuln_check.ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse { error: "Vulnerability not found".to_string() }),
    ))?;

    // Only the assigned user or admin can unassign
    if assigned_user_id != Some(user_id) && user_role != "admin" && user_role != "team_leader" {
        return Err((
            StatusCode::FORBIDDEN,
            Json(ErrorResponse { error: "Non autorizzato a rilasciare questa vulnerabilità".to_string() }),
        ));
    }

    // Unassign
    sqlx::query(
        r#"
        UPDATE vulnerabilities
        SET
            assigned_user_id = NULL,
            assigned_team_id = NULL,
            status = 'open',
            updated_at = NOW()
        WHERE id = $1
        "#
    )
    .bind(vuln_id)
    .execute(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse { error: format!("Failed to unassign vulnerability: {}", e) }),
    ))?;

    // Fetch updated vulnerability
    let vulnerability: Vec<Vulnerability> = sqlx::query_as(
        r#"
        SELECT v.id, v.title, v.description, v.cvss_score, v.epss_score, v.ip_address,
               v.hostname, v.port, v.protocol,
               v.status, v.severity,
               v.cve_id, v.cwe_id, v.remediation, v.source, v.discovered_at,
               v.created_at, v.updated_at, v.asset_id, v.assigned_team_id, v.assigned_user_id,
               u.username as assigned_user_name,
               t.name as assigned_team_name,
               v.deleted_at
        FROM vulnerabilities v
        LEFT JOIN users u ON v.assigned_user_id = u.id AND u.deleted_at IS NULL
        LEFT JOIN teams t ON v.assigned_team_id = t.id AND t.deleted_at IS NULL
        WHERE v.id = $1
        "#
    )
    .bind(vuln_id)
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse { error: format!("Failed to fetch updated vulnerability: {}", e) }),
    ))?;

    let vulnerability = vulnerability.into_iter().next().ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse { error: "Vulnerability not found after update".to_string() }),
    ))?;

    Ok(Json(vulnerability))
}

// Reassign to team member - NEW endpoint
#[derive(Deserialize)]
pub struct ReassignToTeamMemberRequest {
    target_user_id: Uuid,
}

pub async fn reassign_to_team_member(
    State(app_state): State<AppState>,
    claims: Claims,
    Path(vuln_id): Path<Uuid>,
    Json(reassign_data): Json<ReassignToTeamMemberRequest>,
) -> Result<Json<Vulnerability>, (StatusCode, Json<ErrorResponse>)> {
    let user_id = Uuid::parse_str(&claims.sub).map_err(|_| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse { error: "Invalid user ID".to_string() }),
    ))?;

    // Verify current user owns the vulnerability
    let current_owner: Option<Uuid> = sqlx::query_scalar(
        "SELECT assigned_user_id FROM vulnerabilities WHERE id = $1"
    )
    .bind(vuln_id)
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse { error: format!("Database error: {}", e) }),
    ))?;

    if current_owner != Some(user_id) {
        return Err((
            StatusCode::FORBIDDEN,
            Json(ErrorResponse { error: "Non autorizzato a riassegnare questa vulnerabilità".to_string() }),
        ));
    }

    // Verify both users are in the same team
    let same_team: Option<bool> = sqlx::query_scalar(
        r#"
        SELECT EXISTS(
            SELECT 1 FROM team_members tm1
            JOIN team_members tm2 ON tm1.team_id = tm2.team_id
            WHERE tm1.user_id = $1 AND tm2.user_id = $2
              AND tm1.removed_at IS NULL AND tm2.removed_at IS NULL
        )
        "#
    )
    .bind(user_id)
    .bind(reassign_data.target_user_id)
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse { error: format!("Database error: {}", e) }),
    ))?;

    if !same_team.unwrap_or(false) {
        return Err((
            StatusCode::FORBIDDEN,
            Json(ErrorResponse { error: "L'utente target deve essere nello stesso team".to_string() }),
        ));
    }

    // Reassign
    sqlx::query(
        r#"
        UPDATE vulnerabilities
        SET
            assigned_user_id = $2,
            updated_at = NOW()
        WHERE id = $1
        "#
    )
    .bind(vuln_id)
    .bind(reassign_data.target_user_id)
    .execute(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse { error: format!("Failed to reassign vulnerability: {}", e) }),
    ))?;

    // Fetch updated vulnerability
    let vulnerability: Vec<Vulnerability> = sqlx::query_as(
        r#"
        SELECT v.id, v.title, v.description, v.cvss_score, v.epss_score, v.ip_address,
               v.hostname, v.port, v.protocol,
               v.status, v.severity,
               v.cve_id, v.cwe_id, v.remediation, v.source, v.discovered_at,
               v.created_at, v.updated_at, v.asset_id, v.assigned_team_id, v.assigned_user_id,
               u.username as assigned_user_name,
               t.name as assigned_team_name,
               v.deleted_at
        FROM vulnerabilities v
        LEFT JOIN users u ON v.assigned_user_id = u.id AND u.deleted_at IS NULL
        LEFT JOIN teams t ON v.assigned_team_id = t.id AND t.deleted_at IS NULL
        WHERE v.id = $1
        "#
    )
    .bind(vuln_id)
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse { error: format!("Failed to fetch updated vulnerability: {}", e) }),
    ))?;

    let vulnerability = vulnerability.into_iter().next().ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse { error: "Vulnerability not found after update".to_string() }),
    ))?;

    Ok(Json(vulnerability))
}

// Get team members for current user - NEW endpoint for reassignment dropdown
pub async fn get_my_team_members(
    State(app_state): State<AppState>,
    claims: Claims,
) -> Result<Json<Vec<serde_json::Value>>, (StatusCode, Json<ErrorResponse>)> {
    let user_id = Uuid::parse_str(&claims.sub).map_err(|_| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse { error: "Invalid user ID".to_string() }),
    ))?;

    // Get all team members from teams where current user is a member
    let team_members = sqlx::query!(
        r#"
        SELECT DISTINCT u.id, u.username, u.email, tm2.team_id,
               (SELECT name FROM teams WHERE id = tm2.team_id) as team_name
        FROM team_members tm1
        JOIN team_members tm2 ON tm1.team_id = tm2.team_id
        JOIN users u ON tm2.user_id = u.id
        WHERE tm1.user_id = $1
          AND tm2.user_id != $1
          AND tm1.removed_at IS NULL
          AND tm2.removed_at IS NULL
          AND u.deleted_at IS NULL
        ORDER BY u.username
        "#,
        user_id
    )
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse { error: format!("Failed to fetch team members: {}", e) }),
    ))?;

    let result: Vec<serde_json::Value> = team_members
        .into_iter()
        .map(|tm| serde_json::json!({
            "id": tm.id,
            "username": tm.username,
            "email": tm.email,
            "team_id": tm.team_id,
            "team_name": tm.team_name
        }))
        .collect();

    Ok(Json(result))
}
