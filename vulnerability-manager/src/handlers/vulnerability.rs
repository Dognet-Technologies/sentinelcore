// src/handlers/vulnerability.rs
// FIXED: Convertito da Extension a State per Axum 0.6

use axum::{
    extract::{Path, Query, State}, // FIXED: State invece di Extension
    http::StatusCode,
    Json,
};
use serde::{Deserialize, Serialize};
use sqlx::PgPool;
use std::sync::Arc;
use uuid::Uuid;

use crate::auth::Claims;
use crate::models::vulnerability::{
    Vulnerability, VulnerabilityStatus, VulnerabilitySeverity, 
    NewVulnerability, UpdateVulnerability, VulnerabilityFilter
};
use crate::AppState;

#[derive(Serialize)]
pub struct ErrorResponse {
    error: String,
}

#[derive(Deserialize)]
pub struct AssignToTeamRequest {
    team_id: Uuid,
}

// List vulnerabilities with filtering - FIXED: State and simplified query
pub async fn list_vulnerabilities(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    _claims: Claims,
    filter: Option<Query<VulnerabilityFilter>>,
) -> Result<Json<Vec<Vulnerability>>, (StatusCode, Json<ErrorResponse>)> {
    let filter = filter.map(|Query(f)| f).unwrap_or_default();
    
    // FIXED: Simplified query without dynamic parameters for now
    // In production, you would implement proper query building with a crate like sea-query
    let vulnerabilities = if let Some(status) = &filter.status {
        // Filter by status
        sqlx::query_as!(
            Vulnerability,
            r#"
            SELECT id, title, description, cvss_score, epss_score, ip_address,
                   hostname, port, protocol, 
                   status as "status: VulnerabilityStatus", 
                   severity as "severity: VulnerabilitySeverity", 
                   cve_id, cwe_id, remediation, source, discovered_at, 
                   created_at, updated_at, asset_id, assigned_team_id
            FROM vulnerabilities
            WHERE status = $1
            ORDER BY cvss_score DESC, created_at DESC
            LIMIT 100
            "#,
            status as _
        )
        .fetch_all(&*app_state.pool)
        .await
    } else if let Some(severity) = &filter.severity {
        // Filter by severity
        sqlx::query_as!(
            Vulnerability,
            r#"
            SELECT id, title, description, cvss_score, epss_score, ip_address,
                   hostname, port, protocol, 
                   status as "status: VulnerabilityStatus", 
                   severity as "severity: VulnerabilitySeverity", 
                   cve_id, cwe_id, remediation, source, discovered_at, 
                   created_at, updated_at, asset_id, assigned_team_id
            FROM vulnerabilities
            WHERE severity = $1
            ORDER BY cvss_score DESC, created_at DESC
            LIMIT 100
            "#,
            severity as _
        )
        .fetch_all(&*app_state.pool)
        .await
    } else if let Some(ip) = &filter.ip_address {
        // Filter by IP address
        sqlx::query_as!(
            Vulnerability,
            r#"
            SELECT id, title, description, cvss_score, epss_score, ip_address,
                   hostname, port, protocol, 
                   status as "status: VulnerabilityStatus", 
                   severity as "severity: VulnerabilitySeverity", 
                   cve_id, cwe_id, remediation, source, discovered_at, 
                   created_at, updated_at, asset_id, assigned_team_id
            FROM vulnerabilities
            WHERE ip_address ILIKE $1
            ORDER BY cvss_score DESC, created_at DESC
            LIMIT 100
            "#,
            format!("%{}%", ip)
        )
        .fetch_all(&*app_state.pool)
        .await
    } else if let Some(hostname) = &filter.hostname {
        // Filter by hostname
        sqlx::query_as!(
            Vulnerability,
            r#"
            SELECT id, title, description, cvss_score, epss_score, ip_address,
                   hostname, port, protocol, 
                   status as "status: VulnerabilityStatus", 
                   severity as "severity: VulnerabilitySeverity", 
                   cve_id, cwe_id, remediation, source, discovered_at, 
                   created_at, updated_at, asset_id, assigned_team_id
            FROM vulnerabilities
            WHERE hostname ILIKE $1
            ORDER BY cvss_score DESC, created_at DESC
            LIMIT 100
            "#,
            format!("%{}%", hostname)
        )
        .fetch_all(&*app_state.pool)
        .await
    } else if let Some(cve_id) = &filter.cve_id {
        // Filter by CVE ID
        sqlx::query_as!(
            Vulnerability,
            r#"
            SELECT id, title, description, cvss_score, epss_score, ip_address,
                   hostname, port, protocol, 
                   status as "status: VulnerabilityStatus", 
                   severity as "severity: VulnerabilitySeverity", 
                   cve_id, cwe_id, remediation, source, discovered_at, 
                   created_at, updated_at, asset_id, assigned_team_id
            FROM vulnerabilities
            WHERE cve_id = $1
            ORDER BY cvss_score DESC, created_at DESC
            LIMIT 100
            "#,
            cve_id
        )
        .fetch_all(&*app_state.pool)
        .await
    } else if let Some(team_id) = &filter.assigned_team_id {
        // Filter by assigned team
        sqlx::query_as!(
            Vulnerability,
            r#"
            SELECT id, title, description, cvss_score, epss_score, ip_address,
                   hostname, port, protocol, 
                   status as "status: VulnerabilityStatus", 
                   severity as "severity: VulnerabilitySeverity", 
                   cve_id, cwe_id, remediation, source, discovered_at, 
                   created_at, updated_at, asset_id, assigned_team_id
            FROM vulnerabilities
            WHERE assigned_team_id = $1
            ORDER BY cvss_score DESC, created_at DESC
            LIMIT 100
            "#,
            team_id
        )
        .fetch_all(&*app_state.pool)
        .await
    } else if let Some(asset_id) = &filter.asset_id {
        // Filter by asset
        sqlx::query_as!(
            Vulnerability,
            r#"
            SELECT id, title, description, cvss_score, epss_score, ip_address,
                   hostname, port, protocol, 
                   status as "status: VulnerabilityStatus", 
                   severity as "severity: VulnerabilitySeverity", 
                   cve_id, cwe_id, remediation, source, discovered_at, 
                   created_at, updated_at, asset_id, assigned_team_id
            FROM vulnerabilities
            WHERE asset_id = $1
            ORDER BY cvss_score DESC, created_at DESC
            LIMIT 100
            "#,
            asset_id
        )
        .fetch_all(&*app_state.pool)
        .await
    } else {
        // No filters - get all
        sqlx::query_as!(
            Vulnerability,
            r#"
            SELECT id, title, description, cvss_score, epss_score, ip_address,
                   hostname, port, protocol, 
                   status as "status: VulnerabilityStatus", 
                   severity as "severity: VulnerabilitySeverity", 
                   cve_id, cwe_id, remediation, source, discovered_at, 
                   created_at, updated_at, asset_id, assigned_team_id
            FROM vulnerabilities
            ORDER BY cvss_score DESC, created_at DESC
            LIMIT 100
            "#
        )
        .fetch_all(&*app_state.pool)
        .await
    };

    let vulnerabilities = vulnerabilities.map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to fetch vulnerabilities: {}", e),
        }),
    ))?;

    Ok(Json(vulnerabilities))
}

// Get single vulnerability - FIXED: State
pub async fn get_vulnerability(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    _claims: Claims,
    Path(vuln_id): Path<Uuid>,
) -> Result<Json<Vulnerability>, (StatusCode, Json<ErrorResponse>)> {
    let vulnerability = sqlx::query_as!(
        Vulnerability,
        r#"
        SELECT id, title, description, cvss_score, epss_score, ip_address,
               hostname, port, protocol, 
               status as "status: VulnerabilityStatus", 
               severity as "severity: VulnerabilitySeverity", 
               cve_id, cwe_id, remediation, source, discovered_at, 
               created_at, updated_at, asset_id, assigned_team_id
        FROM vulnerabilities
        WHERE id = $1
        "#,
        vuln_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Vulnerability not found".to_string(),
        }),
    ))?;

    Ok(Json(vulnerability))
}

// Create vulnerability - FIXED: State
pub async fn create_vulnerability(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    _claims: Claims,
    Json(new_vuln): Json<NewVulnerability>,
) -> Result<Json<Vulnerability>, (StatusCode, Json<ErrorResponse>)> {
    // Auto-determine severity from CVSS score
    let severity = VulnerabilitySeverity::from_cvss(new_vuln.cvss_score);
    
    let vulnerability = sqlx::query_as!(
        Vulnerability,
        r#"
        INSERT INTO vulnerabilities (
            title, description, cvss_score, epss_score, ip_address,
            hostname, port, protocol, severity, cve_id, cwe_id,
            remediation, source, discovered_at, asset_id
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)
        RETURNING id, title, description, cvss_score, epss_score, ip_address,
                  hostname, port, protocol, 
                  status as "status: VulnerabilityStatus", 
                  severity as "severity: VulnerabilitySeverity", 
                  cve_id, cwe_id, remediation, source, discovered_at, 
                  created_at, updated_at, asset_id, assigned_team_id
        "#,
        new_vuln.title,
        new_vuln.description,
        new_vuln.cvss_score,
        new_vuln.epss_score,
        new_vuln.ip_address,
        new_vuln.hostname,
        new_vuln.port,
        new_vuln.protocol,
        severity as _,
        new_vuln.cve_id,
        new_vuln.cwe_id,
        new_vuln.remediation,
        new_vuln.source,
        new_vuln.discovered_at,
        new_vuln.asset_id
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: format!("Failed to create vulnerability: {}", e),
        }),
    ))?;

    Ok(Json(vulnerability))
}

// Update vulnerability - FIXED: State
pub async fn update_vulnerability(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    _claims: Claims,
    Path(vuln_id): Path<Uuid>,
    Json(update_data): Json<UpdateVulnerability>,
) -> Result<Json<Vulnerability>, (StatusCode, Json<ErrorResponse>)> {
    // If CVSS score is being updated, recalculate severity
    let new_severity = if let Some(cvss_score) = update_data.cvss_score {
        Some(VulnerabilitySeverity::from_cvss(cvss_score))
    } else {
        None
    };

    let vulnerability = sqlx::query_as!(
        Vulnerability,
        r#"
        UPDATE vulnerabilities
        SET 
            title = COALESCE($2, title),
            description = COALESCE($3, description),
            cvss_score = COALESCE($4, cvss_score),
            epss_score = COALESCE($5, epss_score),
            status = COALESCE($6, status),
            severity = COALESCE($7, severity),
            remediation = COALESCE($8, remediation),
            assigned_team_id = COALESCE($9, assigned_team_id),
            updated_at = NOW()
        WHERE id = $1
        RETURNING id, title, description, cvss_score, epss_score, ip_address,
                  hostname, port, protocol, 
                  status as "status: VulnerabilityStatus", 
                  severity as "severity: VulnerabilitySeverity", 
                  cve_id, cwe_id, remediation, source, discovered_at, 
                  created_at, updated_at, asset_id, assigned_team_id
        "#,
        vuln_id,
        update_data.title,
        update_data.description,
        update_data.cvss_score,
        update_data.epss_score,
        update_data.status as _,
        new_severity as _,
        update_data.remediation,
        update_data.assigned_team_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to update vulnerability: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Vulnerability not found".to_string(),
        }),
    ))?;

    Ok(Json(vulnerability))
}

// Delete vulnerability - FIXED: State
pub async fn delete_vulnerability(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    _claims: Claims,
    Path(vuln_id): Path<Uuid>,
) -> Result<StatusCode, (StatusCode, Json<ErrorResponse>)> {
    let result = sqlx::query!(
        "DELETE FROM vulnerabilities WHERE id = $1",
        vuln_id
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to delete vulnerability: {}", e),
        }),
    ))?;

    if result.rows_affected() == 0 {
        return Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Vulnerability not found".to_string(),
            }),
        ));
    }

    Ok(StatusCode::NO_CONTENT)
}

// Assign vulnerability to team - FIXED: State
pub async fn assign_to_team(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    _claims: Claims,
    Path(vuln_id): Path<Uuid>,
    Json(assign_data): Json<AssignToTeamRequest>,
) -> Result<Json<Vulnerability>, (StatusCode, Json<ErrorResponse>)> {
    // Verify team exists
    let team_exists = sqlx::query_scalar!(
        "SELECT EXISTS(SELECT 1 FROM teams WHERE id = $1)",
        assign_data.team_id
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?
    .unwrap_or(false);

    if !team_exists {
        return Err((
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: "Team not found".to_string(),
            }),
        ));
    }

    // Update vulnerability with team assignment
    let vulnerability = sqlx::query_as!(
        Vulnerability,
        r#"
        UPDATE vulnerabilities
        SET 
            assigned_team_id = $2,
            status = CASE 
                WHEN status = 'open' THEN 'in_progress'::vulnerability_status
                ELSE status 
            END,
            updated_at = NOW()
        WHERE id = $1
        RETURNING id, title, description, cvss_score, epss_score, ip_address,
                  hostname, port, protocol, 
                  status as "status: VulnerabilityStatus", 
                  severity as "severity: VulnerabilitySeverity", 
                  cve_id, cwe_id, remediation, source, discovered_at, 
                  created_at, updated_at, asset_id, assigned_team_id
        "#,
        vuln_id,
        assign_data.team_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to assign vulnerability: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Vulnerability not found".to_string(),
        }),
    ))?;

    // In a real application, you might also:
    // 1. Send notification to the team
    // 2. Create an audit log entry
    // 3. Update team workload metrics

    Ok(Json(vulnerability))
}