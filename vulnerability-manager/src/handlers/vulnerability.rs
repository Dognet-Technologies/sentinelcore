// src/handlers/vulnerability.rs
// FIXED: Convertito da Extension a State per Axum 0.6

use axum::{
    extract::{Path, Query, State}, // FIXED: State invece di Extension
    http::StatusCode,
    Json,
};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use crate::auth::Claims;
use crate::models::vulnerability::{
    Vulnerability, VulnerabilityStatus, VulnerabilitySeverity, 
    NewVulnerability, UpdateVulnerability, VulnerabilityFilter
};
use crate::state::AppState;

#[derive(Serialize)]
pub struct ErrorResponse {
    error: String,
}

#[derive(Deserialize)]
pub struct AssignToTeamRequest {
    team_id: Uuid,
}

#[derive(Deserialize)]
pub struct AssignToUserRequest {
    user_id: Uuid,
}

// List vulnerabilities with filtering - FIXED: State and simplified query
pub async fn list_vulnerabilities(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    _claims: Claims,
    filter: Option<Query<VulnerabilityFilter>>,
) -> Result<Json<Vec<Vulnerability>>, (StatusCode, Json<ErrorResponse>)> {
    let filter = filter.map(|Query(f)| f).unwrap_or_default();

    // Dynamic query builder with JOIN for user/team names
    use sqlx::QueryBuilder;

    let mut query = QueryBuilder::new(
        r#"SELECT v.id, v.title, v.description, v.cvss_score, v.epss_score, v.ip_address,
               v.hostname, v.port, v.protocol, v.status, v.severity,
               v.cve_id, v.cwe_id, v.remediation, v.source, v.discovered_at,
               v.created_at, v.updated_at, v.asset_id, v.assigned_team_id, v.assigned_user_id, v.deleted_at,
               u.username as assigned_user_name,
               t.name as assigned_team_name
        FROM vulnerabilities v
        LEFT JOIN users u ON v.assigned_user_id = u.id
        LEFT JOIN teams t ON v.assigned_team_id = t.id
        WHERE v.deleted_at IS NULL"#
    );

    let mut has_where = true;

    // Build WHERE clause dynamically based on provided filters
    // Support multiple filters with AND conditions
    if let Some(status) = &filter.status {
        query.push(if has_where { " AND " } else { " WHERE " });
        query.push("v.status = ");
        query.push_bind(status.as_str());
        has_where = true;
    }

    if let Some(severity) = &filter.severity {
        query.push(if has_where { " AND " } else { " WHERE " });
        query.push("v.severity = ");
        query.push_bind(severity.as_str());
        has_where = true;
    }

    if let Some(ip) = &filter.ip_address {
        query.push(if has_where { " AND " } else { " WHERE " });
        query.push("v.ip_address::TEXT ILIKE ");
        query.push_bind(format!("%{}%", ip));
        has_where = true;
    }

    if let Some(hostname) = &filter.hostname {
        query.push(if has_where { " AND " } else { " WHERE " });
        query.push("v.hostname ILIKE ");
        query.push_bind(format!("%{}%", hostname));
        has_where = true;
    }

    if let Some(cve_id) = &filter.cve_id {
        query.push(if has_where { " AND " } else { " WHERE " });
        query.push("v.cve_id = ");
        query.push_bind(cve_id);
        has_where = true;
    }

    if let Some(team_id) = &filter.assigned_team_id {
        query.push(if has_where { " AND " } else { " WHERE " });
        query.push("v.assigned_team_id = ");
        query.push_bind(team_id);
        has_where = true;
    }

    if let Some(asset_id) = &filter.asset_id {
        query.push(if has_where { " AND " } else { " WHERE " });
        query.push("v.asset_id = ");
        query.push_bind(asset_id);
        has_where = true;
    }

    // Add ORDER BY and LIMIT
    query.push(" ORDER BY cvss_score DESC, created_at DESC LIMIT 100");

    let vulnerabilities = query
        .build_query_as::<Vulnerability>()
        .fetch_all(&*app_state.pool)
        .await
        .map_err(|e| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Failed to fetch vulnerabilities: {}", e),
            }),
        ))?;

    Ok(Json(vulnerabilities))
}

// Get single vulnerability - FIXED: State
pub async fn get_vulnerability(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    _claims: Claims,
    Path(vuln_id): Path<Uuid>,
) -> Result<Json<Vulnerability>, (StatusCode, Json<ErrorResponse>)> {
    let vulnerability = sqlx::query_as!(
        Vulnerability,
        r#"
        SELECT v.id, v.title, v.description, v.cvss_score, v.epss_score, v.ip_address,
               v.hostname, v.port, v.protocol,
               v.status as "status: VulnerabilityStatus",
               v.severity as "severity: VulnerabilitySeverity",
               v.cve_id, v.cwe_id, v.remediation, v.source, v.discovered_at,
               v.created_at, v.updated_at, v.asset_id, v.assigned_team_id, v.assigned_user_id, v.deleted_at,
               u.username as assigned_user_name,
               t.name as assigned_team_name
        FROM vulnerabilities v
        LEFT JOIN users u ON v.assigned_user_id = u.id
        LEFT JOIN teams t ON v.assigned_team_id = t.id
        WHERE v.id = $1
        "#,
        vuln_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Vulnerability not found".to_string(),
        }),
    ))?;

    Ok(Json(vulnerability))
}

// Create vulnerability - FIXED: State
pub async fn create_vulnerability(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    claims: Claims,
    Json(new_vuln): Json<NewVulnerability>,
) -> Result<Json<Vulnerability>, (StatusCode, Json<ErrorResponse>)> {
    // Auto-determine severity from CVSS score
    let severity = VulnerabilitySeverity::from_cvss(new_vuln.cvss_score);

    // First create the vulnerability
    let vuln_id: Uuid = sqlx::query_scalar!(
        r#"
        INSERT INTO vulnerabilities (
            title, description, cvss_score, epss_score, ip_address,
            hostname, port, protocol, severity, cve_id, cwe_id,
            remediation, source, discovered_at, asset_id
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)
        RETURNING id
        "#,
        new_vuln.title,
        new_vuln.description,
        new_vuln.cvss_score,
        new_vuln.epss_score,
        new_vuln.ip_address,
        new_vuln.hostname,
        new_vuln.port,
        new_vuln.protocol,
        severity as _,
        new_vuln.cve_id,
        new_vuln.cwe_id,
        new_vuln.remediation,
        new_vuln.source,
        new_vuln.discovered_at,
        new_vuln.asset_id
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: format!("Failed to create vulnerability: {}", e),
        }),
    ))?;

    // Then fetch with JOINs (will be NULL for new vulnerabilities, but keeps structure consistent)
    let vulnerability = sqlx::query_as!(
        Vulnerability,
        r#"
        SELECT v.id, v.title, v.description, v.cvss_score, v.epss_score, v.ip_address,
               v.hostname, v.port, v.protocol,
               v.status as "status: VulnerabilityStatus",
               v.severity as "severity: VulnerabilitySeverity",
               v.cve_id, v.cwe_id, v.remediation, v.source, v.discovered_at,
               v.created_at, v.updated_at, v.asset_id, v.assigned_team_id, v.assigned_user_id, v.deleted_at,
               u.username as assigned_user_name,
               t.name as assigned_team_name
        FROM vulnerabilities v
        LEFT JOIN users u ON v.assigned_user_id = u.id
        LEFT JOIN teams t ON v.assigned_team_id = t.id
        WHERE v.id = $1
        "#,
        vuln_id
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to fetch created vulnerability: {}", e),
        }),
    ))?;

    // Audit: Vulnerability created
    let user_id = claims.sub.parse::<Uuid>().ok();
    if let Some(uid) = user_id {
        crate::audit::audit(crate::audit::AuditAction::VulnerabilityCreated)
            .user_id(uid)
            .entity("vulnerability", vulnerability.id)
            .new_values(&vulnerability)
            .log_async((*app_state.pool).clone());
    }

    Ok(Json(vulnerability))
}

// Update vulnerability - FIXED: State
pub async fn update_vulnerability(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    claims: Claims,
    Path(vuln_id): Path<Uuid>,
    Json(update_data): Json<UpdateVulnerability>,
) -> Result<Json<Vulnerability>, (StatusCode, Json<ErrorResponse>)> {
    // Fetch old vulnerability for audit logging
    let old_vulnerability = sqlx::query_as!(
        Vulnerability,
        r#"
        SELECT v.id, v.title, v.description, v.cvss_score, v.epss_score, v.ip_address,
               v.hostname, v.port, v.protocol,
               v.status as "status: VulnerabilityStatus",
               v.severity as "severity: VulnerabilitySeverity",
               v.cve_id, v.cwe_id, v.remediation, v.source, v.discovered_at,
               v.created_at, v.updated_at, v.asset_id, v.assigned_team_id, v.assigned_user_id, v.deleted_at,
               u.username as assigned_user_name,
               t.name as assigned_team_name
        FROM vulnerabilities v
        LEFT JOIN users u ON v.assigned_user_id = u.id
        LEFT JOIN teams t ON v.assigned_team_id = t.id
        WHERE v.id = $1
        "#,
        vuln_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Vulnerability not found".to_string(),
        }),
    ))?;

    // If CVSS score is being updated, recalculate severity
    let new_severity = if let Some(cvss_score) = update_data.cvss_score {
        Some(VulnerabilitySeverity::from_cvss(cvss_score))
    } else {
        None
    };

    // First update the vulnerability
    let result = sqlx::query!(
        r#"
        UPDATE vulnerabilities
        SET
            title = COALESCE($2, title),
            description = COALESCE($3, description),
            cvss_score = COALESCE($4, cvss_score),
            epss_score = COALESCE($5, epss_score),
            status = COALESCE($6, status),
            severity = COALESCE($7, severity),
            remediation = COALESCE($8, remediation),
            asset_id = COALESCE($9, asset_id),
            assigned_team_id = COALESCE($10, assigned_team_id),
            assigned_user_id = COALESCE($11, assigned_user_id),
            updated_at = NOW()
        WHERE id = $1
        "#,
        vuln_id,
        update_data.title,
        update_data.description,
        update_data.cvss_score,
        update_data.epss_score,
        update_data.status as _,
        new_severity as _,
        update_data.remediation,
        update_data.asset_id,
        update_data.assigned_team_id,
        update_data.assigned_user_id
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to update vulnerability: {}", e),
        }),
    ))?;

    if result.rows_affected() == 0 {
        return Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Vulnerability not found".to_string(),
            }),
        ));
    }

    // Then fetch with JOINs to get user/team names
    let vulnerability = sqlx::query_as!(
        Vulnerability,
        r#"
        SELECT v.id, v.title, v.description, v.cvss_score, v.epss_score, v.ip_address,
               v.hostname, v.port, v.protocol,
               v.status as "status: VulnerabilityStatus",
               v.severity as "severity: VulnerabilitySeverity",
               v.cve_id, v.cwe_id, v.remediation, v.source, v.discovered_at,
               v.created_at, v.updated_at, v.asset_id, v.assigned_team_id, v.assigned_user_id, v.deleted_at,
               u.username as assigned_user_name,
               t.name as assigned_team_name
        FROM vulnerabilities v
        LEFT JOIN users u ON v.assigned_user_id = u.id
        LEFT JOIN teams t ON v.assigned_team_id = t.id
        WHERE v.id = $1
        "#,
        vuln_id
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to fetch updated vulnerability: {}", e),
        }),
    ))?;

    // Audit: Vulnerability updated
    let user_id = claims.sub.parse::<Uuid>().ok();
    if let Some(uid) = user_id {
        crate::audit::audit(crate::audit::AuditAction::VulnerabilityUpdated)
            .user_id(uid)
            .entity("vulnerability", vulnerability.id)
            .old_values(&old_vulnerability)
            .new_values(&vulnerability)
            .log_async((*app_state.pool).clone());
    }

    Ok(Json(vulnerability))
}

// Delete vulnerability - FIXED: State - Now uses soft delete
pub async fn delete_vulnerability(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    claims: Claims,
    Path(vuln_id): Path<Uuid>,
) -> Result<StatusCode, (StatusCode, Json<ErrorResponse>)> {
    // Soft delete: set deleted_at timestamp instead of hard delete
    let result = sqlx::query(
        "UPDATE vulnerabilities SET deleted_at = NOW() WHERE id = $1 AND deleted_at IS NULL"
    )
    .bind(vuln_id)
    .execute(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to delete vulnerability: {}", e),
        }),
    ))?;

    if result.rows_affected() == 0 {
        return Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Vulnerability not found or already deleted".to_string(),
            }),
        ));
    }

    // Audit: Vulnerability deleted
    let user_id = claims.sub.parse::<Uuid>().ok();
    if let Some(uid) = user_id {
        crate::audit::audit(crate::audit::AuditAction::VulnerabilityDeleted)
            .user_id(uid)
            .entity("vulnerability", vuln_id)
            .log_async((*app_state.pool).clone());
    }

    Ok(StatusCode::NO_CONTENT)
}

// Get vulnerabilities assigned to current user's teams - FIXED: New endpoint
pub async fn get_my_assigned_vulnerabilities(
    State(app_state): State<AppState>,
    claims: Claims,
) -> Result<Json<Vec<Vulnerability>>, (StatusCode, Json<ErrorResponse>)> {
    // First, get the user's email from their ID
    let user_id = Uuid::parse_str(&claims.sub).map_err(|e| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: format!("Invalid user ID: {}", e),
        }),
    ))?;

    let user_email: Option<String> = sqlx::query_scalar(
        "SELECT email FROM users WHERE id = $1 AND deleted_at IS NULL"
    )
    .bind(user_id)
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to fetch user email: {}", e),
        }),
    ))?;

    let user_email = user_email.ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "User not found".to_string(),
        }),
    ))?;

    // Get all teams where the current user is a member (by user_id)
    let team_ids: Vec<Uuid> = sqlx::query_scalar(
        "SELECT DISTINCT team_id FROM team_members WHERE user_id = $1 AND removed_at IS NULL"
    )
    .bind(user_id)
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to fetch user teams: {}", e),
        }),
    ))?;

    // Get all vulnerabilities assigned to any of these teams OR directly to the user
    // Using non-macro version to avoid compile-time verification issues
    let vulnerabilities: Vec<Vulnerability> = if team_ids.is_empty() {
        // If user is not in any teams, only get vulnerabilities assigned directly to user
        sqlx::query_as(
            r#"
            SELECT v.id, v.title, v.description, v.cvss_score, v.epss_score, v.ip_address,
                   v.hostname, v.port, v.protocol,
                   v.status, v.severity,
                   v.cve_id, v.cwe_id, v.remediation, v.source, v.discovered_at,
                   v.created_at, v.updated_at, v.asset_id, v.assigned_team_id, v.assigned_user_id, v.deleted_at,
                   u.username as assigned_user_name,
                   t.name as assigned_team_name
            FROM vulnerabilities v
            LEFT JOIN users u ON v.assigned_user_id = u.id
            LEFT JOIN teams t ON v.assigned_team_id = t.id
            WHERE v.assigned_user_id = $1
            ORDER BY v.cvss_score DESC, v.created_at DESC
            "#
        )
        .bind(user_id)
        .fetch_all(&*app_state.pool)
        .await
        .map_err(|e| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Failed to fetch assigned vulnerabilities: {}", e),
            }),
        ))?
    } else {
        // Get vulnerabilities assigned to teams OR directly to user
        sqlx::query_as(
            r#"
            SELECT v.id, v.title, v.description, v.cvss_score, v.epss_score, v.ip_address,
                   v.hostname, v.port, v.protocol,
                   v.status, v.severity,
                   v.cve_id, v.cwe_id, v.remediation, v.source, v.discovered_at,
                   v.created_at, v.updated_at, v.asset_id, v.assigned_team_id, v.assigned_user_id, v.deleted_at,
                   u.username as assigned_user_name,
                   t.name as assigned_team_name
            FROM vulnerabilities v
            LEFT JOIN users u ON v.assigned_user_id = u.id
            LEFT JOIN teams t ON v.assigned_team_id = t.id
            WHERE v.assigned_team_id = ANY($1) OR v.assigned_user_id = $2
            ORDER BY v.cvss_score DESC, v.created_at DESC
            "#
        )
        .bind(&team_ids)
        .bind(user_id)
        .fetch_all(&*app_state.pool)
        .await
        .map_err(|e| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Failed to fetch assigned vulnerabilities: {}", e),
            }),
        ))?
    };

    Ok(Json(vulnerabilities))
}

// Assign vulnerability to team - FIXED: State
pub async fn assign_to_team(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    claims: Claims,
    Path(vuln_id): Path<Uuid>,
    Json(assign_data): Json<AssignToTeamRequest>,
) -> Result<Json<Vulnerability>, (StatusCode, Json<ErrorResponse>)> {
    // Verify team exists
    let team_exists = sqlx::query_scalar!(
        "SELECT EXISTS(SELECT 1 FROM teams WHERE id = $1)",
        assign_data.team_id
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?
    .unwrap_or(false);

    if !team_exists {
        return Err((
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: "Team not found".to_string(),
            }),
        ));
    }

    // Update vulnerability with team assignment and fetch with JOINs
    // First update, then fetch with JOIN to get team name
    sqlx::query!(
        r#"
        UPDATE vulnerabilities
        SET
            assigned_team_id = $2,
            status = CASE
                WHEN status = 'open' THEN 'in_progress'::vulnerability_status
                ELSE status
            END,
            updated_at = NOW()
        WHERE id = $1
        "#,
        vuln_id,
        assign_data.team_id
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to assign vulnerability: {}", e),
        }),
    ))?;

    // Fetch updated vulnerability with JOINs
    let vulnerability = sqlx::query_as!(
        Vulnerability,
        r#"
        SELECT v.id, v.title, v.description, v.cvss_score, v.epss_score, v.ip_address,
               v.hostname, v.port, v.protocol,
               v.status as "status: VulnerabilityStatus",
               v.severity as "severity: VulnerabilitySeverity",
               v.cve_id, v.cwe_id, v.remediation, v.source, v.discovered_at,
               v.created_at, v.updated_at, v.asset_id, v.assigned_team_id, v.assigned_user_id, v.deleted_at,
               u.username as assigned_user_name,
               t.name as assigned_team_name
        FROM vulnerabilities v
        LEFT JOIN users u ON v.assigned_user_id = u.id
        LEFT JOIN teams t ON v.assigned_team_id = t.id
        WHERE v.id = $1
        "#,
        vuln_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to fetch updated vulnerability: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Vulnerability not found".to_string(),
        }),
    ))?;

    // Audit: Vulnerability assigned to team
    let user_id = claims.sub.parse::<Uuid>().ok();
    if let Some(uid) = user_id {
        crate::audit::audit(crate::audit::AuditAction::VulnerabilityAssigned)
            .user_id(uid)
            .entity("vulnerability", vulnerability.id)
            .new_values(&serde_json::json!({
                "assigned_team_id": assign_data.team_id,
                "status": vulnerability.status
            }))
            .log_async((*app_state.pool).clone());
    }

    Ok(Json(vulnerability))
}

// Assign vulnerability to user - NEW endpoint for user assignment
pub async fn assign_to_user(
    State(app_state): State<AppState>,
    claims: Claims,
    Path(vuln_id): Path<Uuid>,
    Json(assign_data): Json<AssignToUserRequest>,
) -> Result<Json<Vulnerability>, (StatusCode, Json<ErrorResponse>)> {
    // Verify user exists
    let user_exists: Option<bool> = sqlx::query_scalar(
        "SELECT EXISTS(SELECT 1 FROM users WHERE id = $1 AND deleted_at IS NULL)"
    )
    .bind(assign_data.user_id)
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?;

    if !user_exists.unwrap_or(false) {
        return Err((
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: "User not found".to_string(),
            }),
        ));
    }

    // Update vulnerability with user assignment and fetch with JOINs
    // First update, then fetch with JOIN to get user name
    sqlx::query(
        r#"
        UPDATE vulnerabilities
        SET
            assigned_user_id = $2,
            status = CASE
                WHEN status = 'open' THEN 'in_progress'
                ELSE status
            END,
            updated_at = NOW()
        WHERE id = $1
        "#
    )
    .bind(vuln_id)
    .bind(assign_data.user_id)
    .execute(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to assign vulnerability: {}", e),
        }),
    ))?;

    // Fetch updated vulnerability with JOINs
    let vulnerability: Vec<Vulnerability> = sqlx::query_as(
        r#"
        SELECT v.id, v.title, v.description, v.cvss_score, v.epss_score, v.ip_address,
               v.hostname, v.port, v.protocol,
               v.status, v.severity,
               v.cve_id, v.cwe_id, v.remediation, v.source, v.discovered_at,
               v.created_at, v.updated_at, v.asset_id, v.assigned_team_id, v.assigned_user_id, v.deleted_at,
               u.username as assigned_user_name,
               t.name as assigned_team_name
        FROM vulnerabilities v
        LEFT JOIN users u ON v.assigned_user_id = u.id
        LEFT JOIN teams t ON v.assigned_team_id = t.id
        WHERE v.id = $1
        "#
    )
    .bind(vuln_id)
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to fetch updated vulnerability: {}", e),
        }),
    ))?;

    let vulnerability = vulnerability.into_iter().next().ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Vulnerability not found".to_string(),
        }),
    ))?;

    // Audit: Vulnerability assigned to user
    let user_id = claims.sub.parse::<Uuid>().ok();
    if let Some(uid) = user_id {
        crate::audit::audit(crate::audit::AuditAction::VulnerabilityAssigned)
            .user_id(uid)
            .entity("vulnerability", vulnerability.id)
            .new_values(&serde_json::json!({
                "assigned_user_id": assign_data.user_id,
                "status": vulnerability.status
            }))
            .log_async((*app_state.pool).clone());
    }

    Ok(Json(vulnerability))
}

// Check for new vulnerabilities from scanners
#[derive(Serialize)]
pub struct CheckNewResponse {
    pub found: i32,
    pub imported: i32,
}

pub async fn check_new_vulnerabilities(
    State(_app_state): State<AppState>,
    _claims: Claims,
) -> Result<Json<CheckNewResponse>, (StatusCode, Json<ErrorResponse>)> {
    // TODO: Implement scanner integration
    // This is a stub that will be implemented when scanner integration is added
    Ok(Json(CheckNewResponse {
        found: 0,
        imported: 0,
    }))
}

// GET /api/vulnerabilities/:id/timeline
// Get timeline of events for a vulnerability
#[derive(Serialize)]
pub struct TimelineEvent {
    pub id: Uuid,
    pub event_type: String,
    pub old_value: Option<serde_json::Value>,
    pub new_value: Option<serde_json::Value>,
    pub message: String,
    pub metadata: Option<serde_json::Value>,
    pub actor_type: String,
    pub actor_id: Option<Uuid>,
    pub actor_name: String,
    pub created_at: chrono::DateTime<chrono::Utc>,
}

pub async fn get_vulnerability_timeline(
    State(app_state): State<AppState>,
    Path(vuln_id): Path<Uuid>,
    _claims: Claims,
) -> Result<Json<Vec<TimelineEvent>>, (StatusCode, Json<ErrorResponse>)> {
    #[derive(sqlx::FromRow)]
    struct TimelineRow {
        id: Uuid,
        event_type: String,
        old_value: Option<serde_json::Value>,
        new_value: Option<serde_json::Value>,
        message: Option<String>,
        metadata: Option<serde_json::Value>,
        actor_type: String,
        actor_id: Option<Uuid>,
        actor_name: Option<String>,
        created_at: chrono::DateTime<chrono::Utc>,
    }

    let timeline = sqlx::query_as::<_, TimelineRow>(
        r#"
        SELECT
            id,
            event_type,
            old_value,
            new_value,
            message,
            metadata,
            actor_type,
            actor_id,
            actor_name,
            created_at
        FROM vulnerability_timeline
        WHERE vulnerability_id = $1
        ORDER BY created_at DESC
        "#
    )
    .bind(vuln_id)
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| {
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Database error: {}", e),
            }),
        )
    })?;

    let events: Vec<TimelineEvent> = timeline
        .into_iter()
        .map(|row| TimelineEvent {
            id: row.id,
            event_type: row.event_type,
            old_value: row.old_value,
            new_value: row.new_value,
            message: row.message.unwrap_or_else(|| "No message".to_string()),
            metadata: row.metadata,
            actor_type: row.actor_type,
            actor_id: row.actor_id,
            actor_name: row.actor_name.unwrap_or_else(|| "Unknown".to_string()),
            created_at: row.created_at,
        })
        .collect();

    Ok(Json(events))
}