// src/handlers/vulnerability.rs
// FIXED: Convertito da Extension a State per Axum 0.6

use axum::{
    extract::{Path, Query, State}, // FIXED: State invece di Extension
    http::StatusCode,
    Json,
};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use crate::auth::Claims;
use crate::models::vulnerability::{
    Vulnerability, VulnerabilityStatus, VulnerabilitySeverity, 
    NewVulnerability, UpdateVulnerability, VulnerabilityFilter
};
use crate::state::AppState;

#[derive(Serialize)]
pub struct ErrorResponse {
    error: String,
}

#[derive(Deserialize)]
pub struct AssignToTeamRequest {
    team_id: Uuid,
}

#[derive(Deserialize)]
pub struct AssignToUserRequest {
    user_id: Uuid,
}

// List vulnerabilities with filtering - FIXED: State and simplified query
pub async fn list_vulnerabilities(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    _claims: Claims,
    filter: Option<Query<VulnerabilityFilter>>,
) -> Result<Json<Vec<Vulnerability>>, (StatusCode, Json<ErrorResponse>)> {
    let filter = filter.map(|Query(f)| f).unwrap_or_default();
    
    // FIXED: Simplified query without dynamic parameters for now
    // In production, you would implement proper query building with a crate like sea-query
    let vulnerabilities = if let Some(status) = &filter.status {
        // Filter by status
        sqlx::query_as!(
            Vulnerability,
            r#"
            SELECT id, title, description, cvss_score, epss_score, ip_address,
                   hostname, port, protocol, 
                   status as "status: VulnerabilityStatus", 
                   severity as "severity: VulnerabilitySeverity", 
                   cve_id, cwe_id, remediation, source, discovered_at, 
                   created_at, updated_at, asset_id, assigned_team_id, assigned_user_id
            FROM vulnerabilities
            WHERE status = $1
            ORDER BY cvss_score DESC, created_at DESC
            LIMIT 100
            "#,
            status as _
        )
        .fetch_all(&*app_state.pool)
        .await
    } else if let Some(severity) = &filter.severity {
        // Filter by severity
        sqlx::query_as!(
            Vulnerability,
            r#"
            SELECT id, title, description, cvss_score, epss_score, ip_address,
                   hostname, port, protocol, 
                   status as "status: VulnerabilityStatus", 
                   severity as "severity: VulnerabilitySeverity", 
                   cve_id, cwe_id, remediation, source, discovered_at, 
                   created_at, updated_at, asset_id, assigned_team_id, assigned_user_id
            FROM vulnerabilities
            WHERE severity = $1
            ORDER BY cvss_score DESC, created_at DESC
            LIMIT 100
            "#,
            severity as _
        )
        .fetch_all(&*app_state.pool)
        .await
    } else if let Some(ip) = &filter.ip_address {
        // Filter by IP address (cast INET to TEXT for pattern matching)
        sqlx::query_as!(
            Vulnerability,
            r#"
            SELECT id, title, description, cvss_score, epss_score, ip_address,
                   hostname, port, protocol,
                   status as "status: VulnerabilityStatus",
                   severity as "severity: VulnerabilitySeverity",
                   cve_id, cwe_id, remediation, source, discovered_at,
                   created_at, updated_at, asset_id, assigned_team_id, assigned_user_id
            FROM vulnerabilities
            WHERE ip_address::TEXT ILIKE $1
            ORDER BY cvss_score DESC, created_at DESC
            LIMIT 100
            "#,
            format!("%{}%", ip)
        )
        .fetch_all(&*app_state.pool)
        .await
    } else if let Some(hostname) = &filter.hostname {
        // Filter by hostname
        sqlx::query_as!(
            Vulnerability,
            r#"
            SELECT id, title, description, cvss_score, epss_score, ip_address,
                   hostname, port, protocol, 
                   status as "status: VulnerabilityStatus", 
                   severity as "severity: VulnerabilitySeverity", 
                   cve_id, cwe_id, remediation, source, discovered_at, 
                   created_at, updated_at, asset_id, assigned_team_id, assigned_user_id
            FROM vulnerabilities
            WHERE hostname ILIKE $1
            ORDER BY cvss_score DESC, created_at DESC
            LIMIT 100
            "#,
            format!("%{}%", hostname)
        )
        .fetch_all(&*app_state.pool)
        .await
    } else if let Some(cve_id) = &filter.cve_id {
        // Filter by CVE ID
        sqlx::query_as!(
            Vulnerability,
            r#"
            SELECT id, title, description, cvss_score, epss_score, ip_address,
                   hostname, port, protocol, 
                   status as "status: VulnerabilityStatus", 
                   severity as "severity: VulnerabilitySeverity", 
                   cve_id, cwe_id, remediation, source, discovered_at, 
                   created_at, updated_at, asset_id, assigned_team_id, assigned_user_id
            FROM vulnerabilities
            WHERE cve_id = $1
            ORDER BY cvss_score DESC, created_at DESC
            LIMIT 100
            "#,
            cve_id
        )
        .fetch_all(&*app_state.pool)
        .await
    } else if let Some(team_id) = &filter.assigned_team_id {
        // Filter by assigned team
        sqlx::query_as!(
            Vulnerability,
            r#"
            SELECT id, title, description, cvss_score, epss_score, ip_address,
                   hostname, port, protocol, 
                   status as "status: VulnerabilityStatus", 
                   severity as "severity: VulnerabilitySeverity", 
                   cve_id, cwe_id, remediation, source, discovered_at, 
                   created_at, updated_at, asset_id, assigned_team_id, assigned_user_id
            FROM vulnerabilities
            WHERE assigned_team_id = $1
            ORDER BY cvss_score DESC, created_at DESC
            LIMIT 100
            "#,
            team_id
        )
        .fetch_all(&*app_state.pool)
        .await
    } else if let Some(asset_id) = &filter.asset_id {
        // Filter by asset
        sqlx::query_as!(
            Vulnerability,
            r#"
            SELECT id, title, description, cvss_score, epss_score, ip_address,
                   hostname, port, protocol, 
                   status as "status: VulnerabilityStatus", 
                   severity as "severity: VulnerabilitySeverity", 
                   cve_id, cwe_id, remediation, source, discovered_at, 
                   created_at, updated_at, asset_id, assigned_team_id, assigned_user_id
            FROM vulnerabilities
            WHERE asset_id = $1
            ORDER BY cvss_score DESC, created_at DESC
            LIMIT 100
            "#,
            asset_id
        )
        .fetch_all(&*app_state.pool)
        .await
    } else {
        // No filters - get all
        sqlx::query_as!(
            Vulnerability,
            r#"
            SELECT id, title, description, cvss_score, epss_score, ip_address,
                   hostname, port, protocol, 
                   status as "status: VulnerabilityStatus", 
                   severity as "severity: VulnerabilitySeverity", 
                   cve_id, cwe_id, remediation, source, discovered_at, 
                   created_at, updated_at, asset_id, assigned_team_id, assigned_user_id
            FROM vulnerabilities
            ORDER BY cvss_score DESC, created_at DESC
            LIMIT 100
            "#
        )
        .fetch_all(&*app_state.pool)
        .await
    };

    let vulnerabilities = vulnerabilities.map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to fetch vulnerabilities: {}", e),
        }),
    ))?;

    Ok(Json(vulnerabilities))
}

// Get single vulnerability - FIXED: State
pub async fn get_vulnerability(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    _claims: Claims,
    Path(vuln_id): Path<Uuid>,
) -> Result<Json<Vulnerability>, (StatusCode, Json<ErrorResponse>)> {
    let vulnerability = sqlx::query_as!(
        Vulnerability,
        r#"
        SELECT id, title, description, cvss_score, epss_score, ip_address,
               hostname, port, protocol, 
               status as "status: VulnerabilityStatus", 
               severity as "severity: VulnerabilitySeverity", 
               cve_id, cwe_id, remediation, source, discovered_at, 
               created_at, updated_at, asset_id, assigned_team_id, assigned_user_id
        FROM vulnerabilities
        WHERE id = $1
        "#,
        vuln_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Vulnerability not found".to_string(),
        }),
    ))?;

    Ok(Json(vulnerability))
}

// Create vulnerability - FIXED: State
pub async fn create_vulnerability(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    claims: Claims,
    Json(new_vuln): Json<NewVulnerability>,
) -> Result<Json<Vulnerability>, (StatusCode, Json<ErrorResponse>)> {
    // Auto-determine severity from CVSS score
    let severity = VulnerabilitySeverity::from_cvss(new_vuln.cvss_score);
    
    let vulnerability = sqlx::query_as!(
        Vulnerability,
        r#"
        INSERT INTO vulnerabilities (
            title, description, cvss_score, epss_score, ip_address,
            hostname, port, protocol, severity, cve_id, cwe_id,
            remediation, source, discovered_at, asset_id
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)
        RETURNING id, title, description, cvss_score, epss_score, ip_address,
                  hostname, port, protocol, 
                  status as "status: VulnerabilityStatus", 
                  severity as "severity: VulnerabilitySeverity", 
                  cve_id, cwe_id, remediation, source, discovered_at, 
                  created_at, updated_at, asset_id, assigned_team_id, assigned_user_id
        "#,
        new_vuln.title,
        new_vuln.description,
        new_vuln.cvss_score,
        new_vuln.epss_score,
        new_vuln.ip_address,
        new_vuln.hostname,
        new_vuln.port,
        new_vuln.protocol,
        severity as _,
        new_vuln.cve_id,
        new_vuln.cwe_id,
        new_vuln.remediation,
        new_vuln.source,
        new_vuln.discovered_at,
        new_vuln.asset_id
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: format!("Failed to create vulnerability: {}", e),
        }),
    ))?;

    // Audit: Vulnerability created
    let user_id = claims.sub.parse::<Uuid>().ok();
    if let Some(uid) = user_id {
        crate::audit::audit(crate::audit::AuditAction::VulnerabilityCreated)
            .user_id(uid)
            .entity("vulnerability", vulnerability.id)
            .new_values(&vulnerability)
            .log_async((*app_state.pool).clone());
    }

    Ok(Json(vulnerability))
}

// Update vulnerability - FIXED: State
pub async fn update_vulnerability(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    claims: Claims,
    Path(vuln_id): Path<Uuid>,
    Json(update_data): Json<UpdateVulnerability>,
) -> Result<Json<Vulnerability>, (StatusCode, Json<ErrorResponse>)> {
    // Fetch old vulnerability for audit logging
    let old_vulnerability = sqlx::query_as!(
        Vulnerability,
        r#"
        SELECT id, title, description, cvss_score, epss_score, ip_address,
               hostname, port, protocol,
               status as "status: VulnerabilityStatus",
               severity as "severity: VulnerabilitySeverity",
               cve_id, cwe_id, remediation, source, discovered_at,
               created_at, updated_at, asset_id, assigned_team_id, assigned_user_id
        FROM vulnerabilities
        WHERE id = $1
        "#,
        vuln_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Vulnerability not found".to_string(),
        }),
    ))?;

    // If CVSS score is being updated, recalculate severity
    let new_severity = if let Some(cvss_score) = update_data.cvss_score {
        Some(VulnerabilitySeverity::from_cvss(cvss_score))
    } else {
        None
    };

    let vulnerability = sqlx::query_as!(
        Vulnerability,
        r#"
        UPDATE vulnerabilities
        SET
            title = COALESCE($2, title),
            description = COALESCE($3, description),
            cvss_score = COALESCE($4, cvss_score),
            epss_score = COALESCE($5, epss_score),
            status = COALESCE($6, status),
            severity = COALESCE($7, severity),
            remediation = COALESCE($8, remediation),
            assigned_team_id = COALESCE($9, assigned_team_id),
            updated_at = NOW()
        WHERE id = $1
        RETURNING id, title, description, cvss_score, epss_score, ip_address,
                  hostname, port, protocol,
                  status as "status: VulnerabilityStatus",
                  severity as "severity: VulnerabilitySeverity",
                  cve_id, cwe_id, remediation, source, discovered_at,
                  created_at, updated_at, asset_id, assigned_team_id, assigned_user_id
        "#,
        vuln_id,
        update_data.title,
        update_data.description,
        update_data.cvss_score,
        update_data.epss_score,
        update_data.status as _,
        new_severity as _,
        update_data.remediation,
        update_data.assigned_team_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to update vulnerability: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Vulnerability not found".to_string(),
        }),
    ))?;

    // Audit: Vulnerability updated
    let user_id = claims.sub.parse::<Uuid>().ok();
    if let Some(uid) = user_id {
        crate::audit::audit(crate::audit::AuditAction::VulnerabilityUpdated)
            .user_id(uid)
            .entity("vulnerability", vulnerability.id)
            .old_values(&old_vulnerability)
            .new_values(&vulnerability)
            .log_async((*app_state.pool).clone());
    }

    Ok(Json(vulnerability))
}

// Delete vulnerability - FIXED: State - Now uses soft delete
pub async fn delete_vulnerability(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    claims: Claims,
    Path(vuln_id): Path<Uuid>,
) -> Result<StatusCode, (StatusCode, Json<ErrorResponse>)> {
    // Soft delete: set deleted_at timestamp instead of hard delete
    let result = sqlx::query(
        "UPDATE vulnerabilities SET deleted_at = NOW() WHERE id = $1 AND deleted_at IS NULL"
    )
    .bind(vuln_id)
    .execute(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to delete vulnerability: {}", e),
        }),
    ))?;

    if result.rows_affected() == 0 {
        return Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Vulnerability not found or already deleted".to_string(),
            }),
        ));
    }

    // Audit: Vulnerability deleted
    let user_id = claims.sub.parse::<Uuid>().ok();
    if let Some(uid) = user_id {
        crate::audit::audit(crate::audit::AuditAction::VulnerabilityDeleted)
            .user_id(uid)
            .entity("vulnerability", vuln_id)
            .log_async((*app_state.pool).clone());
    }

    Ok(StatusCode::NO_CONTENT)
}

// Get vulnerabilities assigned to current user's teams - FIXED: New endpoint
pub async fn get_my_assigned_vulnerabilities(
    State(app_state): State<AppState>,
    claims: Claims,
) -> Result<Json<Vec<Vulnerability>>, (StatusCode, Json<ErrorResponse>)> {
    // First, get the user's email from their ID
    let user_id = Uuid::parse_str(&claims.sub).map_err(|e| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: format!("Invalid user ID: {}", e),
        }),
    ))?;

    let user_email: Option<String> = sqlx::query_scalar(
        "SELECT email FROM users WHERE id = $1 AND deleted_at IS NULL"
    )
    .bind(user_id)
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to fetch user email: {}", e),
        }),
    ))?;

    let user_email = user_email.ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "User not found".to_string(),
        }),
    ))?;

    // Get all teams where the current user is a member (by email)
    let team_ids: Vec<Uuid> = sqlx::query_scalar(
        "SELECT DISTINCT team_id FROM team_members WHERE email = $1"
    )
    .bind(&user_email)
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to fetch user teams: {}", e),
        }),
    ))?;

    // Get all vulnerabilities assigned to any of these teams OR directly to the user
    // Using non-macro version to avoid compile-time verification issues
    let vulnerabilities: Vec<Vulnerability> = if team_ids.is_empty() {
        // If user is not in any teams, only get vulnerabilities assigned directly to user
        sqlx::query_as(
            r#"
            SELECT id, title, description, cvss_score, epss_score, ip_address,
                   hostname, port, protocol,
                   status, severity,
                   cve_id, cwe_id, remediation, source, discovered_at,
                   created_at, updated_at, asset_id, assigned_team_id, assigned_user_id
            FROM vulnerabilities
            WHERE assigned_user_id = $1
            ORDER BY cvss_score DESC, created_at DESC
            "#
        )
        .bind(user_id)
        .fetch_all(&*app_state.pool)
        .await
        .map_err(|e| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Failed to fetch assigned vulnerabilities: {}", e),
            }),
        ))?
    } else {
        // Get vulnerabilities assigned to teams OR directly to user
        sqlx::query_as(
            r#"
            SELECT id, title, description, cvss_score, epss_score, ip_address,
                   hostname, port, protocol,
                   status, severity,
                   cve_id, cwe_id, remediation, source, discovered_at,
                   created_at, updated_at, asset_id, assigned_team_id, assigned_user_id
            FROM vulnerabilities
            WHERE assigned_team_id = ANY($1) OR assigned_user_id = $2
            ORDER BY cvss_score DESC, created_at DESC
            "#
        )
        .bind(&team_ids)
        .bind(user_id)
        .fetch_all(&*app_state.pool)
        .await
        .map_err(|e| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Failed to fetch assigned vulnerabilities: {}", e),
            }),
        ))?
    };

    Ok(Json(vulnerabilities))
}

// Assign vulnerability to team - FIXED: State
pub async fn assign_to_team(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    claims: Claims,
    Path(vuln_id): Path<Uuid>,
    Json(assign_data): Json<AssignToTeamRequest>,
) -> Result<Json<Vulnerability>, (StatusCode, Json<ErrorResponse>)> {
    // Verify team exists
    let team_exists = sqlx::query_scalar!(
        "SELECT EXISTS(SELECT 1 FROM teams WHERE id = $1)",
        assign_data.team_id
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?
    .unwrap_or(false);

    if !team_exists {
        return Err((
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: "Team not found".to_string(),
            }),
        ));
    }

    // Update vulnerability with team assignment
    let vulnerability = sqlx::query_as!(
        Vulnerability,
        r#"
        UPDATE vulnerabilities
        SET
            assigned_team_id = $2,
            status = CASE
                WHEN status = 'open' THEN 'in_progress'::vulnerability_status
                ELSE status
            END,
            updated_at = NOW()
        WHERE id = $1
        RETURNING id, title, description, cvss_score, epss_score, ip_address,
                  hostname, port, protocol,
                  status as "status: VulnerabilityStatus",
                  severity as "severity: VulnerabilitySeverity",
                  cve_id, cwe_id, remediation, source, discovered_at,
                  created_at, updated_at, asset_id, assigned_team_id, assigned_user_id
        "#,
        vuln_id,
        assign_data.team_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to assign vulnerability: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Vulnerability not found".to_string(),
        }),
    ))?;

    // Audit: Vulnerability assigned to team
    let user_id = claims.sub.parse::<Uuid>().ok();
    if let Some(uid) = user_id {
        crate::audit::audit(crate::audit::AuditAction::VulnerabilityAssigned)
            .user_id(uid)
            .entity("vulnerability", vulnerability.id)
            .new_values(&serde_json::json!({
                "assigned_team_id": assign_data.team_id,
                "status": vulnerability.status
            }))
            .log_async((*app_state.pool).clone());
    }

    Ok(Json(vulnerability))
}

// Assign vulnerability to user - NEW endpoint for user assignment
pub async fn assign_to_user(
    State(app_state): State<AppState>,
    claims: Claims,
    Path(vuln_id): Path<Uuid>,
    Json(assign_data): Json<AssignToUserRequest>,
) -> Result<Json<Vulnerability>, (StatusCode, Json<ErrorResponse>)> {
    // Verify user exists
    let user_exists: Option<bool> = sqlx::query_scalar(
        "SELECT EXISTS(SELECT 1 FROM users WHERE id = $1 AND deleted_at IS NULL)"
    )
    .bind(assign_data.user_id)
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?;

    if !user_exists.unwrap_or(false) {
        return Err((
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: "User not found".to_string(),
            }),
        ));
    }

    // Update vulnerability with user assignment - using non-macro version
    let vulnerability: Vec<Vulnerability> = sqlx::query_as(
        r#"
        UPDATE vulnerabilities
        SET
            assigned_user_id = $2,
            status = CASE
                WHEN status = 'open' THEN 'in_progress'
                ELSE status
            END,
            updated_at = NOW()
        WHERE id = $1
        RETURNING id, title, description, cvss_score, epss_score, ip_address,
                  hostname, port, protocol,
                  status, severity,
                  cve_id, cwe_id, remediation, source, discovered_at,
                  created_at, updated_at, asset_id, assigned_team_id, assigned_user_id
        "#
    )
    .bind(vuln_id)
    .bind(assign_data.user_id)
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to assign vulnerability: {}", e),
        }),
    ))?;

    let vulnerability = vulnerability.into_iter().next().ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Vulnerability not found".to_string(),
        }),
    ))?;

    // Audit: Vulnerability assigned to user
    let user_id = claims.sub.parse::<Uuid>().ok();
    if let Some(uid) = user_id {
        crate::audit::audit(crate::audit::AuditAction::VulnerabilityAssigned)
            .user_id(uid)
            .entity("vulnerability", vulnerability.id)
            .new_values(&serde_json::json!({
                "assigned_user_id": assign_data.user_id,
                "status": vulnerability.status
            }))
            .log_async((*app_state.pool).clone());
    }

    Ok(Json(vulnerability))
}