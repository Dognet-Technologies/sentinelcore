// src/handlers/vulnerability.rs
// FIXED: Rimosso ipnetwork::IpNetwork, corretto create_vulnerability

use axum::{
    extract::{Path, Query, Extension},
    http::StatusCode,
    Json,
};
use sqlx::PgPool;
use std::sync::Arc;
use uuid::Uuid;
use crate::auth::Claims;
use crate::models::{
    Vulnerability, VulnerabilitySeverity, VulnerabilityStatus, 
    NewVulnerability, UpdateVulnerability, VulnerabilityFilter
};

#[derive(Debug, serde::Serialize)]
pub struct ErrorResponse {
    pub error: String,
}

#[derive(Debug, serde::Deserialize)]
pub struct AssignTeamRequest {
    pub team_id: Uuid,
}

// LIST - Elenca vulnerabilità con filtri opzionali
pub async fn list_vulnerabilities(
    Extension(pool): Extension<Arc<PgPool>>,
    _claims: Claims,
    filter: Option<Query<VulnerabilityFilter>>,
) -> Result<Json<Vec<Vulnerability>>, (StatusCode, Json<ErrorResponse>)> {
    let _filter = filter.unwrap_or_default();
    
    // Query semplice - PostgreSQL converte automaticamente String ↔ INET
    let vulnerabilities = sqlx::query_as!(
        Vulnerability,
        r#"
        SELECT id, title, description, cvss_score, epss_score, ip_address::text as ip_address,
               hostname, port, protocol, status as "status: VulnerabilityStatus", 
               severity as "severity: VulnerabilitySeverity",
               cve_id, cwe_id, remediation, source, discovered_at, created_at, 
               updated_at, asset_id, assigned_team_id
        FROM vulnerabilities
        ORDER BY created_at DESC
        "#
    )
    .fetch_all(&*pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore durante il recupero: {}", e),
        }),
    ))?;

    Ok(Json(vulnerabilities))
}

// GET - Ottieni vulnerabilità per ID
pub async fn get_vulnerability(
    Extension(pool): Extension<Arc<PgPool>>,
    _claims: Claims,
    Path(vuln_id): Path<Uuid>,
) -> Result<Json<Vulnerability>, (StatusCode, Json<ErrorResponse>)> {
    let vulnerability = sqlx::query_as!(
        Vulnerability,
        r#"
        SELECT id, title, description, cvss_score, epss_score, ip_address::text as ip_address,
               hostname, port, protocol, status as "status: VulnerabilityStatus", 
               severity as "severity: VulnerabilitySeverity",
               cve_id, cwe_id, remediation, source, discovered_at, created_at, 
               updated_at, asset_id, assigned_team_id
        FROM vulnerabilities
        WHERE id = $1
        "#,
        vuln_id
    )
    .fetch_optional(&*pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore durante il recupero: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Vulnerabilità non trovata".to_string(),
        }),
    ))?;

    Ok(Json(vulnerability))
}

// CREATE - Crea nuova vulnerabilità
pub async fn create_vulnerability(
    Extension(pool): Extension<Arc<PgPool>>,
    _claims: Claims,
    Json(new_vuln): Json<NewVulnerability>,
) -> Result<Json<Vulnerability>, (StatusCode, Json<ErrorResponse>)> {
    // OPZIONALE: Validazione IP address semplice senza IpNetwork
    if let Err(_) = new_vuln.ip_address.parse::<std::net::IpAddr>() {
        return Err((
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: "Indirizzo IP non valido".to_string(),
            }),
        ));
    }

    let vulnerability = sqlx::query_as!(
        Vulnerability,
        r#"
        INSERT INTO vulnerabilities (
            title, description, cvss_score, epss_score, ip_address,
            hostname, port, protocol, status, severity, cve_id, cwe_id,
            remediation, source, discovered_at, asset_id
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, 
                'open', $9, $10, $11, $12, $13, $14, $15)
        RETURNING id, title, description, cvss_score, epss_score, ip_address::text as ip_address,
                  hostname, port, protocol, status as "status: VulnerabilityStatus", 
                  severity as "severity: VulnerabilitySeverity",
                  cve_id, cwe_id, remediation, source, discovered_at, created_at, 
                  updated_at, asset_id, assigned_team_id
        "#,
        new_vuln.title,
        new_vuln.description,
        new_vuln.cvss_score,
        new_vuln.epss_score,
        new_vuln.ip_address,  // String diretto - PostgreSQL converte automaticamente a INET
        new_vuln.hostname,
        new_vuln.port,
        new_vuln.protocol,
        VulnerabilitySeverity::from_cvss(new_vuln.cvss_score) as _,
        new_vuln.cve_id,
        new_vuln.cwe_id,
        new_vuln.remediation,
        new_vuln.source,
        new_vuln.discovered_at,
        new_vuln.asset_id
    )
    .fetch_one(&*pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore durante la creazione: {}", e),
        }),
    ))?;

    Ok(Json(vulnerability))
}

// UPDATE - Aggiorna vulnerabilità
pub async fn update_vulnerability(
    Extension(pool): Extension<Arc<PgPool>>,
    _claims: Claims,
    Path(vuln_id): Path<Uuid>,
    Json(update_data): Json<UpdateVulnerability>,
) -> Result<Json<Vulnerability>, (StatusCode, Json<ErrorResponse>)> {
    let vulnerability = sqlx::query_as!(
        Vulnerability,
        r#"
        UPDATE vulnerabilities
        SET 
            title = COALESCE($2, title),
            description = COALESCE($3, description),
            cvss_score = COALESCE($4, cvss_score),
            epss_score = COALESCE($5, epss_score),
            status = COALESCE($6, status),
            remediation = COALESCE($7, remediation),
            assigned_team_id = COALESCE($8, assigned_team_id),
            updated_at = NOW()
        WHERE id = $1
        RETURNING id, title, description, cvss_score, epss_score, ip_address::text as ip_address,
                  hostname, port, protocol, status as "status: VulnerabilityStatus", 
                  severity as "severity: VulnerabilitySeverity",
                  cve_id, cwe_id, remediation, source, discovered_at, created_at, 
                  updated_at, asset_id, assigned_team_id
        "#,
        vuln_id,
        update_data.title,
        update_data.description,
        update_data.cvss_score,
        update_data.epss_score,
        update_data.status.map(|s| s as _),
        update_data.remediation,
        update_data.assigned_team_id
    )
    .fetch_optional(&*pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore durante l'aggiornamento: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Vulnerabilità non trovata".to_string(),
        }),
    ))?;

    Ok(Json(vulnerability))
}

// DELETE - Elimina vulnerabilità
pub async fn delete_vulnerability(
    Extension(pool): Extension<Arc<PgPool>>,
    _claims: Claims,
    Path(vuln_id): Path<Uuid>,
) -> Result<StatusCode, (StatusCode, Json<ErrorResponse>)> {
    let rows_affected = sqlx::query!(
        "DELETE FROM vulnerabilities WHERE id = $1",
        vuln_id
    )
    .execute(&*pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore durante l'eliminazione: {}", e),
        }),
    ))?
    .rows_affected();

    if rows_affected == 0 {
        return Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Vulnerabilità non trovata".to_string(),
            }),
        ));
    }

    Ok(StatusCode::NO_CONTENT)
}

// ASSIGN TO TEAM - Assegna vulnerabilità a un team
pub async fn assign_to_team(
    Extension(pool): Extension<Arc<PgPool>>,
    _claims: Claims,
    Path(vuln_id): Path<Uuid>,
    Json(assign_request): Json<AssignTeamRequest>,
) -> Result<Json<Vulnerability>, (StatusCode, Json<ErrorResponse>)> {
    let vulnerability = sqlx::query_as!(
        Vulnerability,
        r#"
        UPDATE vulnerabilities
        SET assigned_team_id = $2, updated_at = NOW()
        WHERE id = $1
        RETURNING id, title, description, cvss_score, epss_score, ip_address::text as ip_address,
                  hostname, port, protocol, status as "status: VulnerabilityStatus", 
                  severity as "severity: VulnerabilitySeverity",
                  cve_id, cwe_id, remediation, source, discovered_at, created_at, 
                  updated_at, asset_id, assigned_team_id
        "#,
        vuln_id,
        assign_request.team_id
    )
    .fetch_optional(&*pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore durante l'assegnazione: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Vulnerabilità non trovata".to_string(),
        }),
    ))?;

    Ok(Json(vulnerability))
}