// src/handlers/security.rs
// Security handlers for IP whitelist and user permissions

use axum::{
    extract::{Path, State},
    http::StatusCode,
    Json,
};
use serde::{Serialize, Deserialize};
use uuid::Uuid;
use chrono::{DateTime, Utc};

use crate::auth::Claims;
use crate::models::user::{IpWhitelist, UserPermission};
use crate::state::AppState;

#[derive(Debug, Serialize)]
pub struct ErrorResponse {
    pub error: String,
}

#[derive(Debug, Deserialize)]
pub struct CreateIpWhitelist {
    pub ip_address: String,
    pub cidr_mask: Option<i32>,
    pub description: Option<String>,
    pub user_id: Option<Uuid>,
    pub team_id: Option<Uuid>,
    pub expires_at: Option<DateTime<Utc>>,
}

#[derive(Debug, Deserialize)]
pub struct CreatePermission {
    pub user_id: Uuid,
    pub permission: String,
    pub resource_type: Option<String>,
    pub resource_id: Option<Uuid>,
    pub expires_at: Option<DateTime<Utc>>,
}

// IP Whitelist Management

// Get all IP whitelist entries
pub async fn get_ip_whitelist(
    State(app_state): State<AppState>,
    claims: Claims,
) -> Result<Json<Vec<IpWhitelist>>, StatusCode> {
    // Only admins can view all IP whitelist entries
    if claims.role != "admin" {
        return Err(StatusCode::FORBIDDEN);
    }

    let whitelist = sqlx::query_as!(
        IpWhitelist,
        r#"
        SELECT id, ip_address, cidr_mask, description, user_id, team_id,
               is_active as "is_active!", expires_at, created_by, created_at, updated_at, deleted_at
        FROM ip_whitelist
        WHERE deleted_at IS NULL
        ORDER BY created_at DESC
        "#
    )
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch IP whitelist: {}", e);
        StatusCode::INTERNAL_SERVER_ERROR
    })?;

    Ok(Json(whitelist))
}

// Add IP to whitelist
pub async fn add_ip_whitelist(
    State(app_state): State<AppState>,
    claims: Claims,
    Json(payload): Json<CreateIpWhitelist>,
) -> Result<Json<IpWhitelist>, (StatusCode, Json<ErrorResponse>)> {
    // Only admins can add IP whitelist entries
    if claims.role != "admin" {
        return Err((StatusCode::FORBIDDEN, Json(ErrorResponse {
            error: "Only administrators can manage IP whitelist".to_string(),
        })));
    }

    let created_by = claims.sub.parse::<Uuid>().map_err(|_| {
        (StatusCode::BAD_REQUEST, Json(ErrorResponse {
            error: "Invalid user ID".to_string(),
        }))
    })?;

    let new_entry = sqlx::query_as!(
        IpWhitelist,
        r#"
        INSERT INTO ip_whitelist (ip_address, cidr_mask, description, user_id, team_id, expires_at, created_by)
        VALUES ($1, $2, $3, $4, $5, $6, $7)
        RETURNING id, ip_address, cidr_mask, description, user_id, team_id,
                  is_active as "is_active!", expires_at, created_by, created_at, updated_at, deleted_at
        "#,
        payload.ip_address,
        payload.cidr_mask.unwrap_or(32),
        payload.description,
        payload.user_id,
        payload.team_id,
        payload.expires_at,
        created_by
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to create IP whitelist entry: {}", e);
        (StatusCode::INTERNAL_SERVER_ERROR, Json(ErrorResponse {
            error: "Failed to create IP whitelist entry".to_string(),
        }))
    })?;

    Ok(Json(new_entry))
}

// Remove IP from whitelist
pub async fn remove_ip_whitelist(
    State(app_state): State<AppState>,
    claims: Claims,
    Path(whitelist_id): Path<Uuid>,
) -> Result<StatusCode, (StatusCode, Json<ErrorResponse>)> {
    // Only admins can remove IP whitelist entries
    if claims.role != "admin" {
        return Err((StatusCode::FORBIDDEN, Json(ErrorResponse {
            error: "Only administrators can manage IP whitelist".to_string(),
        })));
    }

    let result = sqlx::query!(
        "UPDATE ip_whitelist SET deleted_at = NOW() WHERE id = $1 AND deleted_at IS NULL",
        whitelist_id
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to delete IP whitelist entry: {}", e);
        (StatusCode::INTERNAL_SERVER_ERROR, Json(ErrorResponse {
            error: "Failed to delete IP whitelist entry".to_string(),
        }))
    })?;

    if result.rows_affected() == 0 {
        return Err((StatusCode::NOT_FOUND, Json(ErrorResponse {
            error: "IP whitelist entry not found".to_string(),
        })));
    }

    Ok(StatusCode::NO_CONTENT)
}

// User Permissions Management

// Get user permissions
pub async fn get_user_permissions(
    State(app_state): State<AppState>,
    claims: Claims,
    Path(user_id): Path<Uuid>,
) -> Result<Json<Vec<UserPermission>>, StatusCode> {
    // Only admins can view user permissions
    if claims.role != "admin" {
        return Err(StatusCode::FORBIDDEN);
    }

    let permissions = sqlx::query_as!(
        UserPermission,
        r#"
        SELECT id, user_id, permission, resource_type, resource_id,
               is_active as "is_active!", expires_at, granted_by, granted_at,
               revoked_at, revoked_by, revoked_reason, created_at, updated_at
        FROM user_permissions
        WHERE user_id = $1 AND is_active = true
        ORDER BY granted_at DESC
        "#,
        user_id
    )
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch user permissions: {}", e);
        StatusCode::INTERNAL_SERVER_ERROR
    })?;

    Ok(Json(permissions))
}

// Grant permission to user
pub async fn grant_user_permission(
    State(app_state): State<AppState>,
    claims: Claims,
    Json(payload): Json<CreatePermission>,
) -> Result<Json<UserPermission>, (StatusCode, Json<ErrorResponse>)> {
    // Only admins can grant permissions
    if claims.role != "admin" {
        return Err((StatusCode::FORBIDDEN, Json(ErrorResponse {
            error: "Only administrators can grant permissions".to_string(),
        })));
    }

    let granted_by = claims.sub.parse::<Uuid>().map_err(|_| {
        (StatusCode::BAD_REQUEST, Json(ErrorResponse {
            error: "Invalid user ID".to_string(),
        }))
    })?;

    let new_permission = sqlx::query_as!(
        UserPermission,
        r#"
        INSERT INTO user_permissions (user_id, permission, resource_type, resource_id, expires_at, granted_by)
        VALUES ($1, $2, $3, $4, $5, $6)
        RETURNING id, user_id, permission, resource_type, resource_id,
                  is_active as "is_active!", expires_at, granted_by, granted_at,
                  revoked_at, revoked_by, revoked_reason, created_at, updated_at
        "#,
        payload.user_id,
        payload.permission,
        payload.resource_type,
        payload.resource_id,
        payload.expires_at,
        granted_by
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to grant permission: {}", e);
        (StatusCode::INTERNAL_SERVER_ERROR, Json(ErrorResponse {
            error: "Failed to grant permission".to_string(),
        }))
    })?;

    Ok(Json(new_permission))
}

// Revoke user permission
pub async fn revoke_user_permission(
    State(app_state): State<AppState>,
    claims: Claims,
    Path(permission_id): Path<Uuid>,
) -> Result<StatusCode, (StatusCode, Json<ErrorResponse>)> {
    // Only admins can revoke permissions
    if claims.role != "admin" {
        return Err((StatusCode::FORBIDDEN, Json(ErrorResponse {
            error: "Only administrators can revoke permissions".to_string(),
        })));
    }

    let revoked_by = claims.sub.parse::<Uuid>().map_err(|_| {
        (StatusCode::BAD_REQUEST, Json(ErrorResponse {
            error: "Invalid user ID".to_string(),
        }))
    })?;

    let result = sqlx::query!(
        r#"
        UPDATE user_permissions
        SET is_active = false, revoked_at = NOW(), revoked_by = $1,
            revoked_reason = 'Revoked by administrator', updated_at = NOW()
        WHERE id = $2 AND is_active = true
        "#,
        revoked_by,
        permission_id
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to revoke permission: {}", e);
        (StatusCode::INTERNAL_SERVER_ERROR, Json(ErrorResponse {
            error: "Failed to revoke permission".to_string(),
        }))
    })?;

    if result.rows_affected() == 0 {
        return Err((StatusCode::NOT_FOUND, Json(ErrorResponse {
            error: "Permission not found or already revoked".to_string(),
        })));
    }

    Ok(StatusCode::NO_CONTENT)
}
