// src/handlers/compliance_reports.rs
// Compliance reporting (PCI-DSS, ISO 27001, SOC2, HIPAA)

use axum::{
    extract::{Path, State},
    http::StatusCode,
    Json,
};
use uuid::Uuid;
use chrono::Utc;
use serde_json::json;

use crate::auth::Claims;
use crate::state::AppState;
use crate::models::compliance::*;

/// Generate compliance report for a framework
pub async fn generate_compliance_report(
    State(app_state): State<AppState>,
    Claims { sub, .. }: Claims,
    Json(payload): Json<GenerateComplianceReportRequest>,
) -> Result<Json<ComplianceReportResponse>, (StatusCode, Json<serde_json::Value>)> {
    let user_id = Uuid::parse_str(&sub).unwrap_or(Uuid::nil());
    let pool = &*app_state.pool;

    // Get framework definition
    let framework_data: (serde_json::Value, String) = sqlx::query_as(
        "SELECT controls, version FROM compliance_frameworks WHERE name = $1 AND is_active = true"
    )
    .bind(&payload.framework)
    .fetch_one(pool)
    .await
    .map_err(|_| (
        StatusCode::NOT_FOUND,
        Json(json!({"error": "Framework not found"}))
    ))?;

    let controls_array = framework_data.0.as_array()
        .ok_or_else(|| (StatusCode::INTERNAL_SERVER_ERROR, Json(json!({"error": "Invalid framework controls"}))))?;

    let framework_version = framework_data.1;

    // Build scope query
    let scope = payload.scope.clone().unwrap_or_default();
    let scope_json = serde_json::to_value(&scope).unwrap_or(json!([]));

    // For each control, check if vulnerabilities violate it
    let mut findings = Vec::new();
    let mut passed_controls = 0;
    let mut failed_controls = 0;
    let mut critical_findings = 0;
    let mut high_findings = 0;
    let mut medium_findings = 0;
    let mut low_findings = 0;

    for control_obj in controls_array {
        let control_id = control_obj.get("id")
            .and_then(|v| v.as_str())
            .unwrap_or("unknown");
        
        let control_name = control_obj.get("name")
            .and_then(|v| v.as_str())
            .unwrap_or("Unknown control");

        let control_severity = control_obj.get("severity")
            .and_then(|v| v.as_str())
            .unwrap_or("medium");

        let cwe_ids: Vec<String> = control_obj.get("cwe_ids")
            .and_then(|v| v.as_array())
            .map(|arr| arr.iter()
                .filter_map(|v| v.as_str().map(String::from))
                .collect())
            .unwrap_or_default();

        // Query vulnerabilities matching this control's CWEs
        let matching_vulns: Vec<(Uuid, String)> = if cwe_ids.is_empty() {
            Vec::new()
        } else {
            sqlx::query_as(
                "SELECT id, severity FROM vulnerabilities 
                 WHERE cwe_id = ANY($1) AND status != 'resolved' 
                 AND ($2::uuid[] IS NULL OR asset_id = ANY($2))"
            )
            .bind(&cwe_ids)
            .bind(if scope.is_empty() { None } else { Some(scope.clone()) })
            .fetch_all(pool)
            .await
            .unwrap_or_default()
        };

        let vuln_count = matching_vulns.len() as i32;
        let status = if vuln_count == 0 { "Compliant" } else { "Non-Compliant" };

        // Calculate severity counts
        for (_, severity) in &matching_vulns {
            match severity.as_str() {
                "critical" => critical_findings += 1,
                "high" => high_findings += 1,
                "medium" => medium_findings += 1,
                _ => {}
            }
        }

        if vuln_count == 0 {
            passed_controls += 1;
        } else {
            failed_controls += 1;
        }

        let vuln_ids: Vec<Uuid> = matching_vulns.iter().map(|(id, _)| *id).collect();

        findings.push(ComplianceFinding {
            id: Uuid::new_v4(),
            report_id: Uuid::new_v4(),
            control_id: control_id.to_string(),
            control_name: control_name.to_string(),
            control_description: control_obj.get("description").and_then(|v| v.as_str()).map(String::from),
            status: status.to_string(),
            vulnerabilities: vuln_count,
            vulnerability_ids: vuln_ids,
            severity: control_severity.to_string(),
            evidence: None,
            recommendation: None,
            created_at: Utc::now(),
        });
    }

    let total_controls = controls_array.len() as i32;
    let compliance_score = if total_controls > 0 {
        (passed_controls as f64 / total_controls as f64) * 100.0
    } else {
        0.0
    };

    let report = ComplianceReport {
        id: Uuid::new_v4(),
        framework: payload.framework.clone(),
        version: Some(framework_version),
        status: "completed".to_string(),
        scope: scope_json,
        score: compliance_score,
        total_controls,
        passed_controls,
        failed_controls,
        findings: findings.len() as i32,
        critical_findings,
        high_findings,
        medium_findings,
        low_findings,
        report_data: json!({
            "generated_at": Utc::now(),
            "framework": payload.framework,
        }),
        generated_by: user_id,
        generated_at: Utc::now(),
        valid_from: Some(Utc::now()),
        valid_to: payload.scope.as_ref().map(|_| Utc::now() + chrono::Duration::days(90)),
        created_at: Utc::now(),
        updated_at: Utc::now(),
    };

    let score_breakdown = ComplianceScoreBreakdown {
        total_controls,
        passed_controls,
        failed_controls,
        compliance_percentage: compliance_score as f32,
        critical_violations: critical_findings,
        high_violations: high_findings,
        medium_violations: medium_findings,
    };

    Ok(Json(ComplianceReportResponse {
        report,
        findings,
        score_breakdown,
    }))
}

/// List compliance reports
pub async fn list_compliance_reports(
    _state: State<AppState>,
    _claims: Claims,
) -> Result<Json<Vec<ComplianceReport>>, (StatusCode, Json<serde_json::Value>)> {
    Ok(Json(vec![]))
}
