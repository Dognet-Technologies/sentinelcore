// src/handlers/workload.rs
// User and team workload tracking - Priority 5

use axum::{
    extract::{Path, State},
    http::StatusCode,
    Json,
};
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use crate::auth::Claims;
use crate::state::AppState;

#[derive(Debug, Serialize)]
pub struct ErrorResponse {
    pub error: String,
}

#[derive(Debug, Serialize)]
pub struct UserWorkload {
    pub user_id: Option<Uuid>,
    pub username: Option<String>,
    pub email: Option<String>,
    pub role: String,
    pub assigned_devices: i64,
    pub total_vulnerabilities: i64,
    pub open_vulnerabilities: i64,
    pub in_progress_vulnerabilities: i64,
    pub resolved_vulnerabilities: i64,
    pub closed_vulnerabilities: i64,
    pub critical_count: i64,
    pub high_count: i64,
    pub medium_count: i64,
    pub low_count: i64,
    pub total_tasks: i64,
    pub completed_tasks: i64,
    pub failed_tasks: i64,
    pub avg_resolution_hours: Option<f64>,
    pub assigned_plans: i64,
    pub completed_plan_devices: i64,
    pub last_activity: Option<DateTime<Utc>>,
}

#[derive(Debug, Serialize)]
pub struct TeamWorkload {
    pub team_id: Option<Uuid>,
    pub team_name: Option<String>,
    pub contact_email: Option<String>,
    pub assigned_devices: i64,
    pub total_vulnerabilities: i64,
    pub open_vulnerabilities: i64,
    pub in_progress_vulnerabilities: i64,
    pub resolved_vulnerabilities: i64,
    pub critical_count: i64,
    pub high_count: i64,
    pub medium_count: i64,
    pub low_count: i64,
    pub total_plans: i64,
    pub active_plans: i64,
    pub completed_plans: i64,
    pub team_members: i64,
    pub last_activity: Option<DateTime<Utc>>,
}

/// Get current user's workload
pub async fn get_my_workload(
    State(app_state): State<AppState>,
    claims: Claims,
) -> Result<Json<UserWorkload>, (StatusCode, Json<ErrorResponse>)> {
    let user_id = claims.sub.parse::<Uuid>().map_err(|_| {
        (
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: "Invalid user ID".to_string(),
            }),
        )
    })?;

    get_user_workload_impl(&app_state, user_id).await
}

/// Get specific user's workload (admin/team leader)
pub async fn get_user_workload(
    State(app_state): State<AppState>,
    Path(user_id): Path<Uuid>,
) -> Result<Json<UserWorkload>, (StatusCode, Json<ErrorResponse>)> {
    get_user_workload_impl(&app_state, user_id).await
}

async fn get_user_workload_impl(
    app_state: &AppState,
    user_id: Uuid,
) -> Result<Json<UserWorkload>, (StatusCode, Json<ErrorResponse>)> {
    let pool = &*app_state.pool;

    let workload = sqlx::query!(
        r#"
        SELECT
            user_id,
            username,
            email,
            role::text,
            assigned_devices,
            total_vulnerabilities,
            open_vulnerabilities,
            in_progress_vulnerabilities,
            resolved_vulnerabilities,
            closed_vulnerabilities,
            critical_count,
            high_count,
            medium_count,
            low_count,
            total_tasks,
            completed_tasks,
            failed_tasks,
            avg_resolution_hours,
            assigned_plans,
            completed_plan_devices,
            last_activity
        FROM user_remediation_stats
        WHERE user_id = $1
        "#,
        user_id
    )
    .fetch_optional(pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch user workload: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to fetch user workload".to_string(),
            }),
        )
    })?
    .ok_or_else(|| {
        (
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "User not found".to_string(),
            }),
        )
    })?;

    Ok(Json(UserWorkload {
        user_id: workload.user_id,
        username: workload.username,
        email: workload.email,
        role: workload.role.unwrap_or_else(|| "user".to_string()),
        assigned_devices: workload.assigned_devices.unwrap_or(0),
        total_vulnerabilities: workload.total_vulnerabilities.unwrap_or(0),
        open_vulnerabilities: workload.open_vulnerabilities.unwrap_or(0),
        in_progress_vulnerabilities: workload.in_progress_vulnerabilities.unwrap_or(0),
        resolved_vulnerabilities: workload.resolved_vulnerabilities.unwrap_or(0),
        closed_vulnerabilities: workload.closed_vulnerabilities.unwrap_or(0),
        critical_count: workload.critical_count.unwrap_or(0),
        high_count: workload.high_count.unwrap_or(0),
        medium_count: workload.medium_count.unwrap_or(0),
        low_count: workload.low_count.unwrap_or(0),
        total_tasks: workload.total_tasks.unwrap_or(0),
        completed_tasks: workload.completed_tasks.unwrap_or(0),
        failed_tasks: workload.failed_tasks.unwrap_or(0),
        avg_resolution_hours: workload.avg_resolution_hours.and_then(|bd| bd.to_f64()),
        assigned_plans: workload.assigned_plans.unwrap_or(0),
        completed_plan_devices: workload.completed_plan_devices.unwrap_or(0),
        last_activity: workload.last_activity,
    }))
}

/// Get all users' workload (admin)
pub async fn list_users_workload(
    State(app_state): State<AppState>,
) -> Result<Json<Vec<UserWorkload>>, (StatusCode, Json<ErrorResponse>)> {
    let pool = &*app_state.pool;

    let workloads = sqlx::query!(
        r#"
        SELECT
            user_id,
            username,
            email,
            role::text,
            assigned_devices,
            total_vulnerabilities,
            open_vulnerabilities,
            in_progress_vulnerabilities,
            resolved_vulnerabilities,
            closed_vulnerabilities,
            critical_count,
            high_count,
            medium_count,
            low_count,
            total_tasks,
            completed_tasks,
            failed_tasks,
            avg_resolution_hours,
            assigned_plans,
            completed_plan_devices,
            last_activity
        FROM user_remediation_stats
        ORDER BY total_vulnerabilities DESC, username ASC
        "#
    )
    .fetch_all(pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch users workload: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to fetch users workload".to_string(),
            }),
        )
    })?;

    let result = workloads
        .into_iter()
        .map(|w| UserWorkload {
            user_id: w.user_id,
            username: w.username,
            email: w.email,
            role: w.role.unwrap_or_else(|| "user".to_string()),
            assigned_devices: w.assigned_devices.unwrap_or(0),
            total_vulnerabilities: w.total_vulnerabilities.unwrap_or(0),
            open_vulnerabilities: w.open_vulnerabilities.unwrap_or(0),
            in_progress_vulnerabilities: w.in_progress_vulnerabilities.unwrap_or(0),
            resolved_vulnerabilities: w.resolved_vulnerabilities.unwrap_or(0),
            closed_vulnerabilities: w.closed_vulnerabilities.unwrap_or(0),
            critical_count: w.critical_count.unwrap_or(0),
            high_count: w.high_count.unwrap_or(0),
            medium_count: w.medium_count.unwrap_or(0),
            low_count: w.low_count.unwrap_or(0),
            total_tasks: w.total_tasks.unwrap_or(0),
            completed_tasks: w.completed_tasks.unwrap_or(0),
            failed_tasks: w.failed_tasks.unwrap_or(0),
            avg_resolution_hours: w.avg_resolution_hours.and_then(|bd| bd.to_f64()),
            assigned_plans: w.assigned_plans.unwrap_or(0),
            completed_plan_devices: w.completed_plan_devices.unwrap_or(0),
            last_activity: w.last_activity,
        })
        .collect();

    Ok(Json(result))
}

/// Get team workload
pub async fn get_team_workload(
    State(app_state): State<AppState>,
    Path(team_id): Path<Uuid>,
) -> Result<Json<TeamWorkload>, (StatusCode, Json<ErrorResponse>)> {
    let pool = &*app_state.pool;

    let workload = sqlx::query!(
        r#"
        SELECT
            team_id,
            team_name,
            contact_email,
            assigned_devices,
            total_vulnerabilities,
            open_vulnerabilities,
            in_progress_vulnerabilities,
            resolved_vulnerabilities,
            critical_count,
            high_count,
            medium_count,
            low_count,
            total_plans,
            active_plans,
            completed_plans,
            team_members,
            last_activity
        FROM team_remediation_stats
        WHERE team_id = $1
        "#,
        team_id
    )
    .fetch_optional(pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch team workload: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to fetch team workload".to_string(),
            }),
        )
    })?
    .ok_or_else(|| {
        (
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Team not found".to_string(),
            }),
        )
    })?;

    Ok(Json(TeamWorkload {
        team_id: workload.team_id,
        team_name: workload.team_name,
        contact_email: workload.contact_email,
        assigned_devices: workload.assigned_devices.unwrap_or(0),
        total_vulnerabilities: workload.total_vulnerabilities.unwrap_or(0),
        open_vulnerabilities: workload.open_vulnerabilities.unwrap_or(0),
        in_progress_vulnerabilities: workload.in_progress_vulnerabilities.unwrap_or(0),
        resolved_vulnerabilities: workload.resolved_vulnerabilities.unwrap_or(0),
        critical_count: workload.critical_count.unwrap_or(0),
        high_count: workload.high_count.unwrap_or(0),
        medium_count: workload.medium_count.unwrap_or(0),
        low_count: workload.low_count.unwrap_or(0),
        total_plans: workload.total_plans.unwrap_or(0),
        active_plans: workload.active_plans.unwrap_or(0),
        completed_plans: workload.completed_plans.unwrap_or(0),
        team_members: workload.team_members.unwrap_or(0),
        last_activity: workload.last_activity,
    }))
}

/// Get all teams' workload
pub async fn list_teams_workload(
    State(app_state): State<AppState>,
) -> Result<Json<Vec<TeamWorkload>>, (StatusCode, Json<ErrorResponse>)> {
    let pool = &*app_state.pool;

    let workloads = sqlx::query!(
        r#"
        SELECT
            team_id,
            team_name,
            contact_email,
            assigned_devices,
            total_vulnerabilities,
            open_vulnerabilities,
            in_progress_vulnerabilities,
            resolved_vulnerabilities,
            critical_count,
            high_count,
            medium_count,
            low_count,
            total_plans,
            active_plans,
            completed_plans,
            team_members,
            last_activity
        FROM team_remediation_stats
        ORDER BY total_vulnerabilities DESC, team_name ASC
        "#
    )
    .fetch_all(pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch teams workload: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to fetch teams workload".to_string(),
            }),
        )
    })?;

    let result = workloads
        .into_iter()
        .map(|w| TeamWorkload {
            team_id: w.team_id,
            team_name: w.team_name,
            contact_email: w.contact_email,
            assigned_devices: w.assigned_devices.unwrap_or(0),
            total_vulnerabilities: w.total_vulnerabilities.unwrap_or(0),
            open_vulnerabilities: w.open_vulnerabilities.unwrap_or(0),
            in_progress_vulnerabilities: w.in_progress_vulnerabilities.unwrap_or(0),
            resolved_vulnerabilities: w.resolved_vulnerabilities.unwrap_or(0),
            critical_count: w.critical_count.unwrap_or(0),
            high_count: w.high_count.unwrap_or(0),
            medium_count: w.medium_count.unwrap_or(0),
            low_count: w.low_count.unwrap_or(0),
            total_plans: w.total_plans.unwrap_or(0),
            active_plans: w.active_plans.unwrap_or(0),
            completed_plans: w.completed_plans.unwrap_or(0),
            team_members: w.team_members.unwrap_or(0),
            last_activity: w.last_activity,
        })
        .collect();

    Ok(Json(result))
}
