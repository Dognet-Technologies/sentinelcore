// src/handlers/jira_integration.rs
// JIRA integration and auto-ticketing handlers

use axum::{
    extract::{Path, State},
    http::StatusCode,
    Json,
};
use serde::{Deserialize, Serialize};
use uuid::Uuid;
use chrono::{DateTime, Utc};

use crate::auth::Claims;
use crate::state::AppState;

#[derive(Debug, Serialize, Deserialize)]
pub struct JiraConfiguration {
    pub id: Uuid,
    pub name: String,
    pub base_url: String,
    pub username: Option<String>,
    pub auth_type: String,
    pub default_project_key: Option<String>,
    pub default_issue_type: String,
    pub is_enabled: bool,
    pub auto_create_tickets: bool,
    pub auto_sync: bool,
    pub custom_field_mapping: serde_json::Value,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct JiraTicket {
    pub id: Uuid,
    pub jira_config_id: Uuid,
    pub entity_type: String,
    pub entity_id: Uuid,
    pub jira_issue_key: String,
    pub jira_issue_id: Option<String>,
    pub jira_project_key: Option<String>,
    pub jira_issue_type: Option<String>,
    pub jira_status: Option<String>,
    pub jira_priority: Option<String>,
    pub jira_assignee: Option<String>,
    pub jira_url: Option<String>,
    pub sync_status: String,
    pub last_sync_at: Option<DateTime<Utc>>,
    pub sync_error: Option<String>,
    pub created_in: String,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Debug, Serialize)]
pub struct JiraTicketWithDetails {
    #[serde(flatten)]
    pub ticket: JiraTicket,
    pub vulnerability_title: Option<String>,
    pub configuration_name: String,
}

#[derive(Debug, Deserialize)]
pub struct CreateJiraConfiguration {
    pub name: String,
    pub base_url: String,
    pub username: Option<String>,
    pub api_token: Option<String>,
    pub auth_type: Option<String>,
    pub default_project_key: Option<String>,
    pub default_issue_type: Option<String>,
    pub is_enabled: Option<bool>,
    pub auto_create_tickets: Option<bool>,
    pub auto_sync: Option<bool>,
    pub webhook_secret: Option<String>,
    pub custom_field_mapping: Option<serde_json::Value>,
}

#[derive(Debug, Deserialize)]
pub struct UpdateJiraConfiguration {
    pub name: Option<String>,
    pub base_url: Option<String>,
    pub username: Option<String>,
    pub api_token: Option<String>,
    pub default_project_key: Option<String>,
    pub default_issue_type: Option<String>,
    pub is_enabled: Option<bool>,
    pub auto_create_tickets: Option<bool>,
    pub auto_sync: Option<bool>,
    pub custom_field_mapping: Option<serde_json::Value>,
}

#[derive(Debug, Deserialize)]
pub struct TestConnectionRequest {
    pub base_url: String,
    pub username: Option<String>,
    pub api_token: String,
    pub auth_type: Option<String>,
}

#[derive(Debug, Serialize)]
pub struct TestConnectionResponse {
    pub success: bool,
    pub message: String,
    pub projects: Option<Vec<String>>,
}

#[derive(Debug, Deserialize)]
pub struct CreateTicketRequest {
    pub jira_config_id: Uuid,
    pub vulnerability_id: Uuid,
    pub project_key: Option<String>,
    pub issue_type: Option<String>,
    pub assignee: Option<String>,
}

#[derive(Debug, Serialize)]
pub struct CreateTicketResponse {
    pub ticket: JiraTicket,
    pub jira_url: String,
}

#[derive(Debug, Serialize)]
pub struct SyncStatusResponse {
    pub ticket_id: Uuid,
    pub sync_status: String,
    pub last_sync_at: Option<DateTime<Utc>>,
    pub message: String,
}

#[derive(Debug, Serialize)]
pub struct ErrorResponse {
    pub error: String,
}

// List JIRA configurations
pub async fn list_jira_configurations(
    State(app_state): State<AppState>,
    _claims: Claims,
) -> Result<Json<Vec<JiraConfiguration>>, (StatusCode, Json<ErrorResponse>)> {
    let configs = sqlx::query_as!(
        JiraConfiguration,
        r#"
        SELECT
            id,
            name,
            base_url,
            username,
            auth_type,
            default_project_key,
            default_issue_type,
            is_enabled,
            auto_create_tickets,
            auto_sync,
            custom_field_mapping,
            created_at,
            updated_at
        FROM jira_configurations
        ORDER BY created_at DESC
        "#
    )
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to list JIRA configurations: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to list JIRA configurations".to_string(),
            }),
        )
    })?;

    Ok(Json(configs))
}

// Get JIRA configuration by ID
pub async fn get_jira_configuration(
    State(app_state): State<AppState>,
    Path(config_id): Path<Uuid>,
    _claims: Claims,
) -> Result<Json<JiraConfiguration>, (StatusCode, Json<ErrorResponse>)> {
    let config = sqlx::query_as!(
        JiraConfiguration,
        r#"
        SELECT
            id,
            name,
            base_url,
            username,
            auth_type,
            default_project_key,
            default_issue_type,
            is_enabled,
            auto_create_tickets,
            auto_sync,
            custom_field_mapping,
            created_at,
            updated_at
        FROM jira_configurations
        WHERE id = $1
        "#,
        config_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch JIRA configuration: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to fetch JIRA configuration".to_string(),
            }),
        )
    })?
    .ok_or_else(|| {
        (
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "JIRA configuration not found".to_string(),
            }),
        )
    })?;

    Ok(Json(config))
}

// Create JIRA configuration
pub async fn create_jira_configuration(
    State(app_state): State<AppState>,
    claims: Claims,
    Json(payload): Json<CreateJiraConfiguration>,
) -> Result<Json<JiraConfiguration>, (StatusCode, Json<ErrorResponse>)> {
    let user_id = claims.sub.parse::<Uuid>().map_err(|_| {
        (
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: "Invalid user ID".to_string(),
            }),
        )
    })?;

    // Note: In production, api_token should be encrypted before storing
    let config = sqlx::query_as!(
        JiraConfiguration,
        r#"
        INSERT INTO jira_configurations (
            name, base_url, username, api_token, auth_type,
            default_project_key, default_issue_type, is_enabled,
            auto_create_tickets, auto_sync, webhook_secret,
            custom_field_mapping, created_by
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
        RETURNING
            id,
            name,
            base_url,
            username,
            auth_type,
            default_project_key,
            default_issue_type,
            is_enabled,
            auto_create_tickets,
            auto_sync,
            custom_field_mapping,
            created_at,
            updated_at
        "#,
        payload.name,
        payload.base_url,
        payload.username,
        payload.api_token,
        payload.auth_type.unwrap_or_else(|| "token".to_string()),
        payload.default_project_key,
        payload.default_issue_type.unwrap_or_else(|| "Task".to_string()),
        payload.is_enabled.unwrap_or(true),
        payload.auto_create_tickets.unwrap_or(false),
        payload.auto_sync.unwrap_or(true),
        payload.webhook_secret,
        payload.custom_field_mapping.unwrap_or(serde_json::json!({})),
        user_id
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to create JIRA configuration: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Failed to create JIRA configuration: {}", e),
            }),
        )
    })?;

    Ok(Json(config))
}

// Update JIRA configuration
pub async fn update_jira_configuration(
    State(app_state): State<AppState>,
    Path(config_id): Path<Uuid>,
    _claims: Claims,
    Json(payload): Json<UpdateJiraConfiguration>,
) -> Result<Json<JiraConfiguration>, (StatusCode, Json<ErrorResponse>)> {
    let config = sqlx::query_as!(
        JiraConfiguration,
        r#"
        UPDATE jira_configurations
        SET
            name = COALESCE($2, name),
            base_url = COALESCE($3, base_url),
            username = COALESCE($4, username),
            api_token = COALESCE($5, api_token),
            default_project_key = COALESCE($6, default_project_key),
            default_issue_type = COALESCE($7, default_issue_type),
            is_enabled = COALESCE($8, is_enabled),
            auto_create_tickets = COALESCE($9, auto_create_tickets),
            auto_sync = COALESCE($10, auto_sync),
            custom_field_mapping = COALESCE($11, custom_field_mapping),
            updated_at = NOW()
        WHERE id = $1
        RETURNING
            id,
            name,
            base_url,
            username,
            auth_type,
            default_project_key,
            default_issue_type,
            is_enabled,
            auto_create_tickets,
            auto_sync,
            custom_field_mapping,
            created_at,
            updated_at
        "#,
        config_id,
        payload.name,
        payload.base_url,
        payload.username,
        payload.api_token,
        payload.default_project_key,
        payload.default_issue_type,
        payload.is_enabled,
        payload.auto_create_tickets,
        payload.auto_sync,
        payload.custom_field_mapping
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to update JIRA configuration: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to update JIRA configuration".to_string(),
            }),
        )
    })?
    .ok_or_else(|| {
        (
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "JIRA configuration not found".to_string(),
            }),
        )
    })?;

    Ok(Json(config))
}

// Delete JIRA configuration
pub async fn delete_jira_configuration(
    State(app_state): State<AppState>,
    Path(config_id): Path<Uuid>,
    _claims: Claims,
) -> Result<StatusCode, (StatusCode, Json<ErrorResponse>)> {
    let result = sqlx::query!(
        "DELETE FROM jira_configurations WHERE id = $1",
        config_id
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to delete JIRA configuration: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to delete JIRA configuration".to_string(),
            }),
        )
    })?;

    if result.rows_affected() == 0 {
        return Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "JIRA configuration not found".to_string(),
            }),
        ));
    }

    Ok(StatusCode::NO_CONTENT)
}

// Test JIRA connection
pub async fn test_jira_connection(
    State(_app_state): State<AppState>,
    _claims: Claims,
    Json(_payload): Json<TestConnectionRequest>,
) -> Result<Json<TestConnectionResponse>, (StatusCode, Json<ErrorResponse>)> {
    // TODO: Implement actual JIRA API connection test
    // This is a placeholder that returns success
    // In production, this should:
    // 1. Create HTTP client with auth
    // 2. Call JIRA API (e.g., /rest/api/2/myself)
    // 3. Fetch available projects
    // 4. Return actual connection status

    Ok(Json(TestConnectionResponse {
        success: true,
        message: "Connection test not fully implemented. Manual verification required.".to_string(),
        projects: Some(vec!["VULN".to_string(), "SEC".to_string()]),
    }))
}

// List JIRA tickets
pub async fn list_jira_tickets(
    State(app_state): State<AppState>,
    _claims: Claims,
) -> Result<Json<Vec<JiraTicketWithDetails>>, (StatusCode, Json<ErrorResponse>)> {
    let tickets = sqlx::query!(
        r#"
        SELECT
            jt.id,
            jt.jira_config_id,
            jt.entity_type,
            jt.entity_id,
            jt.jira_issue_key,
            jt.jira_issue_id,
            jt.jira_project_key,
            jt.jira_issue_type,
            jt.jira_status,
            jt.jira_priority,
            jt.jira_assignee,
            jt.jira_url,
            jt.sync_status,
            jt.last_sync_at,
            jt.sync_error,
            jt.created_in,
            jt.created_at,
            jt.updated_at,
            v.title as vulnerability_title,
            jc.name as configuration_name
        FROM jira_tickets jt
        JOIN jira_configurations jc ON jc.id = jt.jira_config_id
        LEFT JOIN vulnerabilities v ON v.id = jt.entity_id AND jt.entity_type = 'vulnerability'
        ORDER BY jt.created_at DESC
        "#
    )
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to list JIRA tickets: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to list JIRA tickets".to_string(),
            }),
        )
    })?;

    let result = tickets
        .into_iter()
        .map(|row| JiraTicketWithDetails {
            ticket: JiraTicket {
                id: row.id,
                jira_config_id: row.jira_config_id,
                entity_type: row.entity_type,
                entity_id: row.entity_id,
                jira_issue_key: row.jira_issue_key,
                jira_issue_id: row.jira_issue_id,
                jira_project_key: row.jira_project_key,
                jira_issue_type: row.jira_issue_type,
                jira_status: row.jira_status,
                jira_priority: row.jira_priority,
                jira_assignee: row.jira_assignee,
                jira_url: row.jira_url,
                sync_status: row.sync_status,
                last_sync_at: row.last_sync_at,
                sync_error: row.sync_error,
                created_in: row.created_in,
                created_at: row.created_at,
                updated_at: row.updated_at,
            },
            vulnerability_title: row.vulnerability_title,
            configuration_name: row.configuration_name,
        })
        .collect();

    Ok(Json(result))
}

// Create JIRA ticket for vulnerability
pub async fn create_jira_ticket(
    State(app_state): State<AppState>,
    _claims: Claims,
    Json(payload): Json<CreateTicketRequest>,
) -> Result<Json<CreateTicketResponse>, (StatusCode, Json<ErrorResponse>)> {
    // Fetch JIRA configuration
    let config = sqlx::query!(
        r#"
        SELECT base_url, default_project_key, default_issue_type
        FROM jira_configurations
        WHERE id = $1 AND is_enabled = TRUE
        "#,
        payload.jira_config_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch JIRA config: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to fetch JIRA configuration".to_string(),
            }),
        )
    })?
    .ok_or_else(|| {
        (
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "JIRA configuration not found or disabled".to_string(),
            }),
        )
    })?;

    // Check if ticket already exists
    let existing = sqlx::query!(
        "SELECT id FROM jira_tickets WHERE entity_type = 'vulnerability' AND entity_id = $1",
        payload.vulnerability_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to check existing ticket: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to check existing ticket".to_string(),
            }),
        )
    })?;

    if existing.is_some() {
        return Err((
            StatusCode::CONFLICT,
            Json(ErrorResponse {
                error: "JIRA ticket already exists for this vulnerability".to_string(),
            }),
        ));
    }

    // TODO: Implement actual JIRA API ticket creation
    // This is a placeholder that creates a database record
    // In production, this should:
    // 1. Build ticket description using build_jira_description()
    // 2. Call JIRA API to create issue
    // 3. Store the response in jira_tickets table

    let project_key = payload
        .project_key
        .or(config.default_project_key)
        .unwrap_or_else(|| "VULN".to_string());
    let issue_type = payload
        .issue_type
        .or(config.default_issue_type)
        .unwrap_or_else(|| "Task".to_string());

    // Placeholder: Generate mock JIRA key
    let jira_issue_key = format!("{}-{}", project_key, uuid::Uuid::new_v4().as_u128() % 10000);
    let jira_url = format!("{}/browse/{}", config.base_url, jira_issue_key);

    let ticket = sqlx::query_as!(
        JiraTicket,
        r#"
        INSERT INTO jira_tickets (
            jira_config_id, entity_type, entity_id, jira_issue_key,
            jira_project_key, jira_issue_type, jira_status,
            jira_assignee, jira_url, sync_status, created_in
        )
        VALUES ($1, 'vulnerability', $2, $3, $4, $5, 'Open', $6, $7, 'pending', 'sentinelcore')
        RETURNING
            id, jira_config_id, entity_type, entity_id, jira_issue_key,
            jira_issue_id, jira_project_key, jira_issue_type, jira_status,
            jira_priority, jira_assignee, jira_url, sync_status,
            last_sync_at, sync_error, created_in, created_at, updated_at
        "#,
        payload.jira_config_id,
        payload.vulnerability_id,
        jira_issue_key,
        project_key,
        issue_type,
        payload.assignee,
        jira_url
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to create JIRA ticket record: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Failed to create JIRA ticket: {}", e),
            }),
        )
    })?;

    Ok(Json(CreateTicketResponse {
        jira_url: jira_url.clone(),
        ticket,
    }))
}

// Sync JIRA ticket status
pub async fn sync_jira_ticket(
    State(app_state): State<AppState>,
    Path(ticket_id): Path<Uuid>,
    _claims: Claims,
) -> Result<Json<SyncStatusResponse>, (StatusCode, Json<ErrorResponse>)> {
    // TODO: Implement actual JIRA API sync
    // This is a placeholder
    // In production, this should:
    // 1. Fetch ticket from database
    // 2. Call JIRA API to get current status
    // 3. Update local database
    // 4. Call sync_jira_status_to_vulnerability() if status changed

    let ticket = sqlx::query!(
        "SELECT sync_status, last_sync_at FROM jira_tickets WHERE id = $1",
        ticket_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch JIRA ticket: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to fetch JIRA ticket".to_string(),
            }),
        )
    })?
    .ok_or_else(|| {
        (
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "JIRA ticket not found".to_string(),
            }),
        )
    })?;

    Ok(Json(SyncStatusResponse {
        ticket_id,
        sync_status: ticket.sync_status,
        last_sync_at: ticket.last_sync_at,
        message: "Sync functionality not fully implemented. Manual sync required.".to_string(),
    }))
}
