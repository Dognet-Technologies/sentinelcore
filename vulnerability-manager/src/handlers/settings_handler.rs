// src/handlers/settings_handler.rs
// User settings management

use axum::{
    extract::State,
    http::StatusCode,
    Json,
};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use crate::state::AppState;
use crate::auth::Claims;

#[derive(Debug, Serialize, Deserialize)]
pub struct UserSettings {
    pub notifications: NotificationSettings,
    pub security: SecuritySettings,
    pub integrations: IntegrationSettings,
    pub preferences: PreferenceSettings,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct NotificationSettings {
    pub email: bool,
    pub push: bool,
    pub critical: bool,
    pub weekly: bool,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct SecuritySettings {
    pub two_factor_enabled: bool,
    pub session_timeout_minutes: i32,
    pub ip_whitelist_enabled: bool,
    #[serde(default)]
    pub ip_whitelist: Vec<String>,
}

#[derive(Debug, Serialize, Deserialize, Default)]
pub struct IntegrationSettings {
    #[serde(default)]
    pub nessus: Option<IntegrationConfig>,
    #[serde(default)]
    pub qualys: Option<IntegrationConfig>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct IntegrationConfig {
    pub enabled: bool,
    pub last_sync: Option<String>,
    pub api_key: Option<String>,
}

#[derive(Debug, Serialize, Deserialize, Default)]
pub struct PreferenceSettings {
    #[serde(default)]
    pub theme: Option<String>,
    #[serde(default)]
    pub language: Option<String>,
}

#[derive(Serialize)]
pub struct ErrorResponse {
    error: String,
}

/// GET /api/settings
/// Get user settings
pub async fn get_settings(
    State(app_state): State<AppState>,
    claims: Claims,
) -> Result<Json<UserSettings>, (StatusCode, Json<ErrorResponse>)> {
    let user_id = Uuid::parse_str(&claims.sub).map_err(|_| {
        (
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: "Invalid user ID".to_string(),
            }),
        )
    })?;

    // Try to fetch existing settings
    let settings_row = sqlx::query!(
        r#"
        SELECT notifications, security, integrations, preferences
        FROM user_settings
        WHERE user_id = $1
        "#,
        user_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Database error fetching settings: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to fetch settings".to_string(),
            }),
        )
    })?;

    let settings = if let Some(row) = settings_row {
        // Parse existing settings
        UserSettings {
            notifications: serde_json::from_value(row.notifications.unwrap_or_default())
                .unwrap_or_else(|_| NotificationSettings {
                    email: true,
                    push: false,
                    critical: true,
                    weekly: false,
                }),
            security: serde_json::from_value(row.security.unwrap_or_default())
                .unwrap_or_else(|_| SecuritySettings {
                    two_factor_enabled: false,
                    session_timeout_minutes: 30,
                    ip_whitelist_enabled: false,
                    ip_whitelist: vec![],
                }),
            integrations: serde_json::from_value(row.integrations.unwrap_or_default())
                .unwrap_or_default(),
            preferences: serde_json::from_value(row.preferences.unwrap_or_default())
                .unwrap_or_default(),
        }
    } else {
        // Create default settings
        let default_notifications = serde_json::json!({
            "email": true,
            "push": false,
            "critical": true,
            "weekly": false
        });
        let default_security = serde_json::json!({
            "twoFactor": false,
            "sessionTimeout": "30",
            "ipWhitelist": false
        });
        let default_integrations = serde_json::json!({});
        let default_preferences = serde_json::json!({});

        sqlx::query!(
            r#"
            INSERT INTO user_settings (user_id, notifications, security, integrations, preferences)
            VALUES ($1, $2, $3, $4, $5)
            ON CONFLICT (user_id) DO NOTHING
            "#,
            user_id,
            default_notifications,
            default_security,
            default_integrations,
            default_preferences
        )
        .execute(&*app_state.pool)
        .await
        .ok();

        UserSettings {
            notifications: NotificationSettings {
                email: true,
                push: false,
                critical: true,
                weekly: false,
            },
            security: SecuritySettings {
                two_factor_enabled: false,
                session_timeout_minutes: 30,
                ip_whitelist_enabled: false,
                ip_whitelist: vec![],
            },
            integrations: IntegrationSettings {
                nessus: None,
                qualys: None,
            },
            preferences: PreferenceSettings::default(),
        }
    };

    Ok(Json(settings))
}

/// PUT /api/settings
/// Update user settings
pub async fn update_settings(
    State(app_state): State<AppState>,
    claims: Claims,
    Json(settings): Json<UserSettings>,
) -> Result<Json<UserSettings>, (StatusCode, Json<ErrorResponse>)> {
    let user_id = Uuid::parse_str(&claims.sub).map_err(|_| {
        (
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: "Invalid user ID".to_string(),
            }),
        )
    })?;

    let notifications_json = serde_json::to_value(&settings.notifications).map_err(|e| {
        tracing::error!("Failed to serialize notifications: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Invalid settings format".to_string(),
            }),
        )
    })?;

    let security_json = serde_json::to_value(&settings.security).map_err(|e| {
        tracing::error!("Failed to serialize security: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Invalid settings format".to_string(),
            }),
        )
    })?;

    let integrations_json = serde_json::to_value(&settings.integrations).map_err(|e| {
        tracing::error!("Failed to serialize integrations: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Invalid settings format".to_string(),
            }),
        )
    })?;

    let preferences_json = serde_json::to_value(&settings.preferences).map_err(|e| {
        tracing::error!("Failed to serialize preferences: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Invalid settings format".to_string(),
            }),
        )
    })?;

    sqlx::query!(
        r#"
        INSERT INTO user_settings (user_id, notifications, security, integrations, preferences)
        VALUES ($1, $2, $3, $4, $5)
        ON CONFLICT (user_id) DO UPDATE SET
            notifications = EXCLUDED.notifications,
            security = EXCLUDED.security,
            integrations = EXCLUDED.integrations,
            preferences = EXCLUDED.preferences,
            updated_at = NOW()
        "#,
        user_id,
        notifications_json,
        security_json,
        integrations_json,
        preferences_json
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Database error updating settings: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to update settings".to_string(),
            }),
        )
    })?;

    Ok(Json(settings))
}

// System-wide settings (admin only)

#[derive(Serialize, Deserialize)]
pub struct SystemSetting {
    pub setting_key: String,
    pub setting_value: String,
    pub description: Option<String>,
}

#[derive(Deserialize)]
pub struct UpdateSystemSettingsRequest {
    pub settings: Vec<SystemSetting>,
}

/// GET /api/system-settings
/// Get all system-wide settings
pub async fn get_system_settings(
    State(app_state): State<AppState>,
    _claims: Claims,
) -> Result<Json<Vec<SystemSetting>>, (StatusCode, Json<ErrorResponse>)> {
    let settings = sqlx::query!(
        r#"
        SELECT setting_key, setting_value, description
        FROM system_settings
        ORDER BY setting_key
        "#
    )
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse { error: format!("Failed to fetch settings: {}", e) }),
    ))?;

    let result: Vec<SystemSetting> = settings
        .into_iter()
        .map(|s| SystemSetting {
            setting_key: s.setting_key,
            setting_value: s.setting_value,
            description: s.description,
        })
        .collect();

    Ok(Json(result))
}

/// PUT /api/system-settings
/// Update system-wide settings (admin only)
pub async fn update_system_settings(
    State(app_state): State<AppState>,
    claims: Claims,
    Json(update_request): Json<UpdateSystemSettingsRequest>,
) -> Result<Json<serde_json::Value>, (StatusCode, Json<ErrorResponse>)> {
    let user_id = claims.sub.parse::<Uuid>().map_err(|_| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse { error: "Invalid user ID".to_string() }),
    ))?;

    // Verify user is admin
    let user_role = sqlx::query_scalar::<_, String>(
        "SELECT role::TEXT FROM users WHERE id = $1"
    )
    .bind(user_id)
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|_| (
        StatusCode::UNAUTHORIZED,
        Json(ErrorResponse { error: "User not found".to_string() }),
    ))?;

    if user_role != "admin" {
        return Err((
            StatusCode::FORBIDDEN,
            Json(ErrorResponse { error: "Only admins can update system settings".to_string() }),
        ));
    }

    // Update each setting
    for setting in &update_request.settings {
        sqlx::query!(
            r#"
            UPDATE system_settings
            SET setting_value = $1, updated_by = $2, updated_at = NOW()
            WHERE setting_key = $3
            "#,
            setting.setting_value,
            user_id,
            setting.setting_key
        )
        .execute(&*app_state.pool)
        .await
        .map_err(|e| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse { error: format!("Failed to update setting {}: {}", setting.setting_key, e) }),
        ))?;
    }

    Ok(Json(serde_json::json!({
        "message": "Settings updated successfully",
        "updated_count": update_request.settings.len()
    })))
}
