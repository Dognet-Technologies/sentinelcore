// src/handlers/settings_handler.rs
// User settings management

use axum::{
    extract::State,
    http::StatusCode,
    Json,
};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use crate::state::AppState;
use crate::auth::Claims;

#[derive(Debug, Serialize, Deserialize)]
pub struct UserSettings {
    pub notifications: NotificationSettings,
    pub security: SecuritySettings,
    pub integrations: IntegrationSettings,
    pub preferences: PreferenceSettings,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct NotificationSettings {
    pub email: bool,
    pub push: bool,
    pub critical: bool,
    pub weekly: bool,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct SecuritySettings {
    #[serde(rename = "twoFactor")]
    pub two_factor: bool,
    #[serde(rename = "sessionTimeout")]
    pub session_timeout: String,
    #[serde(rename = "ipWhitelist")]
    pub ip_whitelist: bool,
}

#[derive(Debug, Serialize, Deserialize, Default)]
pub struct IntegrationSettings {
    #[serde(default)]
    pub nessus: Option<IntegrationConfig>,
    #[serde(default)]
    pub qualys: Option<IntegrationConfig>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct IntegrationConfig {
    pub enabled: bool,
    pub last_sync: Option<String>,
    pub api_key: Option<String>,
}

#[derive(Debug, Serialize, Deserialize, Default)]
pub struct PreferenceSettings {
    #[serde(default)]
    pub theme: Option<String>,
    #[serde(default)]
    pub language: Option<String>,
}

#[derive(Serialize)]
pub struct ErrorResponse {
    error: String,
}

/// GET /api/settings
/// Get user settings
pub async fn get_settings(
    State(app_state): State<AppState>,
    claims: Claims,
) -> Result<Json<UserSettings>, (StatusCode, Json<ErrorResponse>)> {
    let user_id = Uuid::parse_str(&claims.sub).map_err(|_| {
        (
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: "Invalid user ID".to_string(),
            }),
        )
    })?;

    // Try to fetch existing settings
    let settings_row = sqlx::query!(
        r#"
        SELECT notifications, security, integrations, preferences
        FROM user_settings
        WHERE user_id = $1
        "#,
        user_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Database error fetching settings: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to fetch settings".to_string(),
            }),
        )
    })?;

    let settings = if let Some(row) = settings_row {
        // Parse existing settings
        UserSettings {
            notifications: serde_json::from_value(row.notifications.unwrap_or_default())
                .unwrap_or_else(|_| NotificationSettings {
                    email: true,
                    push: false,
                    critical: true,
                    weekly: false,
                }),
            security: serde_json::from_value(row.security.unwrap_or_default())
                .unwrap_or_else(|_| SecuritySettings {
                    two_factor: false,
                    session_timeout: "30".to_string(),
                    ip_whitelist: false,
                }),
            integrations: serde_json::from_value(row.integrations.unwrap_or_default())
                .unwrap_or_default(),
            preferences: serde_json::from_value(row.preferences.unwrap_or_default())
                .unwrap_or_default(),
        }
    } else {
        // Create default settings
        let default_notifications = serde_json::json!({
            "email": true,
            "push": false,
            "critical": true,
            "weekly": false
        });
        let default_security = serde_json::json!({
            "twoFactor": false,
            "sessionTimeout": "30",
            "ipWhitelist": false
        });
        let default_integrations = serde_json::json!({});
        let default_preferences = serde_json::json!({});

        sqlx::query!(
            r#"
            INSERT INTO user_settings (user_id, notifications, security, integrations, preferences)
            VALUES ($1, $2, $3, $4, $5)
            ON CONFLICT (user_id) DO NOTHING
            "#,
            user_id,
            default_notifications,
            default_security,
            default_integrations,
            default_preferences
        )
        .execute(&*app_state.pool)
        .await
        .ok();

        UserSettings {
            notifications: NotificationSettings {
                email: true,
                push: false,
                critical: true,
                weekly: false,
            },
            security: SecuritySettings {
                two_factor: false,
                session_timeout: "30".to_string(),
                ip_whitelist: false,
            },
            integrations: IntegrationSettings {
                nessus: None,
                qualys: None,
            },
            preferences: PreferenceSettings::default(),
        }
    };

    Ok(Json(settings))
}

/// PUT /api/settings
/// Update user settings
pub async fn update_settings(
    State(app_state): State<AppState>,
    claims: Claims,
    Json(settings): Json<UserSettings>,
) -> Result<Json<UserSettings>, (StatusCode, Json<ErrorResponse>)> {
    let user_id = Uuid::parse_str(&claims.sub).map_err(|_| {
        (
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: "Invalid user ID".to_string(),
            }),
        )
    })?;

    let notifications_json = serde_json::to_value(&settings.notifications).map_err(|e| {
        tracing::error!("Failed to serialize notifications: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Invalid settings format".to_string(),
            }),
        )
    })?;

    let security_json = serde_json::to_value(&settings.security).map_err(|e| {
        tracing::error!("Failed to serialize security: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Invalid settings format".to_string(),
            }),
        )
    })?;

    let integrations_json = serde_json::to_value(&settings.integrations).map_err(|e| {
        tracing::error!("Failed to serialize integrations: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Invalid settings format".to_string(),
            }),
        )
    })?;

    let preferences_json = serde_json::to_value(&settings.preferences).map_err(|e| {
        tracing::error!("Failed to serialize preferences: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Invalid settings format".to_string(),
            }),
        )
    })?;

    sqlx::query!(
        r#"
        INSERT INTO user_settings (user_id, notifications, security, integrations, preferences)
        VALUES ($1, $2, $3, $4, $5)
        ON CONFLICT (user_id) DO UPDATE SET
            notifications = EXCLUDED.notifications,
            security = EXCLUDED.security,
            integrations = EXCLUDED.integrations,
            preferences = EXCLUDED.preferences,
            updated_at = NOW()
        "#,
        user_id,
        notifications_json,
        security_json,
        integrations_json,
        preferences_json
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Database error updating settings: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to update settings".to_string(),
            }),
        )
    })?;

    Ok(Json(settings))
}
