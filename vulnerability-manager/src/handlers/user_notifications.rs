// src/handlers/user_notifications.rs
// API handlers for persistent user notifications (bell icon)

use axum::{
    extract::{Path, Query, State},
    http::StatusCode,
    Json,
};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use crate::auth::Claims;
use crate::state::AppState;

#[derive(Debug, Serialize, Deserialize)]
pub struct UserNotification {
    pub id: Uuid,
    pub notification_type: String,
    pub priority: String,
    pub title: String,
    pub message: String,
    pub action_url: Option<String>,
    pub vulnerability_id: Option<Uuid>,
    pub team_id: Option<Uuid>,
    pub actor_name: Option<String>,
    pub metadata: Option<serde_json::Value>,
    pub is_read: bool,
    pub read_at: Option<chrono::DateTime<chrono::Utc>>,
    pub created_at: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug, Deserialize)]
pub struct ListNotificationsQuery {
    pub limit: Option<i64>,
    pub offset: Option<i64>,
    pub unread_only: Option<bool>,
}

#[derive(Debug, Serialize)]
pub struct NotificationCountResponse {
    pub unread_count: i32,
}

#[derive(Debug, Serialize)]
pub struct NotificationListResponse {
    pub notifications: Vec<UserNotification>,
    pub total_count: i64,
    pub unread_count: i64,
}

/// GET /api/notifications/unread-count
/// Get count of unread notifications for current user
pub async fn get_unread_count(
    State(app_state): State<AppState>,
    claims: Claims,
) -> Result<Json<NotificationCountResponse>, (StatusCode, String)> {
    let user_id = Uuid::parse_str(&claims.sub)
        .map_err(|_| (StatusCode::BAD_REQUEST, "Invalid user ID".to_string()))?;

    let count = sqlx::query_scalar::<_, i32>(
        "SELECT get_unread_notification_count($1)"
    )
    .bind(user_id)
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, format!("Database error: {}", e)))?;

    Ok(Json(NotificationCountResponse {
        unread_count: count,
    }))
}

/// GET /api/notifications
/// Get list of notifications for current user
pub async fn list_notifications(
    State(app_state): State<AppState>,
    Query(query): Query<ListNotificationsQuery>,
    claims: Claims,
) -> Result<Json<NotificationListResponse>, (StatusCode, String)> {
    let user_id = Uuid::parse_str(&claims.sub)
        .map_err(|_| (StatusCode::BAD_REQUEST, "Invalid user ID".to_string()))?;

    let limit = query.limit.unwrap_or(50).min(100); // Max 100 notifications
    let offset = query.offset.unwrap_or(0);
    let unread_only = query.unread_only.unwrap_or(false);

    // Build query
    let where_clause = if unread_only {
        "WHERE user_id = $1 AND is_read = FALSE AND is_dismissed = FALSE AND (expires_at IS NULL OR expires_at > NOW())"
    } else {
        "WHERE user_id = $1 AND is_dismissed = FALSE AND (expires_at IS NULL OR expires_at > NOW())"
    };

    let query_str = format!(
        r#"
        SELECT
            id,
            notification_type::TEXT as notification_type,
            priority::TEXT as priority,
            title,
            message,
            action_url,
            vulnerability_id,
            team_id,
            actor_name,
            metadata,
            is_read,
            read_at,
            created_at
        FROM user_notifications
        {}
        ORDER BY created_at DESC
        LIMIT $2 OFFSET $3
        "#,
        where_clause
    );

    #[derive(sqlx::FromRow)]
    struct NotificationRow {
        id: Uuid,
        notification_type: String,
        priority: String,
        title: String,
        message: String,
        action_url: Option<String>,
        vulnerability_id: Option<Uuid>,
        team_id: Option<Uuid>,
        actor_name: Option<String>,
        metadata: Option<serde_json::Value>,
        is_read: bool,
        read_at: Option<chrono::DateTime<chrono::Utc>>,
        created_at: chrono::DateTime<chrono::Utc>,
    }

    let notifications = sqlx::query_as::<_, NotificationRow>(&query_str)
        .bind(user_id)
        .bind(limit)
        .bind(offset)
        .fetch_all(&*app_state.pool)
        .await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, format!("Database error: {}", e)))?;

    // Get total count
    let total_count_query = format!(
        "SELECT COUNT(*)::BIGINT FROM user_notifications {}",
        where_clause
    );

    let total_count = sqlx::query_scalar::<_, i64>(&total_count_query)
        .bind(user_id)
        .fetch_one(&*app_state.pool)
        .await
        .unwrap_or(0);

    // Get unread count
    let unread_count = sqlx::query_scalar::<_, i64>(
        "SELECT COUNT(*)::BIGINT FROM user_notifications WHERE user_id = $1 AND is_read = FALSE AND is_dismissed = FALSE"
    )
    .bind(user_id)
    .fetch_one(&*app_state.pool)
    .await
    .unwrap_or(0);

    let notifications_response: Vec<UserNotification> = notifications
        .into_iter()
        .map(|row| UserNotification {
            id: row.id,
            notification_type: row.notification_type,
            priority: row.priority,
            title: row.title,
            message: row.message,
            action_url: row.action_url,
            vulnerability_id: row.vulnerability_id,
            team_id: row.team_id,
            actor_name: row.actor_name,
            metadata: row.metadata,
            is_read: row.is_read,
            read_at: row.read_at,
            created_at: row.created_at,
        })
        .collect();

    Ok(Json(NotificationListResponse {
        notifications: notifications_response,
        total_count,
        unread_count,
    }))
}

/// PUT /api/notifications/:id/read
/// Mark a notification as read
pub async fn mark_notification_read(
    State(app_state): State<AppState>,
    Path(notification_id): Path<Uuid>,
    claims: Claims,
) -> Result<StatusCode, (StatusCode, String)> {
    let user_id = Uuid::parse_str(&claims.sub)
        .map_err(|_| (StatusCode::BAD_REQUEST, "Invalid user ID".to_string()))?;

    let result = sqlx::query_scalar::<_, bool>(
        "SELECT mark_notification_read($1, $2)"
    )
    .bind(notification_id)
    .bind(user_id)
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, format!("Database error: {}", e)))?;

    if result {
        Ok(StatusCode::OK)
    } else {
        Err((StatusCode::NOT_FOUND, "Notification not found or already read".to_string()))
    }
}

/// PUT /api/notifications/read-all
/// Mark all notifications as read for current user
pub async fn mark_all_notifications_read(
    State(app_state): State<AppState>,
    claims: Claims,
) -> Result<Json<serde_json::Value>, (StatusCode, String)> {
    let user_id = Uuid::parse_str(&claims.sub)
        .map_err(|_| (StatusCode::BAD_REQUEST, "Invalid user ID".to_string()))?;

    let count = sqlx::query_scalar::<_, i32>(
        "SELECT mark_all_notifications_read($1)"
    )
    .bind(user_id)
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, format!("Database error: {}", e)))?;

    Ok(Json(serde_json::json!({
        "marked_read": count
    })))
}

/// DELETE /api/notifications/:id
/// Dismiss (soft delete) a notification
pub async fn dismiss_notification(
    State(app_state): State<AppState>,
    Path(notification_id): Path<Uuid>,
    claims: Claims,
) -> Result<StatusCode, (StatusCode, String)> {
    let user_id = Uuid::parse_str(&claims.sub)
        .map_err(|_| (StatusCode::BAD_REQUEST, "Invalid user ID".to_string()))?;

    let result = sqlx::query(
        r#"
        UPDATE user_notifications
        SET is_dismissed = TRUE,
            dismissed_at = NOW()
        WHERE id = $1 AND user_id = $2
        "#
    )
    .bind(notification_id)
    .bind(user_id)
    .execute(&*app_state.pool)
    .await
    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, format!("Database error: {}", e)))?;

    if result.rows_affected() > 0 {
        Ok(StatusCode::OK)
    } else {
        Err((StatusCode::NOT_FOUND, "Notification not found".to_string()))
    }
}
