// src/handlers/audit.rs  
// FIXED: Aggiunto import State per Axum 0.6

use axum::{
    extract::{Path, Query, State}, // FIXED: Aggiunto State
    http::StatusCode,
    Json,
};
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use serde_json::Value;
use sqlx::PgPool;
use std::sync::Arc;
use uuid::Uuid;

use crate::auth::Claims;
use crate::models::user::PaginationParams;

#[derive(Debug, Serialize, Deserialize)]
pub struct AuditLogFilter {
    pub action: Option<String>,
    pub entity_type: Option<String>,
    pub entity_id: Option<Uuid>,
    pub user_id: Option<Uuid>,
    pub start_date: Option<DateTime<Utc>>,
    pub end_date: Option<DateTime<Utc>>,
    pub ip_address: Option<String>,
}

#[derive(Debug, Serialize, sqlx::FromRow)]
pub struct AuditLogResponse {
    pub id: Uuid,
    pub user_id: Option<Uuid>,
    pub action: String,
    pub entity_type: String,
    pub entity_id: Option<Uuid>,
    pub old_values: Option<Value>,
    pub new_values: Option<Value>,
    pub ip_address: Option<String>,
    pub user_agent: Option<String>,
    pub created_at: DateTime<Utc>,
}

#[derive(Debug, Serialize)]
pub struct AuditLogStats {
    pub total_logs: i64,
    pub actions_breakdown: Vec<ActionCount>,
    pub daily_activity: Vec<DailyActivity>,
    pub top_users: Vec<UserActivity>,
}

#[derive(Debug, Serialize, sqlx::FromRow)]
pub struct ActionCount {
    pub action: String,
    pub count: Option<i64>, // FIXED: Option per compatibilità SQL
}

#[derive(Debug, Serialize, sqlx::FromRow)]
pub struct DailyActivity {
    pub date: Option<chrono::NaiveDate>,
    pub count: Option<i64>, // FIXED: Option per compatibilità SQL
}

#[derive(Debug, Serialize, sqlx::FromRow)]
pub struct UserActivity {
    pub user_id: Option<Uuid>,
    pub username: Option<String>,
    pub count: Option<i64>, // FIXED: Option per compatibilità SQL
}

#[derive(Serialize)]
pub struct ErrorResponse {
    error: String,
}

// Create audit log entry
pub async fn create_audit_log(
    State(pool): State<Arc<PgPool>>,
    claims: Claims,
    Json(log_data): Json<Value>,
) -> Result<StatusCode, (StatusCode, Json<ErrorResponse>)> {
    let user_id = claims.sub.parse::<Uuid>().map_err(|_| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: "Invalid user ID".to_string(),
        }),
    ))?;

    let action = log_data["action"].as_str().unwrap_or("unknown");
    let entity_type = log_data["entity_type"].as_str().unwrap_or("unknown");
    let entity_id = log_data["entity_id"]
        .as_str()
        .and_then(|s| Uuid::parse_str(s).ok());
    let old_values = log_data.get("old_values");
    let new_values = log_data.get("new_values");
    let ip_address = log_data["ip_address"].as_str().map(|s| s.to_string());

    sqlx::query!(
        r#"
        INSERT INTO audit_logs (user_id, action, entity_type, entity_id, old_values, new_values, ip_address)
        VALUES ($1, $2, $3, $4, $5, $6, $7)
        "#,
        user_id,
        action,
        entity_type,
        entity_id,
        old_values,
        new_values,
        ip_address
    )
    .execute(&*pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to create audit log: {}", e),
        }),
    ))?;

    Ok(StatusCode::CREATED)
}

// Get audit logs
pub async fn get_audit_logs(
    State(pool): State<Arc<PgPool>>,
    _claims: Claims,
    Query(_filter): Query<AuditLogFilter>,
    Query(pagination): Query<PaginationParams>,
) -> Result<Json<Vec<AuditLogResponse>>, (StatusCode, Json<ErrorResponse>)> {
    let limit = pagination.limit.unwrap_or(50).min(1000);
    let offset = (pagination.page.unwrap_or(1) - 1) * limit;

    let logs = sqlx::query_as!(
        AuditLogResponse,
        r#"
        SELECT id, user_id, action, entity_type, entity_id, 
               old_values, new_values, ip_address, 
               user_agent, created_at
        FROM audit_logs
        ORDER BY created_at DESC
        LIMIT $1 OFFSET $2
        "#,
        limit,
        offset
    )
    .fetch_all(&*pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to fetch audit logs: {}", e),
        }),
    ))?;

    Ok(Json(logs))
}

// Get audit log by ID
pub async fn get_audit_log_by_id(
    State(pool): State<Arc<PgPool>>,
    _claims: Claims,
    Path(log_id): Path<Uuid>,
) -> Result<Json<AuditLogResponse>, (StatusCode, Json<ErrorResponse>)> {
    let log = sqlx::query_as!(
        AuditLogResponse,
        r#"
        SELECT id, user_id, action, entity_type, entity_id,
               old_values, new_values, ip_address, 
               user_agent, created_at
        FROM audit_logs
        WHERE id = $1
        "#,
        log_id
    )
    .fetch_optional(&*pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to fetch audit log: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Audit log not found".to_string(),
        }),
    ))?;

    Ok(Json(log))
}

// Get audit statistics - FIXED: Gestione Option<i64>
pub async fn get_audit_stats(
    State(pool): State<Arc<PgPool>>,
    _claims: Claims,
    Query(_filter): Query<AuditLogFilter>,
) -> Result<Json<AuditLogStats>, (StatusCode, Json<ErrorResponse>)> {
    // Total count
    let total_logs: i64 = sqlx::query_scalar!(
        "SELECT COUNT(*) FROM audit_logs"
    )
    .fetch_one(&*pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to fetch total count: {}", e),
        }),
    ))?
    .unwrap_or(0);

    // Actions breakdown
    let actions_breakdown_raw: Vec<ActionCount> = sqlx::query_as!(
        ActionCount,
        r#"
        SELECT action, COUNT(*)::bigint as count
        FROM audit_logs 
        GROUP BY action 
        ORDER BY count DESC 
        LIMIT 10
        "#
    )
    .fetch_all(&*pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to fetch actions breakdown: {}", e),
        }),
    ))?;

    // Convert Option<i64> to i64 for response
    let actions_breakdown: Vec<_> = actions_breakdown_raw.into_iter().map(|item| {
        serde_json::json!({
            "action": item.action,
            "count": item.count.unwrap_or(0)
        })
    }).collect();

    // Daily activity  
    let daily_activity_raw: Vec<DailyActivity> = sqlx::query_as!(
        DailyActivity,
        r#"
        SELECT DATE(created_at) as date, COUNT(*)::bigint as count
        FROM audit_logs 
        WHERE created_at >= CURRENT_DATE - INTERVAL '30 days'
        GROUP BY DATE(created_at) 
        ORDER BY date DESC
        "#
    )
    .fetch_all(&*pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to fetch daily activity: {}", e),
        }),
    ))?;

    let daily_activity: Vec<_> = daily_activity_raw.into_iter().map(|item| {
        serde_json::json!({
            "date": item.date,
            "count": item.count.unwrap_or(0)
        })
    }).collect();

    // Top users
    let top_users_raw: Vec<UserActivity> = sqlx::query_as!(
        UserActivity,
        r#"
        SELECT al.user_id, u.username, 
               COUNT(*)::bigint as count
        FROM audit_logs al
        LEFT JOIN users u ON al.user_id = u.id
        WHERE al.user_id IS NOT NULL
        GROUP BY al.user_id, u.username 
        ORDER BY count DESC 
        LIMIT 10
        "#
    )
    .fetch_all(&*pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to fetch top users: {}", e),
        }),
    ))?;

    let top_users: Vec<_> = top_users_raw.into_iter().map(|item| {
        serde_json::json!({
            "user_id": item.user_id,
            "username": item.username,
            "count": item.count.unwrap_or(0)
        })
    }).collect();

    // FIXED: Uso serde_json::Value temporaneamente per compatibilità
    let response = serde_json::json!({
        "total_logs": total_logs,
        "actions_breakdown": actions_breakdown,
        "daily_activity": daily_activity,
        "top_users": top_users
    });

    Ok(Json(response))
}