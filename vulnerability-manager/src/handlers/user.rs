// src/handlers/user.rs
// FIXED: Convertito da Extension a State per Axum 0.6

use axum::{
    extract::{Path, Query, State, Multipart}, // FIXED: State invece di Extension
    http::StatusCode,
    Json,
};
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use sqlx::PgPool;
use std::sync::Arc;
use uuid::Uuid;
use validator::Validate;

use crate::auth::{Auth, Claims};
use crate::models::user::{
    User, Role, NewUser, UpdateUser, UpdateProfileRequest, ChangePasswordRequest,
    UserSession, ReputationEvent, SecuritySettings, PaginationParams
};
use crate::AppState;

#[derive(Serialize)]
pub struct ErrorResponse {
    error: String,
}

#[derive(Serialize)]
pub struct UserResponse {
    id: Uuid,
    username: String,
    email: String,
    role: String,
    reputation_score: i32, // FIXED: i32 invece di Option<i32>
    avatar_url: Option<String>,
    last_login: Option<DateTime<Utc>>,
    two_factor_enabled: bool,
    phone_number: Option<String>,
    bio: Option<String>,
    preferred_language: Option<String>,
    created_at: DateTime<Utc>,
    updated_at: DateTime<Utc>,
}

impl From<User> for UserResponse {
    fn from(user: User) -> Self {
        Self {
            id: user.id,
            username: user.username,
            email: user.email,
            role: user.role.as_str().to_string(),
            reputation_score: user.reputation_score.unwrap_or(0), // FIXED: gestione Option
            avatar_url: user.avatar_url,
            last_login: user.last_login,
            two_factor_enabled: user.two_factor_enabled.unwrap_or(false),
            phone_number: user.phone_number,
            bio: user.bio,
            preferred_language: user.preferred_language,
            created_at: user.created_at,
            updated_at: user.updated_at,
        }
    }
}

// Get current user profile - FIXED: State
pub async fn get_current_user(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    claims: Claims,
) -> Result<Json<UserResponse>, (StatusCode, Json<ErrorResponse>)> {
    let user_id = claims.sub.parse::<Uuid>().map_err(|_| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: "Invalid user ID".to_string(),
        }),
    ))?;

    let user = sqlx::query_as!(
        User,
        r#"
        SELECT id, username, email, password_hash, role as "role: Role",
               reputation_score, avatar_url, last_login, failed_login_attempts,
               account_locked_until, two_factor_enabled, two_factor_secret,
               phone_number, bio, preferred_language, created_at, updated_at
        FROM users 
        WHERE id = $1
        "#,
        user_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "User not found".to_string(),
        }),
    ))?;

    Ok(Json(UserResponse::from(user)))
}

// Update current user profile - FIXED: State
pub async fn update_current_user(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    claims: Claims,
    Json(update_data): Json<UpdateProfileRequest>,
) -> Result<Json<UserResponse>, (StatusCode, Json<ErrorResponse>)> {
    // Validate input
    update_data.validate().map_err(|e| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: format!("Validation error: {}", e),
        }),
    ))?;

    let user_id = claims.sub.parse::<Uuid>().map_err(|_| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: "Invalid user ID".to_string(),
        }),
    ))?;

    let user = sqlx::query_as!(
        User,
        r#"
        UPDATE users
        SET 
            username = COALESCE($2, username),
            email = COALESCE($3, email),
            phone_number = $4,
            bio = $5,
            preferred_language = $6,
            updated_at = NOW()
        WHERE id = $1
        RETURNING id, username, email, password_hash, role as "role: Role",
                  reputation_score, avatar_url, last_login, failed_login_attempts,
                  account_locked_until, two_factor_enabled, two_factor_secret,
                  phone_number, bio, preferred_language, created_at, updated_at
        "#,
        user_id,
        update_data.username,
        update_data.email,
        update_data.phone_number,
        update_data.bio,
        update_data.preferred_language
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to update user: {}", e),
        }),
    ))?;

    Ok(Json(UserResponse::from(user)))
}

// Change password - FIXED: State
pub async fn change_password(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    claims: Claims,
    Json(password_data): Json<ChangePasswordRequest>,
) -> Result<StatusCode, (StatusCode, Json<ErrorResponse>)> {
    // Validate input
    password_data.validate().map_err(|e| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: format!("Validation error: {}", e),
        }),
    ))?;

    let user_id = claims.sub.parse::<Uuid>().map_err(|_| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: "Invalid user ID".to_string(),
        }),
    ))?;

    // Get current user to verify password
    let user = sqlx::query!(
        "SELECT password_hash FROM users WHERE id = $1",
        user_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "User not found".to_string(),
        }),
    ))?;

    // Verify current password
    let is_valid = app_state.auth.verify_password(&password_data.current_password, &user.password_hash)
        .map_err(|_| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Password verification failed".to_string(),
            }),
        ))?;

    if !is_valid {
        return Err((
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: "Current password is incorrect".to_string(),
            }),
        ));
    }

    // Hash new password
    let new_password_hash = app_state.auth.hash_password(&password_data.new_password)
        .map_err(|e| (
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: format!("Password validation failed: {}", e),
            }),
        ))?;

    // Update password
    sqlx::query!(
        "UPDATE users SET password_hash = $1, updated_at = NOW() WHERE id = $2",
        new_password_hash,
        user_id
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to update password: {}", e),
        }),
    ))?;

    Ok(StatusCode::NO_CONTENT)
}

// Upload avatar - FIXED: State
pub async fn upload_avatar(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    claims: Claims,
    mut multipart: Multipart,
) -> Result<Json<serde_json::Value>, (StatusCode, Json<ErrorResponse>)> {
    let user_id = claims.sub.parse::<Uuid>().map_err(|_| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: "Invalid user ID".to_string(),
        }),
    ))?;

    while let Some(field) = multipart.next_field().await.map_err(|e| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: format!("Failed to read multipart data: {}", e),
        }),
    ))? {
        if field.name() == Some("avatar") {
            let filename = field.file_name()
                .unwrap_or("avatar.jpg")
                .to_string();
            
            let data = field.bytes().await.map_err(|e| (
                StatusCode::BAD_REQUEST,
                Json(ErrorResponse {
                    error: format!("Failed to read file data: {}", e),
                }),
            ))?;

            // Basic validation
            if data.len() > 5 * 1024 * 1024 { // 5MB limit
                return Err((
                    StatusCode::BAD_REQUEST,
                    Json(ErrorResponse {
                        error: "File too large (max 5MB)".to_string(),
                    }),
                ));
            }

            // In a real implementation, you would:
            // 1. Validate file type
            // 2. Save to storage (filesystem, S3, etc.)
            // 3. Generate thumbnail
            // 4. Scan for malware
            
            // For now, just generate a fake URL
            let avatar_url = format!("/avatars/{}/{}", user_id, filename);

            // Update user avatar URL
            sqlx::query!(
                "UPDATE users SET avatar_url = $1, updated_at = NOW() WHERE id = $2",
                avatar_url,
                user_id
            )
            .execute(&*app_state.pool)
            .await
            .map_err(|e| (
                StatusCode::INTERNAL_SERVER_ERROR,
                Json(ErrorResponse {
                    error: format!("Failed to update avatar URL: {}", e),
                }),
            ))?;

            return Ok(Json(serde_json::json!({
                "avatar_url": avatar_url,
                "message": "Avatar uploaded successfully"
            })));
        }
    }

    Err((
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: "No avatar file found in request".to_string(),
        }),
    ))
}

// Get user sessions - FIXED: State
pub async fn get_user_sessions(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    claims: Claims,
) -> Result<Json<Vec<UserSession>>, (StatusCode, Json<ErrorResponse>)> {
    let user_id = claims.sub.parse::<Uuid>().map_err(|_| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: "Invalid user ID".to_string(),
        }),
    ))?;

    let sessions = sqlx::query_as!(
        UserSession,
        r#"
        SELECT id, user_id, session_token, ip_address, user_agent,
               device_info, created_at, last_activity, expires_at,
               is_active, revoked_at, revoked_reason
        FROM user_sessions
        WHERE user_id = $1 AND is_active = true
        ORDER BY last_activity DESC
        "#,
        user_id
    )
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to fetch sessions: {}", e),
        }),
    ))?;

    Ok(Json(sessions))
}

// Revoke session - FIXED: State
pub async fn revoke_session(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    claims: Claims,
    Path(session_id): Path<Uuid>,
) -> Result<StatusCode, (StatusCode, Json<ErrorResponse>)> {
    let user_id = claims.sub.parse::<Uuid>().map_err(|_| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: "Invalid user ID".to_string(),
        }),
    ))?;

    let result = sqlx::query!(
        r#"
        UPDATE user_sessions 
        SET is_active = false, revoked_at = NOW(), revoked_reason = 'user_revoked'
        WHERE id = $1 AND user_id = $2 AND is_active = true
        "#,
        session_id,
        user_id
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to revoke session: {}", e),
        }),
    ))?;

    if result.rows_affected() == 0 {
        return Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Session not found or already revoked".to_string(),
            }),
        ));
    }

    Ok(StatusCode::NO_CONTENT)
}

// Two-factor authentication functions - FIXED: State
pub async fn enable_two_factor(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    claims: Claims,
) -> Result<Json<serde_json::Value>, (StatusCode, Json<ErrorResponse>)> {
    let user_id = claims.sub.parse::<Uuid>().map_err(|_| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: "Invalid user ID".to_string(),
        }),
    ))?;

    // Generate TOTP secret
    use rand::Rng;
    let mut rng = rand::thread_rng();
    let secret: [u8; 16] = rng.gen();
    let secret_string = base32::encode(base32::Alphabet::RFC4648 { padding: true }, &secret);

    // Update user with 2FA secret
    sqlx::query!(
        r#"
        UPDATE users 
        SET two_factor_secret = $1, two_factor_enabled = false, updated_at = NOW()
        WHERE id = $2
        "#,
        secret_string,
        user_id
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to update 2FA secret: {}", e),
        }),
    ))?;

    // Generate QR code URL
    let user = sqlx::query!(
        "SELECT username, email FROM users WHERE id = $1",
        user_id
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to fetch user: {}", e),
        }),
    ))?;

    let qr_url = format!(
        "otpauth://totp/VulnerabilityManager:{}?secret={}&issuer=VulnerabilityManager",
        user.email, secret_string
    );

    Ok(Json(serde_json::json!({
        "secret": secret_string,
        "qr_url": qr_url,
        "backup_codes": [], // In production, generate backup codes
        "message": "2FA setup initiated. Verify with your authenticator app to complete."
    })))
}

pub async fn disable_two_factor(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    claims: Claims,
) -> Result<StatusCode, (StatusCode, Json<ErrorResponse>)> {
    let user_id = claims.sub.parse::<Uuid>().map_err(|_| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: "Invalid user ID".to_string(),
        }),
    ))?;

    sqlx::query!(
        r#"
        UPDATE users 
        SET two_factor_enabled = false, two_factor_secret = NULL, updated_at = NOW()
        WHERE id = $1
        "#,
        user_id
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to disable 2FA: {}", e),
        }),
    ))?;

    Ok(StatusCode::NO_CONTENT)
}

pub async fn verify_two_factor(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    claims: Claims,
    Json(totp_code): Json<String>,
) -> Result<Json<serde_json::Value>, (StatusCode, Json<ErrorResponse>)> {
    let user_id = claims.sub.parse::<Uuid>().map_err(|_| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: "Invalid user ID".to_string(),
        }),
    ))?;

    let user = sqlx::query!(
        "SELECT two_factor_secret FROM users WHERE id = $1",
        user_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "User not found".to_string(),
        }),
    ))?;

    let secret = user.two_factor_secret.ok_or_else(|| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: "2FA not set up".to_string(),
        }),
    ))?;

    // Verify TOTP code
    let secret_bytes = base32::decode(base32::Alphabet::RFC4648 { padding: true }, &secret)
        .ok_or_else(|| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Invalid 2FA secret".to_string(),
            }),
        ))?;

    let is_valid = totp_lite::totp(&secret_bytes, 30) == totp_code;

    if is_valid {
        // Enable 2FA
        sqlx::query!(
            "UPDATE users SET two_factor_enabled = true, updated_at = NOW() WHERE id = $1",
            user_id
        )
        .execute(&*app_state.pool)
        .await
        .map_err(|e| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Failed to enable 2FA: {}", e),
            }),
        ))?;

        Ok(Json(serde_json::json!({
            "success": true,
            "message": "2FA enabled successfully"
        })))
    } else {
        Err((
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: "Invalid verification code".to_string(),
            }),
        ))
    }
}

// Security settings - FIXED: State
pub async fn get_security_settings(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    claims: Claims,
) -> Result<Json<SecuritySettings>, (StatusCode, Json<ErrorResponse>)> {
    let user_id = claims.sub.parse::<Uuid>().map_err(|_| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: "Invalid user ID".to_string(),
        }),
    ))?;

    let user = sqlx::query!(
        "SELECT two_factor_enabled FROM users WHERE id = $1",
        user_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "User not found".to_string(),
        }),
    ))?;

    // In a real implementation, these would be user-configurable
    let settings = SecuritySettings {
        two_factor_enabled: user.two_factor_enabled.unwrap_or(false),
        session_timeout: 24 * 60, // 24 hours in minutes
        ip_whitelist_enabled: false,
        allowed_ips: vec![],
        password_expiry_days: None,
        require_password_change: false,
    };

    Ok(Json(settings))
}

pub async fn update_security_settings(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    claims: Claims,
    Json(_settings): Json<SecuritySettings>,
) -> Result<Json<SecuritySettings>, (StatusCode, Json<ErrorResponse>)> {
    // This would update user security preferences
    // For now, just return current settings
    get_security_settings(State(app_state), claims).await
}

// Reputation events - FIXED: State
pub async fn get_reputation_events(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    claims: Claims,
) -> Result<Json<Vec<ReputationEvent>>, (StatusCode, Json<ErrorResponse>)> {
    let user_id = claims.sub.parse::<Uuid>().map_err(|_| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: "Invalid user ID".to_string(),
        }),
    ))?;

    let events = sqlx::query_as!(
        ReputationEvent,
        r#"
        SELECT id, user_id, event_type, points, description,
               related_entity_type, related_entity_id, created_at
        FROM reputation_events
        WHERE user_id = $1
        ORDER BY created_at DESC
        LIMIT 50
        "#,
        user_id
    )
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to fetch reputation events: {}", e),
        }),
    ))?;

    Ok(Json(events))
}

// Admin functions - FIXED: State
pub async fn list_users(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    _claims: Claims,
) -> Result<Json<Vec<UserResponse>>, (StatusCode, Json<ErrorResponse>)> {
    let users = sqlx::query_as!(
        User,
        r#"
        SELECT id, username, email, password_hash, role as "role: Role",
               reputation_score, avatar_url, last_login, failed_login_attempts,
               account_locked_until, two_factor_enabled, two_factor_secret,
               phone_number, bio, preferred_language, created_at, updated_at
        FROM users
        ORDER BY created_at DESC
        "#
    )
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to fetch users: {}", e),
        }),
    ))?;

    let user_responses: Vec<UserResponse> = users.into_iter()
        .map(UserResponse::from)
        .collect();

    Ok(Json(user_responses))
}

pub async fn create_user(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    _claims: Claims,
    Json(new_user): Json<NewUser>,
) -> Result<Json<UserResponse>, (StatusCode, Json<ErrorResponse>)> {
    let password_hash = app_state.auth.hash_password(&new_user.password)
        .map_err(|e| (
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: format!("Password validation failed: {}", e),
            }),
        ))?;

    let role = new_user.role.unwrap_or(Role::User);

    let user = sqlx::query_as!(
        User,
        r#"
        INSERT INTO users (username, email, password_hash, role)
        VALUES ($1, $2, $3, $4)
        RETURNING id, username, email, password_hash, role as "role: Role",
                  reputation_score, avatar_url, last_login, failed_login_attempts,
                  account_locked_until, two_factor_enabled, two_factor_secret,
                  phone_number, bio, preferred_language, created_at, updated_at
        "#,
        new_user.username,
        new_user.email,
        password_hash,
        role as _
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| {
        let error_message = if e.to_string().contains("duplicate key") {
            "Username or email already exists".to_string()
        } else {
            format!("Failed to create user: {}", e)
        };
        (
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse { error: error_message }),
        )
    })?;

    Ok(Json(UserResponse::from(user)))
}

pub async fn get_user(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    _claims: Claims,
    Path(user_id): Path<Uuid>,
) -> Result<Json<UserResponse>, (StatusCode, Json<ErrorResponse>)> {
    let user = sqlx::query_as!(
        User,
        r#"
        SELECT id, username, email, password_hash, role as "role: Role",
               reputation_score, avatar_url, last_login, failed_login_attempts,
               account_locked_until, two_factor_enabled, two_factor_secret,
               phone_number, bio, preferred_language, created_at, updated_at
        FROM users
        WHERE id = $1
        "#,
        user_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "User not found".to_string(),
        }),
    ))?;

    Ok(Json(UserResponse::from(user)))
}

pub async fn update_user(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    _claims: Claims,
    Path(user_id): Path<Uuid>,
    Json(update_data): Json<UpdateUser>,
) -> Result<Json<UserResponse>, (StatusCode, Json<ErrorResponse>)> {
    let password_hash = if let Some(password) = update_data.password {
        Some(app_state.auth.hash_password(&password)
            .map_err(|e| (
                StatusCode::BAD_REQUEST,
                Json(ErrorResponse {
                    error: format!("Password validation failed: {}", e),
                }),
            ))?)
    } else {
        None
    };

    let user = sqlx::query_as!(
        User,
        r#"
        UPDATE users
        SET 
            username = COALESCE($2, username),
            email = COALESCE($3, email),
            password_hash = COALESCE($4, password_hash),
            role = COALESCE($5, role),
            updated_at = NOW()
        WHERE id = $1
        RETURNING id, username, email, password_hash, role as "role: Role",
                  reputation_score, avatar_url, last_login, failed_login_attempts,
                  account_locked_until, two_factor_enabled, two_factor_secret,
                  phone_number, bio, preferred_language, created_at, updated_at
        "#,
        user_id,
        update_data.username,
        update_data.email,
        password_hash,
        update_data.role as _
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to update user: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "User not found".to_string(),
        }),
    ))?;

    Ok(Json(UserResponse::from(user)))
}

pub async fn delete_user(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    _claims: Claims,
    Path(user_id): Path<Uuid>,
) -> Result<StatusCode, (StatusCode, Json<ErrorResponse>)> {
    let result = sqlx::query!(
        "DELETE FROM users WHERE id = $1",
        user_id
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to delete user: {}", e),
        }),
    ))?;

    if result.rows_affected() == 0 {
        return Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "User not found".to_string(),
            }),
        ));
    }

    Ok(StatusCode::NO_CONTENT)
}

pub async fn lock_user(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    _claims: Claims,
    Path(user_id): Path<Uuid>,
) -> Result<StatusCode, (StatusCode, Json<ErrorResponse>)> {
    let lock_until = chrono::Utc::now() + chrono::Duration::hours(24);
    
    sqlx::query!(
        "UPDATE users SET account_locked_until = $1, updated_at = NOW() WHERE id = $2",
        lock_until,
        user_id
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to lock user: {}", e),
        }),
    ))?;

    Ok(StatusCode::NO_CONTENT)
}

pub async fn unlock_user(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    _claims: Claims,
    Path(user_id): Path<Uuid>,
) -> Result<StatusCode, (StatusCode, Json<ErrorResponse>)> {
    sqlx::query!(
        "UPDATE users SET account_locked_until = NULL, failed_login_attempts = 0, updated_at = NOW() WHERE id = $1",
        user_id
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to unlock user: {}", e),
        }),
    ))?;

    Ok(StatusCode::NO_CONTENT)
}

pub async fn get_user_sessions_admin(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    _claims: Claims,
    Path(user_id): Path<Uuid>,
) -> Result<Json<Vec<UserSession>>, (StatusCode, Json<ErrorResponse>)> {
    let sessions = sqlx::query_as!(
        UserSession,
        r#"
        SELECT id, user_id, session_token, ip_address, user_agent,
               device_info, created_at, last_activity, expires_at,
               is_active, revoked_at, revoked_reason
        FROM user_sessions
        WHERE user_id = $1
        ORDER BY last_activity DESC
        "#,
        user_id
    )
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to fetch sessions: {}", e),
        }),
    ))?;

    Ok(Json(sessions))
}

pub async fn revoke_all_user_sessions(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    _claims: Claims,
    Path(user_id): Path<Uuid>,
) -> Result<StatusCode, (StatusCode, Json<ErrorResponse>)> {
    sqlx::query!(
        r#"
        UPDATE user_sessions 
        SET is_active = false, revoked_at = NOW(), revoked_reason = 'admin_revoked'
        WHERE user_id = $1 AND is_active = true
        "#,
        user_id
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to revoke sessions: {}", e),
        }),
    ))?;

    Ok(StatusCode::NO_CONTENT)
}