// src/handlers/user.rs
// FIXED: Convertito da Extension a State per Axum 0.6

use axum::{
    extract::{Path, State, Multipart}, // FIXED: State invece di Extension
    http::StatusCode,
    Json,
};
use chrono::{DateTime, Utc};
use serde::Serialize;
use uuid::Uuid;
use validator::Validate;

use crate::auth::Claims;
use crate::models::user::{
    User, Role, NewUser, UpdateUser, UpdateProfileRequest, ChangePasswordRequest,
    UserSession, ReputationEvent, SecuritySettings, UpdateSecuritySettingsRequest
};

use crate::state::AppState;

#[derive(Serialize)]
pub struct ErrorResponse {
    error: String,
}

#[derive(Serialize)]
pub struct UserResponse {
    id: Uuid,
    username: String,
    email: String,
    role: String,
    reputation_score: i32, // FIXED: i32 invece di Option<i32>
    avatar_url: Option<String>,
    last_login: Option<DateTime<Utc>>,
    two_factor_enabled: bool,
    phone_number: Option<String>,
    bio: Option<String>,
    preferred_language: Option<String>,
    skills: Option<Vec<String>>,
    email_verified: bool,
    created_at: DateTime<Utc>,
    updated_at: DateTime<Utc>,
}

impl From<User> for UserResponse {
    fn from(user: User) -> Self {
        Self {
            id: user.id,
            username: user.username,
            email: user.email,
            role: user.role.as_str().to_string(),
            reputation_score: user.reputation_score.unwrap_or(0), // FIXED: gestione Option
            avatar_url: user.avatar_url,
            last_login: user.last_login,
            two_factor_enabled: user.two_factor_enabled.unwrap_or(false),
            phone_number: user.phone_number,
            bio: user.bio,
            preferred_language: user.preferred_language,
            skills: user.skills,
            email_verified: user.email_verified,
            created_at: user.created_at,
            updated_at: user.updated_at,
        }
    }
}

// Get current user profile - FIXED: State
pub async fn get_current_user(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    claims: Claims,
) -> Result<Json<UserResponse>, (StatusCode, Json<ErrorResponse>)> {
    let user_id = claims.sub.parse::<Uuid>().map_err(|_| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: "Invalid user ID".to_string(),
        }),
    ))?;

    let user = sqlx::query_as!(
        User,
        r#"
        SELECT id, username, email, password_hash, role as "role: Role",
               reputation_score, avatar_url, last_login, failed_login_attempts,
               account_locked_until, two_factor_enabled, two_factor_secret,
               phone_number, bio, preferred_language,
               email_verified, email_verification_token, email_verification_sent_at,
                  email_verification_expires_at, email_verification_skipped, skills,
               created_at, updated_at
        FROM users
        WHERE id = $1
        "#,
        user_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "User not found".to_string(),
        }),
    ))?;

    Ok(Json(UserResponse::from(user)))
}

// Update current user profile - FIXED: State
pub async fn update_current_user(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    claims: Claims,
    Json(update_data): Json<UpdateProfileRequest>,
) -> Result<Json<UserResponse>, (StatusCode, Json<ErrorResponse>)> {
    // Validate input
    update_data.validate().map_err(|e| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: format!("Validation error: {}", e),
        }),
    ))?;

    let user_id = claims.sub.parse::<Uuid>().map_err(|_| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: "Invalid user ID".to_string(),
        }),
    ))?;

    let user = sqlx::query_as!(
        User,
        r#"
        UPDATE users
        SET 
            username = COALESCE($2, username),
            email = COALESCE($3, email),
            phone_number = $4,
            bio = $5,
            preferred_language = $6,
            updated_at = NOW()
        WHERE id = $1
        RETURNING id, username, email, password_hash, role as "role: Role",
                  reputation_score, avatar_url, last_login, failed_login_attempts,
                  account_locked_until, two_factor_enabled, two_factor_secret,
                  phone_number, bio, preferred_language,
                  email_verified, email_verification_token, email_verification_sent_at,
                  email_verification_expires_at, email_verification_skipped, skills,
                  created_at, updated_at
        "#,
        user_id,
        update_data.username,
        update_data.email,
        update_data.phone_number,
        update_data.bio,
        update_data.preferred_language
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to update user: {}", e),
        }),
    ))?;

    Ok(Json(UserResponse::from(user)))
}

// Change password - FIXED: State
pub async fn change_password(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    claims: Claims,
    Json(password_data): Json<ChangePasswordRequest>,
) -> Result<StatusCode, (StatusCode, Json<ErrorResponse>)> {
    // Validate input
    password_data.validate().map_err(|e| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: format!("Validation error: {}", e),
        }),
    ))?;

    let user_id = claims.sub.parse::<Uuid>().map_err(|_| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: "Invalid user ID".to_string(),
        }),
    ))?;

    // Get current user to verify password
    let user = sqlx::query!(
        "SELECT password_hash FROM users WHERE id = $1",
        user_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "User not found".to_string(),
        }),
    ))?;

    // Verify current password
    let is_valid = app_state.auth.verify_password(&password_data.current_password, &user.password_hash)
        .map_err(|_| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Password verification failed".to_string(),
            }),
        ))?;

    if !is_valid {
        return Err((
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: "Current password is incorrect".to_string(),
            }),
        ));
    }

    // Hash new password
    let new_password_hash = app_state.auth.hash_password(&password_data.new_password)
        .map_err(|e| (
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: format!("Password validation failed: {}", e),
            }),
        ))?;

    // Update password
    sqlx::query!(
        "UPDATE users SET password_hash = $1, updated_at = NOW() WHERE id = $2",
        new_password_hash,
        user_id
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to update password: {}", e),
        }),
    ))?;

    // Audit: Password changed
    crate::audit::audit(crate::audit::AuditAction::PasswordChanged)
        .user_id(user_id)
        .entity("user", user_id)
        .log_async((*app_state.pool).clone());

    Ok(StatusCode::NO_CONTENT)
}

// Update security settings - FIXED: State
pub async fn update_security_settings(
    State(app_state): State<AppState>,
    claims: Claims,
    Json(settings_data): Json<UpdateSecuritySettingsRequest>,
) -> Result<Json<UserResponse>, (StatusCode, Json<ErrorResponse>)> {
    let user_id = claims.sub.parse::<Uuid>().map_err(|_| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: "Invalid user ID".to_string(),
        }),
    ))?;

    // Fetch old user for audit logging
    let old_user = sqlx::query_as!(
        User,
        r#"
        SELECT id, username, email, password_hash, role as "role: Role",
               reputation_score, avatar_url, last_login, failed_login_attempts,
               account_locked_until, two_factor_enabled, two_factor_secret,
               phone_number, bio, preferred_language, email_verified,
               email_verification_token, email_verification_sent_at,
               email_verification_expires_at, email_verification_skipped, skills,
               created_at, updated_at
        FROM users
        WHERE id = $1
        "#,
        user_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "User not found".to_string(),
        }),
    ))?;

    // Update security settings
    let user = sqlx::query_as!(
        User,
        r#"
        UPDATE users
        SET
            two_factor_enabled = COALESCE($2, two_factor_enabled),
            updated_at = NOW()
        WHERE id = $1
        RETURNING id, username, email, password_hash, role as "role: Role",
                  reputation_score, avatar_url, last_login, failed_login_attempts,
                  account_locked_until, two_factor_enabled, two_factor_secret,
                  phone_number, bio, preferred_language, email_verified,
                  email_verification_token, email_verification_sent_at,
                  email_verification_expires_at, email_verification_skipped, skills,
                  created_at, updated_at
        "#,
        user_id,
        settings_data.two_factor_enabled
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to update security settings: {}", e),
        }),
    ))?;

    // Audit: Security settings updated
    crate::audit::audit(crate::audit::AuditAction::UserUpdated)
        .user_id(user_id)
        .entity("user", user_id)
        .old_values(&old_user)
        .new_values(&user)
        .log_async((*app_state.pool).clone());

    Ok(Json(UserResponse::from(user)))
}

// Upload avatar - FIXED: State
pub async fn upload_avatar(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    claims: Claims,
    mut multipart: Multipart,
) -> Result<Json<serde_json::Value>, (StatusCode, Json<ErrorResponse>)> {
    let user_id = claims.sub.parse::<Uuid>().map_err(|_| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: "Invalid user ID".to_string(),
        }),
    ))?;

    while let Some(field) = multipart.next_field().await.map_err(|e| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: format!("Failed to read multipart data: {}", e),
        }),
    ))? {
        if field.name() == Some("avatar") {
            let filename = field.file_name()
                .unwrap_or("avatar.jpg")
                .to_string();
            
            let data = field.bytes().await.map_err(|e| (
                StatusCode::BAD_REQUEST,
                Json(ErrorResponse {
                    error: format!("Failed to read file data: {}", e),
                }),
            ))?;

            // Basic validation
            if data.len() > 5 * 1024 * 1024 { // 5MB limit
                return Err((
                    StatusCode::BAD_REQUEST,
                    Json(ErrorResponse {
                        error: "File too large (max 5MB)".to_string(),
                    }),
                ));
            }

            // Validate file type (check extension)
            let ext = std::path::Path::new(&filename)
                .extension()
                .and_then(|s| s.to_str())
                .unwrap_or("")
                .to_lowercase();

            if !["jpg", "jpeg", "png", "gif", "webp"].contains(&ext.as_str()) {
                return Err((
                    StatusCode::BAD_REQUEST,
                    Json(ErrorResponse {
                        error: "Invalid file type. Only jpg, png, gif, and webp are allowed".to_string(),
                    }),
                ));
            }

            // Create uploads directory if it doesn't exist
            let upload_dir = std::path::PathBuf::from("uploads/avatars");
            tokio::fs::create_dir_all(&upload_dir).await.map_err(|e| (
                StatusCode::INTERNAL_SERVER_ERROR,
                Json(ErrorResponse {
                    error: format!("Failed to create upload directory: {}", e),
                }),
            ))?;

            // Generate unique filename
            let unique_filename = format!("{}_{}.{}", user_id, uuid::Uuid::new_v4(), ext);
            let file_path = upload_dir.join(&unique_filename);

            // Save file to filesystem
            tokio::fs::write(&file_path, &data).await.map_err(|e| (
                StatusCode::INTERNAL_SERVER_ERROR,
                Json(ErrorResponse {
                    error: format!("Failed to save file: {}", e),
                }),
            ))?;

            let avatar_url = format!("/uploads/avatars/{}", unique_filename);

            // Update user avatar URL
            sqlx::query!(
                "UPDATE users SET avatar_url = $1, updated_at = NOW() WHERE id = $2",
                avatar_url,
                user_id
            )
            .execute(&*app_state.pool)
            .await
            .map_err(|e| (
                StatusCode::INTERNAL_SERVER_ERROR,
                Json(ErrorResponse {
                    error: format!("Failed to update avatar URL: {}", e),
                }),
            ))?;

            return Ok(Json(serde_json::json!({
                "avatar_url": avatar_url,
                "message": "Avatar uploaded successfully"
            })));
        }
    }

    Err((
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: "No avatar file found in request".to_string(),
        }),
    ))
}

// Get user sessions - FIXED: State
pub async fn get_user_sessions(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    claims: Claims,
) -> Result<Json<Vec<UserSession>>, (StatusCode, Json<ErrorResponse>)> {
    let user_id = claims.sub.parse::<Uuid>().map_err(|_| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: "Invalid user ID".to_string(),
        }),
    ))?;

    let sessions = sqlx::query_as!(
        UserSession,
        r#"
        SELECT id, user_id, session_token, ip_address, user_agent,
               device_info, created_at as "created_at!", last_activity as "last_activity!",
               expires_at as "expires_at!", is_active, revoked_at, revoked_reason
        FROM user_sessions
        WHERE user_id = $1 AND is_active = true
        ORDER BY last_activity DESC
        "#,
        user_id
    )
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to fetch sessions: {}", e),
        }),
    ))?;

    Ok(Json(sessions))
}

// Revoke session - FIXED: State
pub async fn revoke_session(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    claims: Claims,
    Path(session_id): Path<Uuid>,
) -> Result<StatusCode, (StatusCode, Json<ErrorResponse>)> {
    let user_id = claims.sub.parse::<Uuid>().map_err(|_| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: "Invalid user ID".to_string(),
        }),
    ))?;

    let result = sqlx::query!(
        r#"
        UPDATE user_sessions 
        SET is_active = false, revoked_at = NOW(), revoked_reason = 'user_revoked'
        WHERE id = $1 AND user_id = $2 AND is_active = true
        "#,
        session_id,
        user_id
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to revoke session: {}", e),
        }),
    ))?;

    if result.rows_affected() == 0 {
        return Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Session not found or already revoked".to_string(),
            }),
        ));
    }

    Ok(StatusCode::NO_CONTENT)
}

// Two-factor authentication functions - FIXED: State
pub async fn enable_two_factor(
    State(app_state): State<AppState>,
    claims: Claims,
) -> Result<Json<serde_json::Value>, (StatusCode, Json<ErrorResponse>)> { // FIXED: Added Json wrapper
    let user_id = claims.sub.parse::<Uuid>().map_err(|_| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: "Invalid user ID".to_string(),
        }),
    ))?;

    // Check if 2FA is already enabled
    let user = sqlx::query!(
        "SELECT two_factor_enabled FROM users WHERE id = $1",
        user_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "User not found".to_string(),
        }),
    ))?;

    if user.two_factor_enabled.unwrap_or(false) {
        return Err((
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: "2FA is already enabled".to_string(),
            }),
        ));
    }

    // Generate a new secret using crypto-safe random
    let mut random_bytes = [0u8; 32];
    for byte in &mut random_bytes {
        *byte = rand::random::<u8>();
    }
    let secret = base32::encode(base32::Alphabet::RFC4648 { padding: false }, &random_bytes);
    
    // Save the secret but don't enable 2FA yet (user needs to verify first)
    sqlx::query!(
        "UPDATE users SET two_factor_secret = $1, updated_at = NOW() WHERE id = $2",
        secret,
        user_id
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to save 2FA secret: {}", e),
        }),
    ))?;

    // Get user info for QR code generation
    let user_info = sqlx::query!(
        "SELECT username, email FROM users WHERE id = $1",
        user_id
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to get user info: {}", e),
        }),
    ))?;

    // Generate QR code URL for authenticator apps
    let issuer = "SentinelCore";
    let account_name = format!("{}:{}", issuer, user_info.username);
    let qr_url = format!(
        "otpauth://totp/{}?secret={}&issuer={}",
        urlencoding::encode(&account_name),
        secret,
        urlencoding::encode(issuer)
    );

    Ok(Json(serde_json::json!({
        "secret": secret,
        "qr_url": qr_url,
        "message": "Please scan the QR code with your authenticator app and then verify with a code to complete setup"
    })))
}

pub async fn disable_two_factor(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    claims: Claims,
) -> Result<StatusCode, (StatusCode, Json<ErrorResponse>)> {
    let user_id = claims.sub.parse::<Uuid>().map_err(|_| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: "Invalid user ID".to_string(),
        }),
    ))?;

    sqlx::query!(
        r#"
        UPDATE users 
        SET two_factor_enabled = false, two_factor_secret = NULL, updated_at = NOW()
        WHERE id = $1
        "#,
        user_id
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to disable 2FA: {}", e),
        }),
    ))?;

    Ok(StatusCode::NO_CONTENT)
}


pub async fn verify_two_factor(
    State(app_state): State<AppState>,
    claims: Claims,
    Json(totp_code): Json<String>,
) -> Result<Json<serde_json::Value>, (StatusCode, Json<ErrorResponse>)> {
    let user_id = claims.sub.parse::<Uuid>().map_err(|_| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: "Invalid user ID".to_string(),
        }),
    ))?;

    let user = sqlx::query!(
        "SELECT two_factor_secret FROM users WHERE id = $1",
        user_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "User not found".to_string(),
        }),
    ))?;

    let secret = user.two_factor_secret.ok_or_else(|| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: "2FA not set up".to_string(),
        }),
    ))?;

    // Verify TOTP code
    let secret_bytes = base32::decode(base32::Alphabet::RFC4648 { padding: true }, &secret)
        .ok_or_else(|| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Invalid 2FA secret".to_string(),
            }),
        ))?;

    // FIXED: Specify SHA1 as the hash algorithm explicitly
    let is_valid = totp_lite::totp::<sha1::Sha1>(&secret_bytes, 30) == totp_code;

    if is_valid {
        // Enable 2FA
        sqlx::query!(
            "UPDATE users SET two_factor_enabled = true, updated_at = NOW() WHERE id = $1",
            user_id
        )
        .execute(&*app_state.pool)
        .await
        .map_err(|e| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Failed to enable 2FA: {}", e),
            }),
        ))?;

        Ok(Json(serde_json::json!({
            "success": true,
            "message": "2FA enabled successfully"
        })))
    } else {
        Err((
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: "Invalid verification code".to_string(),
            }),
        ))
    }
}

// Security settings - FIXED: State
pub async fn get_security_settings(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    claims: Claims,
) -> Result<Json<SecuritySettings>, (StatusCode, Json<ErrorResponse>)> {
    let user_id = claims.sub.parse::<Uuid>().map_err(|_| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: "Invalid user ID".to_string(),
        }),
    ))?;

    let user = sqlx::query!(
        "SELECT two_factor_enabled FROM users WHERE id = $1",
        user_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "User not found".to_string(),
        }),
    ))?;

    // In a real implementation, these would be user-configurable
    let settings = SecuritySettings {
        two_factor_enabled: user.two_factor_enabled.unwrap_or(false),
        session_timeout: 24 * 60, // 24 hours in minutes
        ip_whitelist_enabled: false,
        allowed_ips: vec![],
        password_expiry_days: None,
        require_password_change: false,
    };

    Ok(Json(settings))
}

// Reputation events - FIXED: State
pub async fn get_reputation_events(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    claims: Claims,
) -> Result<Json<Vec<ReputationEvent>>, (StatusCode, Json<ErrorResponse>)> {
    let user_id = claims.sub.parse::<Uuid>().map_err(|_| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: "Invalid user ID".to_string(),
        }),
    ))?;

    let events = sqlx::query_as!(
        ReputationEvent,
        r#"
        SELECT id, user_id, event_type, points, description,
               related_entity_type, related_entity_id, created_at as "created_at!"
        FROM reputation_events
        WHERE user_id = $1
        ORDER BY created_at DESC
        LIMIT 50
        "#,
        user_id
    )
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to fetch reputation events: {}", e),
        }),
    ))?;

    Ok(Json(events))
}

// Admin functions - FIXED: State
pub async fn list_users(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    _claims: Claims,
) -> Result<Json<Vec<UserResponse>>, (StatusCode, Json<ErrorResponse>)> {
    let users = sqlx::query_as!(
        User,
        r#"
        SELECT id, username, email, password_hash, role as "role: Role",
               reputation_score, avatar_url, last_login, failed_login_attempts,
               account_locked_until, two_factor_enabled, two_factor_secret,
               phone_number, bio, preferred_language,
               email_verified, email_verification_token, email_verification_sent_at,
                  email_verification_expires_at, email_verification_skipped, skills,
               created_at, updated_at
        FROM users
        ORDER BY created_at DESC
        "#
    )
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to fetch users: {}", e),
        }),
    ))?;

    let user_responses: Vec<UserResponse> = users.into_iter()
        .map(UserResponse::from)
        .collect();

    Ok(Json(user_responses))
}

pub async fn create_user(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    claims: Claims,
    Json(new_user): Json<NewUser>,
) -> Result<Json<UserResponse>, (StatusCode, Json<ErrorResponse>)> {
    let password_hash = app_state.auth.hash_password(&new_user.password)
        .map_err(|e| (
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: format!("Password validation failed: {}", e),
            }),
        ))?;

    let role = new_user.role.unwrap_or(Role::User);
    let skip_verification = new_user.skip_email_verification.unwrap_or(false);
    let skills = new_user.skills.as_ref().map(|s| s.as_slice());

    // Generate email verification token (only if not skipping)
    let (email_verified, verification_token, verification_expires_at, email_verification_skipped) = if skip_verification {
        (true, None, None, true)
    } else {
        let token = format!("verify_{}", Uuid::new_v4());
        let expires = Utc::now() + chrono::Duration::hours(24);
        (false, Some(token), Some(expires), false)
    };

    let user = sqlx::query_as!(
        User,
        r#"
        INSERT INTO users (username, email, password_hash, role, email_verified,
                          email_verification_token, email_verification_sent_at,
                          email_verification_expires_at, email_verification_skipped, skills)
        VALUES ($1, $2, $3, $4, $5, $6, NOW(), $7, $8, $9)
        RETURNING id, username, email, password_hash, role as "role: Role",
                  reputation_score, avatar_url, last_login, failed_login_attempts,
                  account_locked_until, two_factor_enabled, two_factor_secret,
                  phone_number, bio, preferred_language,
                  email_verified, email_verification_token, email_verification_sent_at,
                  email_verification_expires_at, email_verification_skipped, skills,
                  created_at, updated_at
        "#,
        new_user.username,
        new_user.email,
        password_hash,
        role as _,
        email_verified,
        verification_token,
        verification_expires_at,
        email_verification_skipped,
        skills
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| {
        let error_message = if e.to_string().contains("duplicate key") {
            "Username or email already exists".to_string()
        } else {
            format!("Failed to create user: {}", e)
        };
        (
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse { error: error_message }),
        )
    })?;

    // TODO: Send verification email here
    // For now, log the token (in production, this should be sent via email)
    if !skip_verification {
        if let (Some(token), Some(expires)) = (&verification_token, &verification_expires_at) {
            tracing::info!(
                "Email verification token for {}: {} (expires at {})",
                user.email,
                token,
                expires
            );
        }
    } else {
        tracing::info!("Email verification skipped for user: {}", user.email);
    }

    // Audit: User created
    let creator_id = claims.sub.parse::<Uuid>().ok();
    if let Some(cid) = creator_id {
        crate::audit::audit(crate::audit::AuditAction::UserCreated)
            .user_id(cid)
            .entity("user", user.id)
            .new_values(&serde_json::json!({
                "username": user.username,
                "email": user.email,
                "role": user.role.as_str(),
                "email_verified": false
            }))
            .log_async((*app_state.pool).clone());
    }

    Ok(Json(UserResponse::from(user)))
}

pub async fn get_user(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    _claims: Claims,
    Path(user_id): Path<Uuid>,
) -> Result<Json<UserResponse>, (StatusCode, Json<ErrorResponse>)> {
    let user = sqlx::query_as!(
        User,
        r#"
        SELECT id, username, email, password_hash, role as "role: Role",
               reputation_score, avatar_url, last_login, failed_login_attempts,
               account_locked_until, two_factor_enabled, two_factor_secret,
               phone_number, bio, preferred_language,
               email_verified, email_verification_token, email_verification_sent_at,
                  email_verification_expires_at, email_verification_skipped, skills,
               created_at, updated_at
        FROM users
        WHERE id = $1
        "#,
        user_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "User not found".to_string(),
        }),
    ))?;

    Ok(Json(UserResponse::from(user)))
}

pub async fn update_user(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    claims: Claims,
    Path(user_id): Path<Uuid>,
    Json(update_data): Json<UpdateUser>,
) -> Result<Json<UserResponse>, (StatusCode, Json<ErrorResponse>)> {
    // Fetch old user for audit logging
    let old_user = sqlx::query_as!(
        User,
        r#"
        SELECT id, username, email, password_hash, role as "role: Role",
               reputation_score, avatar_url, last_login, failed_login_attempts,
               account_locked_until, two_factor_enabled, two_factor_secret,
               phone_number, bio, preferred_language,
               email_verified, email_verification_token, email_verification_sent_at,
                  email_verification_expires_at, email_verification_skipped, skills,
               created_at, updated_at
        FROM users
        WHERE id = $1
        "#,
        user_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "User not found".to_string(),
        }),
    ))?;

    let password_hash = if let Some(password) = update_data.password {
        Some(app_state.auth.hash_password(&password)
            .map_err(|e| (
                StatusCode::BAD_REQUEST,
                Json(ErrorResponse {
                    error: format!("Password validation failed: {}", e),
                }),
            ))?)
    } else {
        None
    };

    let skills = update_data.skills.as_ref().map(|s| s.as_slice());

    let user = sqlx::query_as!(
        User,
        r#"
        UPDATE users
        SET
            username = COALESCE($2, username),
            email = COALESCE($3, email),
            password_hash = COALESCE($4, password_hash),
            role = COALESCE($5, role),
            skills = COALESCE($6, skills),
            updated_at = NOW()
        WHERE id = $1
        RETURNING id, username, email, password_hash, role as "role: Role",
                  reputation_score, avatar_url, last_login, failed_login_attempts,
                  account_locked_until, two_factor_enabled, two_factor_secret,
                  phone_number, bio, preferred_language,
                  email_verified, email_verification_token, email_verification_sent_at,
                  email_verification_expires_at, email_verification_skipped, skills,
                  created_at, updated_at
        "#,
        user_id,
        update_data.username,
        update_data.email,
        password_hash,
        update_data.role as _,
        skills
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to update user: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "User not found".to_string(),
        }),
    ))?;

    // Audit: User updated
    let updater_id = claims.sub.parse::<Uuid>().ok();
    if let Some(uid) = updater_id {
        crate::audit::audit(crate::audit::AuditAction::UserUpdated)
            .user_id(uid)
            .entity("user", user.id)
            .old_values(&serde_json::json!({
                "username": old_user.username,
                "email": old_user.email,
                "role": old_user.role.as_str()
            }))
            .new_values(&serde_json::json!({
                "username": user.username,
                "email": user.email,
                "role": user.role.as_str()
            }))
            .log_async((*app_state.pool).clone());
    }

    Ok(Json(UserResponse::from(user)))
}

pub async fn delete_user(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    claims: Claims,
    Path(user_id): Path<Uuid>,
)-> Result<StatusCode, (StatusCode, Json<ErrorResponse>)> {
    // Soft delete: set deleted_at timestamp
    let result = sqlx::query!(
        "UPDATE users SET deleted_at = NOW(), updated_at = NOW() WHERE id = $1 AND deleted_at IS NULL",
        user_id
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to delete user: {}", e),
        }),
    ))?;

    if result.rows_affected() == 0 {
        return Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "User not found or already deleted".to_string(),
            }),
        ));
    }

    // Audit: User deleted
    let deleter_id = claims.sub.parse::<Uuid>().ok();
    if let Some(did) = deleter_id {
        crate::audit::audit(crate::audit::AuditAction::UserDeleted)
            .user_id(did)
            .entity("user", user_id)
            .log_async((*app_state.pool).clone());
    }

    Ok(StatusCode::NO_CONTENT)
}

pub async fn lock_user(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    _claims: Claims,
    Path(user_id): Path<Uuid>,
) -> Result<StatusCode, (StatusCode, Json<ErrorResponse>)> {
    let lock_until = chrono::Utc::now() + chrono::Duration::hours(24);
    
    sqlx::query!(
        "UPDATE users SET account_locked_until = $1, updated_at = NOW() WHERE id = $2",
        lock_until,
        user_id
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to lock user: {}", e),
        }),
    ))?;

    Ok(StatusCode::NO_CONTENT)
}

pub async fn unlock_user(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    _claims: Claims,
    Path(user_id): Path<Uuid>,
) -> Result<StatusCode, (StatusCode, Json<ErrorResponse>)> {
    sqlx::query!(
        "UPDATE users SET account_locked_until = NULL, failed_login_attempts = 0, updated_at = NOW() WHERE id = $1",
        user_id
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to unlock user: {}", e),
        }),
    ))?;

    Ok(StatusCode::NO_CONTENT)
}

pub async fn get_user_sessions_admin(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    _claims: Claims,
    Path(user_id): Path<Uuid>,
) -> Result<Json<Vec<UserSession>>, (StatusCode, Json<ErrorResponse>)> {
    let sessions = sqlx::query_as!(
        UserSession,
        r#"
        SELECT id, user_id, session_token, ip_address, user_agent,
               device_info, created_at as "created_at!", last_activity as "last_activity!",
               expires_at as "expires_at!", is_active, revoked_at, revoked_reason
        FROM user_sessions
        WHERE user_id = $1
        ORDER BY last_activity DESC
        "#,
        user_id
    )
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to fetch sessions: {}", e),
        }),
    ))?;

    Ok(Json(sessions))
}

pub async fn revoke_all_user_sessions(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    _claims: Claims,
    Path(user_id): Path<Uuid>,
) -> Result<StatusCode, (StatusCode, Json<ErrorResponse>)> {
    sqlx::query!(
        r#"
        UPDATE user_sessions
        SET is_active = false, revoked_at = NOW(), revoked_reason = 'admin_revoked'
        WHERE user_id = $1 AND is_active = true
        "#,
        user_id
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to revoke sessions: {}", e),
        }),
    ))?;

    Ok(StatusCode::NO_CONTENT)
}

// ==================== Notification Settings ====================

#[derive(serde::Deserialize, serde::Serialize)]
pub struct NotificationSettings {
    pub email_enabled: bool,
    pub push_enabled: bool,
    pub critical_alerts: bool,
    pub weekly_report: bool,
}

pub async fn get_notification_settings(
    State(app_state): State<AppState>,
    claims: Claims,
) -> Result<Json<NotificationSettings>, (StatusCode, Json<ErrorResponse>)> {
    let user_id = claims.sub.parse::<Uuid>().map_err(|_| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse { error: "Invalid user ID".to_string() }),
    ))?;

    let settings = sqlx::query_as!(
        NotificationSettings,
        r#"
        SELECT email_enabled, push_enabled, critical_alerts, weekly_report
        FROM user_notification_settings
        WHERE user_id = $1
        "#,
        user_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse { error: format!("Database error: {}", e) }),
    ))?;

    Ok(Json(settings.unwrap_or(NotificationSettings {
        email_enabled: true,
        push_enabled: false,
        critical_alerts: true,
        weekly_report: false,
    })))
}

pub async fn update_notification_settings(
    State(app_state): State<AppState>,
    claims: Claims,
    Json(settings): Json<NotificationSettings>,
) -> Result<Json<NotificationSettings>, (StatusCode, Json<ErrorResponse>)> {
    let user_id = claims.sub.parse::<Uuid>().map_err(|_| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse { error: "Invalid user ID".to_string() }),
    ))?;

    sqlx::query!(
        r#"
        INSERT INTO user_notification_settings (user_id, email_enabled, push_enabled, critical_alerts, weekly_report)
        VALUES ($1, $2, $3, $4, $5)
        ON CONFLICT (user_id) DO UPDATE SET
            email_enabled = $2,
            push_enabled = $3,
            critical_alerts = $4,
            weekly_report = $5,
            updated_at = NOW()
        "#,
        user_id,
        settings.email_enabled,
        settings.push_enabled,
        settings.critical_alerts,
        settings.weekly_report
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse { error: format!("Failed to update settings: {}", e) }),
    ))?;

    Ok(Json(settings))
}

// ==================== API Keys ====================

#[derive(serde::Serialize)]
pub struct ApiKeyResponse {
    pub id: Uuid,
    pub name: String,
    pub key_prefix: String,
    pub created_at: DateTime<Utc>,
    pub last_used_at: Option<DateTime<Utc>>,
    pub expires_at: Option<DateTime<Utc>>,
}

#[derive(serde::Serialize)]
pub struct NewApiKeyResponse {
    pub id: Uuid,
    pub name: String,
    pub key: String,
    pub created_at: DateTime<Utc>,
}

#[derive(serde::Deserialize)]
pub struct CreateApiKeyRequest {
    pub name: String,
    pub expires_in_days: Option<i32>,
}

pub async fn list_api_keys(
    State(app_state): State<AppState>,
    claims: Claims,
) -> Result<Json<Vec<ApiKeyResponse>>, (StatusCode, Json<ErrorResponse>)> {
    let user_id = claims.sub.parse::<Uuid>().map_err(|_| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse { error: "Invalid user ID".to_string() }),
    ))?;

    let keys = sqlx::query!(
        r#"
        SELECT id, name, key_prefix, created_at, last_used_at, expires_at
        FROM user_api_keys
        WHERE user_id = $1 AND (expires_at IS NULL OR expires_at > NOW())
        ORDER BY created_at DESC
        "#,
        user_id
    )
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse { error: format!("Database error: {}", e) }),
    ))?;

    let response: Vec<ApiKeyResponse> = keys
        .into_iter()
        .map(|k| ApiKeyResponse {
            id: k.id,
            name: k.name,
            key_prefix: k.key_prefix,
            created_at: k.created_at,
            last_used_at: k.last_used_at,
            expires_at: k.expires_at,
        })
        .collect();

    Ok(Json(response))
}

pub async fn create_api_key(
    State(app_state): State<AppState>,
    claims: Claims,
    Json(req): Json<CreateApiKeyRequest>,
) -> Result<Json<NewApiKeyResponse>, (StatusCode, Json<ErrorResponse>)> {
    let user_id = claims.sub.parse::<Uuid>().map_err(|_| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse { error: "Invalid user ID".to_string() }),
    ))?;

    use rand::Rng;
    let key: String = rand::thread_rng()
        .sample_iter(&rand::distributions::Alphanumeric)
        .take(48)
        .map(char::from)
        .collect();

    let key_prefix = format!("sk_{}", &key[..8]);
    let key_hash = format!("{:x}", md5::compute(&key));

    let expires_at = req.expires_in_days.map(|days| {
        Utc::now() + chrono::Duration::days(days as i64)
    });

    let id = Uuid::new_v4();
    let created_at = Utc::now();

    sqlx::query!(
        r#"
        INSERT INTO user_api_keys (id, user_id, name, key_hash, key_prefix, created_at, expires_at)
        VALUES ($1, $2, $3, $4, $5, $6, $7)
        "#,
        id,
        user_id,
        req.name,
        key_hash,
        key_prefix,
        created_at,
        expires_at
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse { error: format!("Failed to create API key: {}", e) }),
    ))?;

    Ok(Json(NewApiKeyResponse {
        id,
        name: req.name,
        key: format!("sk_{}", key),
        created_at,
    }))
}

pub async fn revoke_api_key(
    State(app_state): State<AppState>,
    claims: Claims,
    Path(key_id): Path<Uuid>,
) -> Result<StatusCode, (StatusCode, Json<ErrorResponse>)> {
    let user_id = claims.sub.parse::<Uuid>().map_err(|_| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse { error: "Invalid user ID".to_string() }),
    ))?;

    let result = sqlx::query!(
        r#"DELETE FROM user_api_keys WHERE id = $1 AND user_id = $2"#,
        key_id,
        user_id
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse { error: format!("Failed to revoke API key: {}", e) }),
    ))?;

    if result.rows_affected() == 0 {
        return Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse { error: "API key not found".to_string() }),
        ));
    }

    Ok(StatusCode::NO_CONTENT)
}

pub async fn delete_avatar(
    State(app_state): State<AppState>,
    claims: Claims,
) -> Result<StatusCode, (StatusCode, Json<ErrorResponse>)> {
    let user_id = claims.sub.parse::<Uuid>().map_err(|_| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse { error: "Invalid user ID".to_string() }),
    ))?;

    let user = sqlx::query!(
        "SELECT avatar_url FROM users WHERE id = $1",
        user_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse { error: format!("Database error: {}", e) }),
    ))?;

    if let Some(user) = user {
        if let Some(avatar_url) = user.avatar_url {
            let file_path = format!(".{}", avatar_url);
            let _ = std::fs::remove_file(&file_path);
        }
    }

    sqlx::query!(
        "UPDATE users SET avatar_url = NULL, updated_at = NOW() WHERE id = $1",
        user_id
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse { error: format!("Failed to update user: {}", e) }),
    ))?;

    Ok(StatusCode::NO_CONTENT)
}
// Get skills catalog for skills selection
pub async fn get_skills_catalog(
    State(app_state): State<AppState>,
    _claims: Claims,
) -> Result<Json<Vec<serde_json::Value>>, (StatusCode, Json<ErrorResponse>)> {
    let skills = sqlx::query!(
        r#"
        SELECT name, category, description
        FROM skills_catalog
        ORDER BY category, name
        "#
    )
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse { error: format!("Failed to fetch skills: {}", e) }),
    ))?;

    let skills_json: Vec<serde_json::Value> = skills
        .into_iter()
        .map(|s| serde_json::json!({
            "name": s.name,
            "category": s.category,
            "description": s.description
        }))
        .collect();

    Ok(Json(skills_json))
}

// Get users without team assignment (for admin alerts)
pub async fn get_unassigned_users(
    State(app_state): State<AppState>,
    claims: Claims,
) -> Result<Json<Vec<serde_json::Value>>, (StatusCode, Json<ErrorResponse>)> {
    // Parse user_id from claims to verify they're admin or team_leader
    let requesting_user_id = claims.sub.parse::<Uuid>().map_err(|_| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse { error: "Invalid user ID".to_string() }),
    ))?;

    // Get requesting user's role
    let requesting_user = sqlx::query!(
        "SELECT role::TEXT as role FROM users WHERE id = $1",
        requesting_user_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse { error: format!("Database error: {}", e) }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse { error: "User not found".to_string() }),
    ))?;

    // Only admin and team_leader can see unassigned users
    if requesting_user.role != Some("admin".to_string()) && requesting_user.role != Some("team_leader".to_string()) {
        return Err((
            StatusCode::FORBIDDEN,
            Json(ErrorResponse { error: "Only admins and team leaders can view unassigned users".to_string() }),
        ));
    }

    // Find users with role 'user' or 'team_leader' that are NOT in team_members
    let unassigned_users = sqlx::query!(
        r#"
        SELECT u.id, u.username, u.email, u.role::TEXT as role, u.created_at
        FROM users u
        LEFT JOIN team_members tm ON u.id = tm.user_id
        WHERE tm.user_id IS NULL
          AND u.role IN ('user', 'team_leader')
          AND u.deleted_at IS NULL
        ORDER BY u.created_at DESC
        "#
    )
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse { error: format!("Failed to fetch unassigned users: {}", e) }),
    ))?;

    let result: Vec<serde_json::Value> = unassigned_users
        .into_iter()
        .map(|u| serde_json::json!({
            "id": u.id,
            "username": u.username,
            "email": u.email,
            "role": u.role,
            "created_at": u.created_at
        }))
        .collect();

    Ok(Json(result))
}
