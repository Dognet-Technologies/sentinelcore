// src/handlers/auto_assignment.rs
// Auto-assignment engine for vulnerabilities based on skills

use axum::{
    extract::{State},
    http::StatusCode,
    Json,
};
use serde::{Deserialize, Serialize};
use uuid::Uuid;
use chrono::Utc;
use sqlx::types::BigDecimal;
use std::str::FromStr;

use crate::auth::Claims;
use crate::state::AppState;

#[derive(Serialize)]
pub struct ErrorResponse {
    error: String,
}

#[derive(Serialize)]
pub struct AutoAssignmentResult {
    job_id: Uuid,
    vulnerabilities_processed: i32,
    vulnerabilities_assigned: i32,
    status: String,
    message: String,
}

#[derive(Debug)]
struct UnassignedVuln {
    id: Uuid,
    cve_id: Option<String>,
    title: String,
    description: Option<String>,
    severity: String,
    discovered_at: chrono::DateTime<Utc>,
}

#[derive(Debug)]
struct UserWithSkills {
    id: Uuid,
    username: String,
    skills: Vec<String>,
}

#[derive(Debug)]
struct TeamWithSkills {
    id: Uuid,
    name: String,
    skills: Vec<String>,
}

// Run auto-assignment for unassigned vulnerabilities
pub async fn run_auto_assignment(
    State(app_state): State<AppState>,
    claims: Claims,
) -> Result<Json<AutoAssignmentResult>, (StatusCode, Json<ErrorResponse>)> {
    let user_id = claims.sub.parse::<Uuid>().map_err(|_| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse { error: "Invalid user ID".to_string() }),
    ))?;

    // Check if auto-assignment is enabled
    let enabled = sqlx::query_scalar::<_, String>(
        "SELECT setting_value FROM system_settings WHERE setting_key = 'auto_assignment_enabled'"
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse { error: format!("Failed to check settings: {}", e) }),
    ))?
    .unwrap_or_else(|| "false".to_string());

    if enabled != "true" {
        return Err((
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse { error: "Auto-assignment is disabled in system settings".to_string() }),
        ));
    }

    // Get delay days from settings
    let delay_days = sqlx::query_scalar::<_, String>(
        "SELECT setting_value FROM system_settings WHERE setting_key = 'auto_assignment_delay_days'"
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse { error: format!("Failed to get delay setting: {}", e) }),
    ))?
    .unwrap_or_else(|| "7".to_string())
    .parse::<i32>()
    .unwrap_or(7);

    // Create auto-assignment job record
    let job_id = Uuid::new_v4();
    sqlx::query!(
        r#"
        INSERT INTO auto_assignment_jobs (id, triggered_by, trigger_type, status)
        VALUES ($1, $2, 'manual', 'running')
        "#,
        job_id,
        user_id
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse { error: format!("Failed to create job: {}", e) }),
    ))?;

    // Find vulnerabilities that need assignment
    // (unassigned, older than delay_days, status = 'open')
    let cutoff_date = Utc::now() - chrono::Duration::days(delay_days as i64);

    let unassigned_vulns = sqlx::query_as!(
        UnassignedVuln,
        r#"
        SELECT id, cve_id, title, description, severity::TEXT as "severity!", discovered_at
        FROM vulnerabilities
        WHERE assigned_user_id IS NULL
          AND assigned_team_id IS NULL
          AND status = 'open'
          AND discovered_at <= $1
        ORDER BY severity DESC, discovered_at ASC
        LIMIT 100
        "#,
        cutoff_date
    )
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse { error: format!("Failed to fetch unassigned vulnerabilities: {}", e) }),
    ))?;

    let mut vulnerabilities_assigned = 0;
    let vulnerabilities_processed = unassigned_vulns.len() as i32;

    // Get users with skills
    let users_with_skills = sqlx::query!(
        r#"
        SELECT u.id, u.username, u.skills
        FROM users u
        INNER JOIN team_members tm ON u.id = tm.user_id
        WHERE u.skills IS NOT NULL
          AND array_length(u.skills, 1) > 0
          AND u.deleted_at IS NULL
        "#
    )
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse { error: format!("Failed to fetch users with skills: {}", e) }),
    ))?
    .into_iter()
    .map(|row| UserWithSkills {
        id: row.id,
        username: row.username,
        skills: row.skills.unwrap_or_default(),
    })
    .collect::<Vec<_>>();

    // Get teams with skills
    let teams_with_skills = sqlx::query!(
        r#"
        SELECT id, name, skills
        FROM teams
        WHERE skills IS NOT NULL
          AND array_length(skills, 1) > 0
        "#
    )
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse { error: format!("Failed to fetch teams with skills: {}", e) }),
    ))?
    .into_iter()
    .map(|row| TeamWithSkills {
        id: row.id,
        name: row.name,
        skills: row.skills.unwrap_or_default(),
    })
    .collect::<Vec<_>>();

    // Process each vulnerability
    for vuln in unassigned_vulns {
        let matched = match_vulnerability_to_user_or_team(
            &vuln,
            &users_with_skills,
            &teams_with_skills,
        );

        if let Some((assignment_type, entity_id, matched_skills, confidence, reason)) = matched {
            // Perform assignment
            match assignment_type.as_str() {
                "user" => {
                    // Assign to user
                    sqlx::query!(
                        "UPDATE vulnerabilities SET assigned_user_id = $1, updated_at = NOW() WHERE id = $2",
                        entity_id,
                        vuln.id
                    )
                    .execute(&*app_state.pool)
                    .await
                    .ok();

                    // Record in history
                    let confidence_decimal = BigDecimal::from_str(&format!("{:.2}", confidence))
                        .unwrap_or_else(|_| BigDecimal::from_str("0").unwrap());
                    sqlx::query!(
                        r#"
                        INSERT INTO auto_assignment_history
                        (job_id, vulnerability_id, assigned_to_user_id, matched_skills, assignment_reason, confidence_score)
                        VALUES ($1, $2, $3, $4, $5, $6)
                        "#,
                        job_id,
                        vuln.id,
                        entity_id,
                        &matched_skills[..],
                        reason,
                        confidence_decimal
                    )
                    .execute(&*app_state.pool)
                    .await
                    .ok();

                    vulnerabilities_assigned += 1;
                },
                "team" => {
                    // Assign to team
                    sqlx::query!(
                        "UPDATE vulnerabilities SET assigned_team_id = $1, updated_at = NOW() WHERE id = $2",
                        entity_id,
                        vuln.id
                    )
                    .execute(&*app_state.pool)
                    .await
                    .ok();

                    // Record in history
                    let confidence_decimal = BigDecimal::from_str(&format!("{:.2}", confidence))
                        .unwrap_or_else(|_| BigDecimal::from_str("0").unwrap());
                    sqlx::query!(
                        r#"
                        INSERT INTO auto_assignment_history
                        (job_id, vulnerability_id, assigned_to_team_id, matched_skills, assignment_reason, confidence_score)
                        VALUES ($1, $2, $3, $4, $5, $6)
                        "#,
                        job_id,
                        vuln.id,
                        entity_id,
                        &matched_skills[..],
                        reason,
                        confidence_decimal
                    )
                    .execute(&*app_state.pool)
                    .await
                    .ok();

                    vulnerabilities_assigned += 1;
                },
                _ => {}
            }
        }
    }

    // Update job status
    sqlx::query!(
        r#"
        UPDATE auto_assignment_jobs
        SET status = 'completed',
            completed_at = NOW(),
            vulnerabilities_processed = $2,
            vulnerabilities_assigned = $3
        WHERE id = $1
        "#,
        job_id,
        vulnerabilities_processed,
        vulnerabilities_assigned
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse { error: format!("Failed to update job: {}", e) }),
    ))?;

    Ok(Json(AutoAssignmentResult {
        job_id,
        vulnerabilities_processed,
        vulnerabilities_assigned,
        status: "completed".to_string(),
        message: format!("Auto-assignment completed: {} vulnerabilities assigned out of {} processed", vulnerabilities_assigned, vulnerabilities_processed),
    }))
}

// Match vulnerability to best user or team based on skills
fn match_vulnerability_to_user_or_team(
    vuln: &UnassignedVuln,
    users: &[UserWithSkills],
    teams: &[TeamWithSkills],
) -> Option<(String, Uuid, Vec<String>, f64, String)> {
    // Extract keywords from vulnerability
    let vuln_keywords = extract_keywords_from_vulnerability(vuln);

    let mut best_match: Option<(String, Uuid, Vec<String>, f64, String)> = None;
    let mut best_score = 0.0;

    // Try matching with users first (more specific)
    for user in users {
        let (score, matched_skills) = calculate_match_score(&vuln_keywords, &user.skills);
        if score > best_score {
            best_score = score;
            let reason = format!(
                "User {} has matching skills: {}",
                user.username,
                matched_skills.join(", ")
            );
            best_match = Some(("user".to_string(), user.id, matched_skills.clone(), score, reason));
        }
    }

    // Try matching with teams (fallback to broader assignment)
    for team in teams {
        let (score, matched_skills) = calculate_match_score(&vuln_keywords, &team.skills);
        // Teams need slightly lower threshold (0.8x) since they're broader
        let adjusted_score = score * 0.8;
        if adjusted_score > best_score {
            best_score = adjusted_score;
            let reason = format!(
                "Team {} has matching skills: {}",
                team.name,
                matched_skills.join(", ")
            );
            best_match = Some(("team".to_string(), team.id, matched_skills.clone(), score, reason));
        }
    }

    // Only return match if confidence is above threshold (30%)
    if best_score >= 30.0 {
        best_match
    } else {
        None
    }
}

// Extract keywords from vulnerability for matching
fn extract_keywords_from_vulnerability(vuln: &UnassignedVuln) -> Vec<String> {
    let mut keywords = Vec::new();
    let text = format!(
        "{} {} {}",
        vuln.title,
        vuln.description.as_deref().unwrap_or(""),
        vuln.cve_id.as_deref().unwrap_or("")
    ).to_lowercase();

    // Common technology keywords
    let tech_keywords = [
        "web", "api", "database", "sql", "kubernetes", "k8s", "docker", "container",
        "cloud", "aws", "azure", "gcp", "network", "firewall", "authentication",
        "auth", "oauth", "jwt", "crypto", "encryption", "ssl", "tls", "mobile",
        "android", "ios", "windows", "linux", "scada", "iot", "webapp",
    ];

    for keyword in &tech_keywords {
        if text.contains(keyword) {
            keywords.push(keyword.to_string());
        }
    }

    keywords
}

// Calculate match score between vulnerability keywords and user/team skills
fn calculate_match_score(vuln_keywords: &[String], skills: &[String]) -> (f64, Vec<String>) {
    if vuln_keywords.is_empty() || skills.is_empty() {
        return (0.0, vec![]);
    }

    let mut matched_skills = Vec::new();
    let mut matches = 0;

    for keyword in vuln_keywords {
        for skill in skills {
            if keyword.contains(skill) || skill.contains(keyword) {
                if !matched_skills.contains(skill) {
                    matched_skills.push(skill.clone());
                    matches += 1;
                }
            }
        }
    }

    // Score = (matches / total_keywords) * 100
    let score = (matches as f64 / vuln_keywords.len() as f64) * 100.0;
    (score, matched_skills)
}

// Get auto-assignment job history
pub async fn get_assignment_history(
    State(app_state): State<AppState>,
    _claims: Claims,
) -> Result<Json<Vec<serde_json::Value>>, (StatusCode, Json<ErrorResponse>)> {
    let jobs = sqlx::query!(
        r#"
        SELECT id, started_at, completed_at, status,
               vulnerabilities_processed, vulnerabilities_assigned,
               trigger_type, error_message
        FROM auto_assignment_jobs
        ORDER BY started_at DESC
        LIMIT 50
        "#
    )
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse { error: format!("Failed to fetch history: {}", e) }),
    ))?;

    let result: Vec<serde_json::Value> = jobs
        .into_iter()
        .map(|job| serde_json::json!({
            "id": job.id,
            "started_at": job.started_at,
            "completed_at": job.completed_at,
            "status": job.status,
            "vulnerabilities_processed": job.vulnerabilities_processed,
            "vulnerabilities_assigned": job.vulnerabilities_assigned,
            "trigger_type": job.trigger_type,
            "error_message": job.error_message
        }))
        .collect();

    Ok(Json(result))
}
