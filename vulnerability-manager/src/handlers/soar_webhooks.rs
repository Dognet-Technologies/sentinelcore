// src/handlers/soar_webhooks.rs
// SOAR Integration - Webhook automation for Splunk, Cortex, etc.

use axum::{
    extract::{Path, State},
    http::StatusCode,
    Json,
};
use serde::{Deserialize, Serialize};
use uuid::Uuid;
use chrono::{DateTime, Utc};

use crate::auth::Claims;
use crate::state::AppState;

#[derive(Debug, Serialize, Deserialize)]
pub struct WebhookConfig {
    pub id: Uuid,
    pub name: String,
    pub url: String,
    pub method: String, // POST, PUT
    pub headers: serde_json::Value,
    pub payload_template: String,
    pub trigger_on: Vec<String>, // Events: vulnerability_created, sla_breach, etc.
    pub is_enabled: bool,
    pub created_at: DateTime<Utc>,
}

#[derive(Debug, Deserialize)]
pub struct CreateWebhookRequest {
    pub name: String,
    pub url: String,
    pub method: Option<String>,
    pub headers: Option<serde_json::Value>,
    pub payload_template: String,
    pub trigger_on: Vec<String>,
}

#[derive(Debug, Serialize)]
pub struct WebhookExecutionLog {
    pub id: Uuid,
    pub webhook_id: Uuid,
    pub event_type: String,
    pub status: String, // success, failed
    pub response_code: Option<i32>,
    pub error_message: Option<String>,
    pub executed_at: DateTime<Utc>,
}

/// Create webhook configuration
pub async fn create_webhook(
    State(app_state): State<AppState>,
    claims: Claims,
    Json(payload): Json<CreateWebhookRequest>,
) -> Result<Json<WebhookConfig>, StatusCode> {
    let user_id = claims.sub.parse::<Uuid>().map_err(|_| StatusCode::BAD_REQUEST)?;

    let webhook = sqlx::query_as!(
        WebhookConfig,
        r#"
        INSERT INTO soar_webhooks (
            name, url, method, headers, payload_template, trigger_on, created_by
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7)
        RETURNING id, name, url, method, headers, payload_template, trigger_on, is_enabled, created_at
        "#,
        payload.name,
        payload.url,
        payload.method.unwrap_or_else(|| "POST".to_string()),
        payload.headers.unwrap_or(serde_json::json!({})),
        payload.payload_template,
        &payload.trigger_on,
        user_id
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    Ok(Json(webhook))
}

/// List webhooks
pub async fn list_webhooks(
    State(app_state): State<AppState>,
    _claims: Claims,
) -> Result<Json<Vec<WebhookConfig>>, StatusCode> {
    let webhooks = sqlx::query_as!(
        WebhookConfig,
        r#"
        SELECT id, name, url, method, headers, payload_template, trigger_on, is_enabled, created_at
        FROM soar_webhooks
        ORDER BY created_at DESC
        "#
    )
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    Ok(Json(webhooks))
}

/// Delete webhook
pub async fn delete_webhook(
    State(app_state): State<AppState>,
    Path(webhook_id): Path<Uuid>,
    _claims: Claims,
) -> Result<StatusCode, StatusCode> {
    let result = sqlx::query!(
        "DELETE FROM soar_webhooks WHERE id = $1",
        webhook_id
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    if result.rows_affected() == 0 {
        return Err(StatusCode::NOT_FOUND);
    }

    Ok(StatusCode::NO_CONTENT)
}

/// Trigger webhook manually (for testing)
pub async fn trigger_webhook(
    State(app_state): State<AppState>,
    Path(webhook_id): Path<Uuid>,
    _claims: Claims,
) -> Result<Json<serde_json::Value>, StatusCode> {
    let webhook = sqlx::query_as!(
        WebhookConfig,
        "SELECT id, name, url, method, headers, payload_template, trigger_on, is_enabled, created_at FROM soar_webhooks WHERE id = $1",
        webhook_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?
    .ok_or(StatusCode::NOT_FOUND)?;

    // Execute webhook
    let client = reqwest::Client::new();
    let response = client
        .post(&webhook.url)
        .header("Content-Type", "application/json")
        .body(webhook.payload_template)
        .send()
        .await
        .map_err(|_| StatusCode::BAD_GATEWAY)?;

    Ok(Json(serde_json::json!({
        "status": response.status().as_u16(),
        "success": response.status().is_success()
    })))
}
