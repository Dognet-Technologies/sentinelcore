// src/handlers/asset.rs - FIXED: Convertito a State
use axum::{
    extract::{Path, State}, // FIXED: State invece di Extension
    http::StatusCode,
    Json,
};
use serde::Serialize;
use uuid::Uuid;

use crate::models::{Asset, AssetType, NewAsset, UpdateAsset};  // Import UpdateAsset from models
use crate::state::AppState;
use chrono::{DateTime, Utc};
use ipnetwork::IpNetwork;

#[derive(Debug, Serialize)]
pub struct ErrorResponse {
    pub error: String,
}

// Enhanced asset response for frontend with vulnerability count
#[derive(Debug, Serialize)]
pub struct AssetWithStats {
    pub id: Uuid,
    pub name: String,
    pub hostname: Option<String>,
    pub ip_address: Option<String>,  // Serialized as string for frontend
    pub os: Option<String>,          // Renamed from operating_system for frontend
    pub description: Option<String>,
    pub asset_type: String,
    pub vulnerability_count: i64,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

// NOTE: UpdateAsset is now imported from crate::models
// No need to redefine it here - using the correct version with IpNetwork

// LIST - Ottieni lista asset con vulnerability count - FIXED: State
pub async fn list_assets(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
) -> Result<Json<Vec<AssetWithStats>>, (StatusCode, Json<ErrorResponse>)> {
    // Use non-macro version to avoid compile-time verification issues
    let assets_data: Vec<(Uuid, String, Option<String>, Option<IpNetwork>, Option<String>, Option<String>, String, i64, DateTime<Utc>, DateTime<Utc>)> = sqlx::query_as(
        r#"
        SELECT
            a.id,
            a.name,
            a.hostname,
            a.ip_address,
            a.operating_system,
            a.description,
            a.asset_type::text as asset_type,
            COUNT(v.id) as vulnerability_count,
            a.created_at,
            a.updated_at
        FROM assets a
        LEFT JOIN vulnerabilities v ON v.asset_id = a.id AND v.status != 'resolved'
        GROUP BY a.id, a.name, a.hostname, a.ip_address, a.operating_system, a.description, a.asset_type, a.created_at, a.updated_at
        ORDER BY a.name ASC
        "#
    )
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore nel recupero degli asset: {}", e),
        }),
    ))?;

    let assets: Vec<AssetWithStats> = assets_data.into_iter().map(|(id, name, hostname, ip_address, operating_system, description, asset_type, vulnerability_count, created_at, updated_at)| {
        AssetWithStats {
            id,
            name,
            hostname,
            ip_address: ip_address.map(|ip| ip.to_string()),
            os: operating_system,
            description,
            asset_type,
            vulnerability_count,
            created_at,
            updated_at,
        }
    }).collect();

    Ok(Json(assets))
}

// GET - Ottieni singolo asset - FIXED: State
pub async fn get_asset(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    Path(asset_id): Path<Uuid>,
) -> Result<Json<Asset>, (StatusCode, Json<ErrorResponse>)> {
    let asset = sqlx::query_as!(
        Asset,
        r#"
        SELECT id, name, asset_type as "asset_type: AssetType", description, ip_address, 
               hostname, mac_address, operating_system, owner, location, 
               tags as "tags!", created_at, updated_at
        FROM assets
        WHERE id = $1
        "#,
        asset_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore database: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Asset non trovato".to_string(),
        }),
    ))?;

    Ok(Json(asset))
}

// CREATE - Crea nuovo asset - FIXED: State
pub async fn create_asset(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    claims: crate::auth::Claims,
    Json(new_asset): Json<NewAsset>,
) -> Result<Json<Asset>, (StatusCode, Json<ErrorResponse>)> {
    let tags: Vec<String> = new_asset.tags.unwrap_or_default();

    let asset = sqlx::query_as!(
        Asset,
        r#"
        INSERT INTO assets (
            name, asset_type, description, ip_address, hostname,
            mac_address, operating_system, owner, location, tags
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
        RETURNING id, name, asset_type as "asset_type: AssetType", description, ip_address,
                  hostname, mac_address, operating_system, owner, location,
                  tags as "tags!", created_at, updated_at
        "#,
        new_asset.name,
        new_asset.asset_type as _,
        new_asset.description,
        new_asset.ip_address,
        new_asset.hostname,
        new_asset.mac_address,
        new_asset.operating_system,
        new_asset.owner,
        new_asset.location,
        &tags
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| {
        let error_message = if e.to_string().contains("duplicate key") {
            "Asset con questi dati già esistente".to_string()
        } else {
            format!("Errore durante la creazione: {}", e)
        };
        (
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse { error: error_message }),
        )
    })?;

    // Audit: Asset created
    let user_id = claims.sub.parse::<uuid::Uuid>().ok();
    if let Some(uid) = user_id {
        crate::audit::audit(crate::audit::AuditAction::AssetCreated)
            .user_id(uid)
            .entity("asset", asset.id)
            .new_values(&asset)
            .log_async((*app_state.pool).clone());
    }

    Ok(Json(asset))
}

// UPDATE - Aggiorna asset - FIXED: State
pub async fn update_asset(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    claims: crate::auth::Claims,
    Path(asset_id): Path<Uuid>,
    Json(update_data): Json<UpdateAsset>,
) -> Result<Json<Asset>, (StatusCode, Json<ErrorResponse>)> {
    // Fetch old asset for audit logging
    let old_asset = sqlx::query_as!(
        Asset,
        r#"
        SELECT id, name, asset_type as "asset_type: AssetType", description, ip_address,
               hostname, mac_address, operating_system, owner, location,
               tags as "tags!", created_at, updated_at
        FROM assets
        WHERE id = $1 AND deleted_at IS NULL
        "#,
        asset_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore database: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Asset non trovato".to_string(),
        }),
    ))?;

    let asset = sqlx::query_as!(
        Asset,
        r#"
        UPDATE assets
        SET
            name = COALESCE($2, name),
            asset_type = COALESCE($3, asset_type),
            description = COALESCE($4, description),
            ip_address = COALESCE($5, ip_address),
            hostname = COALESCE($6, hostname),
            mac_address = COALESCE($7, mac_address),
            operating_system = COALESCE($8, operating_system),
            owner = COALESCE($9, owner),
            location = COALESCE($10, location),
            tags = COALESCE($11, tags),
            updated_at = NOW()
        WHERE id = $1
        RETURNING id, name, asset_type as "asset_type: AssetType", description, ip_address,
                  hostname, mac_address, operating_system, owner, location,
                  tags as "tags!", created_at, updated_at
        "#,
        asset_id,
        update_data.name,
        update_data.asset_type as _,
        update_data.description,
        update_data.ip_address,
        update_data.hostname,
        update_data.mac_address,
        update_data.operating_system,
        update_data.owner,
        update_data.location,
        update_data.tags.as_deref()
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore durante l'aggiornamento: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Asset non trovato".to_string(),
        }),
    ))?;

    // Audit: Asset updated
    let user_id = claims.sub.parse::<uuid::Uuid>().ok();
    if let Some(uid) = user_id {
        crate::audit::audit(crate::audit::AuditAction::AssetUpdated)
            .user_id(uid)
            .entity("asset", asset.id)
            .old_values(&old_asset)
            .new_values(&asset)
            .log_async((*app_state.pool).clone());
    }

    Ok(Json(asset))
}

// DELETE - Elimina asset - FIXED: State
pub async fn delete_asset(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    claims: crate::auth::Claims,
    Path(asset_id): Path<Uuid>,
) -> Result<StatusCode, (StatusCode, Json<ErrorResponse>)> {
    // Prima verifica se ci sono vulnerabilità associate all'asset (only active ones)
    let associated_vulns = sqlx::query_scalar::<_, i64>(
        "SELECT COUNT(*) FROM vulnerabilities WHERE asset_id = $1 AND deleted_at IS NULL"
    )
    .bind(asset_id)
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore durante il controllo: {}", e),
        }),
    ))?;

    if associated_vulns > 0 {
        return Err((
            StatusCode::CONFLICT,
            Json(ErrorResponse {
                error: format!("Impossibile eliminare: l'asset ha {} vulnerabilità associate", associated_vulns),
            }),
        ));
    }

    // Soft delete: set deleted_at timestamp instead of hard delete
    let result = sqlx::query(
        "UPDATE assets SET deleted_at = NOW() WHERE id = $1 AND deleted_at IS NULL"
    )
    .bind(asset_id)
    .execute(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore durante l'eliminazione: {}", e),
        }),
    ))?;

    if result.rows_affected() == 0 {
        return Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Asset non trovato o già eliminato".to_string(),
            }),
        ));
    }

    // Audit: Asset deleted
    let user_id = claims.sub.parse::<uuid::Uuid>().ok();
    if let Some(uid) = user_id {
        crate::audit::audit(crate::audit::AuditAction::AssetDeleted)
            .user_id(uid)
            .entity("asset", asset_id)
            .log_async((*app_state.pool).clone());
    }

    Ok(StatusCode::NO_CONTENT)
}