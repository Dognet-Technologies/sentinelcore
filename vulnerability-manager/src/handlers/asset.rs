// src/handlers/asset.rs - FIXED: Convertito a State
use axum::{
    extract::{Path, State}, // FIXED: State invece di Extension
    http::StatusCode,
    Json,
};
use sqlx::PgPool;
use std::sync::Arc;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use crate::models::{Asset, AssetType, NewAsset};

#[derive(Debug, Serialize)]
pub struct ErrorResponse {
    pub error: String,
}

#[derive(Debug, Deserialize)]
pub struct UpdateAsset {
    pub name: Option<String>,
    pub asset_type: Option<AssetType>,
    pub description: Option<String>,
    pub ip_address: Option<String>,
    pub hostname: Option<String>,
    pub mac_address: Option<String>,
    pub operating_system: Option<String>,
    pub owner: Option<String>,
    pub location: Option<String>,
    pub tags: Option<Vec<String>>,
}

// LIST - Ottieni lista asset - FIXED: State
pub async fn list_assets(
    State(pool): State<Arc<PgPool>>, // FIXED: State invece di Extension
) -> Result<Json<Vec<Asset>>, (StatusCode, Json<ErrorResponse>)> {
    let assets = sqlx::query_as!(
        Asset,
        r#"
        SELECT id, name, asset_type as "asset_type: AssetType", description, ip_address, 
               hostname, mac_address, operating_system, owner, location, 
               tags as "tags!", created_at, updated_at
        FROM assets
        ORDER BY name ASC
        "#
    )
    .fetch_all(&*pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore nel recupero degli asset: {}", e),
        }),
    ))?;

    Ok(Json(assets))
}

// GET - Ottieni singolo asset - FIXED: State
pub async fn get_asset(
    State(pool): State<Arc<PgPool>>, // FIXED: State invece di Extension
    Path(asset_id): Path<Uuid>,
) -> Result<Json<Asset>, (StatusCode, Json<ErrorResponse>)> {
    let asset = sqlx::query_as!(
        Asset,
        r#"
        SELECT id, name, asset_type as "asset_type: AssetType", description, ip_address, 
               hostname, mac_address, operating_system, owner, location, 
               tags as "tags!", created_at, updated_at
        FROM assets
        WHERE id = $1
        "#,
        asset_id
    )
    .fetch_optional(&*pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore database: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Asset non trovato".to_string(),
        }),
    ))?;

    Ok(Json(asset))
}

// CREATE - Crea nuovo asset - FIXED: State
pub async fn create_asset(
    State(pool): State<Arc<PgPool>>, // FIXED: State invece di Extension
    Json(new_asset): Json<NewAsset>,
) -> Result<Json<Asset>, (StatusCode, Json<ErrorResponse>)> {
    let tags: Vec<String> = new_asset.tags.unwrap_or_default();
    
    let asset = sqlx::query_as!(
        Asset,
        r#"
        INSERT INTO assets (
            name, asset_type, description, ip_address, hostname,
            mac_address, operating_system, owner, location, tags
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
        RETURNING id, name, asset_type as "asset_type: AssetType", description, ip_address, 
                  hostname, mac_address, operating_system, owner, location, 
                  tags as "tags!", created_at, updated_at
        "#,
        new_asset.name,
        new_asset.asset_type as _,
        new_asset.description,
        new_asset.ip_address,
        new_asset.hostname,
        new_asset.mac_address,
        new_asset.operating_system,
        new_asset.owner,
        new_asset.location,
        &tags
    )
    .fetch_one(&*pool)
    .await
    .map_err(|e| {
        let error_message = if e.to_string().contains("duplicate key") {
            "Asset con questi dati già esistente".to_string()
        } else {
            format!("Errore durante la creazione: {}", e)
        };
        (
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse { error: error_message }),
        )
    })?;

    Ok(Json(asset))
}

// UPDATE - Aggiorna asset - FIXED: State
pub async fn update_asset(
    State(pool): State<Arc<PgPool>>, // FIXED: State invece di Extension
    Path(asset_id): Path<Uuid>,
    Json(update_data): Json<UpdateAsset>,
) -> Result<Json<Asset>, (StatusCode, Json<ErrorResponse>)> {
    let asset = sqlx::query_as!(
        Asset,
        r#"
        UPDATE assets
        SET 
            name = COALESCE($2, name),
            asset_type = COALESCE($3, asset_type),
            description = COALESCE($4, description),
            ip_address = COALESCE($5, ip_address),
            hostname = COALESCE($6, hostname),
            mac_address = COALESCE($7, mac_address),
            operating_system = COALESCE($8, operating_system),
            owner = COALESCE($9, owner),
            location = COALESCE($10, location),
            tags = COALESCE($11, tags),
            updated_at = NOW()
        WHERE id = $1
        RETURNING id, name, asset_type as "asset_type: AssetType", description, ip_address, 
                  hostname, mac_address, operating_system, owner, location, 
                  tags as "tags!", created_at, updated_at
        "#,
        asset_id,
        update_data.name,
        update_data.asset_type as _,
        update_data.description,
        update_data.ip_address,
        update_data.hostname,
        update_data.mac_address,
        update_data.operating_system,
        update_data.owner,
        update_data.location,
        update_data.tags.as_deref()
    )
    .fetch_optional(&*pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore durante l'aggiornamento: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Asset non trovato".to_string(),
        }),
    ))?;

    Ok(Json(asset))
}

// DELETE - Elimina asset - FIXED: State
pub async fn delete_asset(
    State(pool): State<Arc<PgPool>>, // FIXED: State invece di Extension
    Path(asset_id): Path<Uuid>,
) -> Result<StatusCode, (StatusCode, Json<ErrorResponse>)> {
    // Prima verifica se ci sono vulnerabilità associate all'asset
    let associated_vulns = sqlx::query_scalar!(
        "SELECT COUNT(*) FROM vulnerabilities WHERE asset_id = $1",
        asset_id
    )
    .fetch_one(&*pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore durante il controllo: {}", e),
        }),
    ))?
    .unwrap_or(0);

    if associated_vulns > 0 {
        return Err((
            StatusCode::CONFLICT,
            Json(ErrorResponse {
                error: format!("Impossibile eliminare: l'asset ha {} vulnerabilità associate", associated_vulns),
            }),
        ));
    }

    let result = sqlx::query!(
        "DELETE FROM assets WHERE id = $1",
        asset_id
    )
    .execute(&*pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore durante l'eliminazione: {}", e),
        }),
    ))?;

    if result.rows_affected() == 0 {
        return Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Asset non trovato".to_string(),
            }),
        ));
    }

    Ok(StatusCode::NO_CONTENT)
}