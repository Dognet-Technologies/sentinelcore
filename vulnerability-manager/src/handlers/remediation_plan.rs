// src/handlers/remediation_plan.rs
use axum::{
    extract::{Path, State},
    http::StatusCode,
    Json,
};
use serde::Serialize;
use uuid::Uuid;

use crate::auth::Claims;
use crate::models::{RemediationPlan, NewRemediationPlan, UpdateRemediationPlan};
use crate::state::AppState;

#[derive(Debug, Serialize)]
pub struct ErrorResponse {
    pub error: String,
}

// LIST - Get all remediation plans
pub async fn list_remediation_plans(
    State(app_state): State<AppState>,
    _claims: Claims,
) -> Result<Json<Vec<serde_json::Value>>, (StatusCode, Json<ErrorResponse>)> {
    let plans = sqlx::query!(
        r#"
        SELECT id, name, description, created_by, assigned_team_id,
               status, priority, due_date, started_at, completed_at,
               created_at, updated_at, COALESCE(total_devices, 0) as total_devices,
               COALESCE(critical_count, 0) as critical_count, COALESCE(high_count, 0) as high_count,
               COALESCE(medium_count, 0) as medium_count, COALESCE(low_count, 0) as low_count,
               COALESCE(estimated_hours_total, 0) as estimated_hours_total, estimated_start_date, estimated_completion_date
        FROM remediation_plans
        ORDER BY priority DESC, created_at DESC
        "#
    )
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to fetch remediation plans: {}", e),
        }),
    ))?;

    let result = plans.into_iter().map(|row| {
        let hours_total = row.estimated_hours_total.map(|bd| bd.to_string().parse::<f64>().unwrap_or(0.0)).unwrap_or(0.0);
        serde_json::json!({
            "id": row.id,
            "name": row.name,
            "description": row.description,
            "created_by": row.created_by,
            "assigned_team_id": row.assigned_team_id,
            "status": row.status,
            "priority": row.priority,
            "due_date": row.due_date,
            "started_at": row.started_at,
            "completed_at": row.completed_at,
            "created_at": row.created_at,
            "updated_at": row.updated_at,
            "total_devices": row.total_devices,
            "critical_count": row.critical_count,
            "high_count": row.high_count,
            "medium_count": row.medium_count,
            "low_count": row.low_count,
            "estimated_hours_total": hours_total,
            "estimated_start_date": row.estimated_start_date,
            "estimated_completion_date": row.estimated_completion_date
        })
    }).collect();

    Ok(Json(result))
}

// GET - Get single remediation plan
pub async fn get_remediation_plan(
    State(app_state): State<AppState>,
    _claims: Claims,
    Path(plan_id): Path<Uuid>,
) -> Result<Json<RemediationPlan>, (StatusCode, Json<ErrorResponse>)> {
    let plan = sqlx::query_as!(
        RemediationPlan,
        r#"
        SELECT id, name, description, created_by, assigned_team_id,
               status, priority, due_date, started_at, completed_at,
               created_at, updated_at
        FROM remediation_plans
        WHERE id = $1
        "#,
        plan_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Remediation plan not found".to_string(),
        }),
    ))?;

    Ok(Json(plan))
}

// CREATE - Create new remediation plan
pub async fn create_remediation_plan(
    State(app_state): State<AppState>,
    claims: Claims,
    Json(new_plan): Json<NewRemediationPlan>,
) -> Result<Json<RemediationPlan>, (StatusCode, Json<ErrorResponse>)> {
    let user_id = claims.sub.parse::<Uuid>().map_err(|_| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: "Invalid user ID".to_string(),
        }),
    ))?;

    let priority = new_plan.priority.unwrap_or(50);

    let plan = sqlx::query_as!(
        RemediationPlan,
        r#"
        INSERT INTO remediation_plans (name, description, created_by, assigned_team_id, priority, due_date)
        VALUES ($1, $2, $3, $4, $5, $6)
        RETURNING id, name, description, created_by, assigned_team_id,
                  status, priority, due_date, started_at, completed_at,
                  created_at, updated_at
        "#,
        new_plan.name,
        new_plan.description,
        user_id,
        new_plan.assigned_team_id,
        priority,
        new_plan.due_date
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: format!("Failed to create remediation plan: {}", e),
        }),
    ))?;

    Ok(Json(plan))
}

// UPDATE - Update remediation plan
pub async fn update_remediation_plan(
    State(app_state): State<AppState>,
    _claims: Claims,
    Path(plan_id): Path<Uuid>,
    Json(update_data): Json<UpdateRemediationPlan>,
) -> Result<Json<RemediationPlan>, (StatusCode, Json<ErrorResponse>)> {
    let plan = sqlx::query_as!(
        RemediationPlan,
        r#"
        UPDATE remediation_plans
        SET
            name = COALESCE($2, name),
            description = COALESCE($3, description),
            assigned_team_id = COALESCE($4, assigned_team_id),
            status = COALESCE($5, status),
            priority = COALESCE($6, priority),
            due_date = COALESCE($7, due_date),
            updated_at = NOW()
        WHERE id = $1
        RETURNING id, name, description, created_by, assigned_team_id,
                  status, priority, due_date, started_at, completed_at,
                  created_at, updated_at
        "#,
        plan_id,
        update_data.name,
        update_data.description,
        update_data.assigned_team_id,
        update_data.status,
        update_data.priority,
        update_data.due_date
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to update remediation plan: {}", e),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::NOT_FOUND,
        Json(ErrorResponse {
            error: "Remediation plan not found".to_string(),
        }),
    ))?;

    Ok(Json(plan))
}

// DELETE - Delete remediation plan
pub async fn delete_remediation_plan(
    State(app_state): State<AppState>,
    _claims: Claims,
    Path(plan_id): Path<Uuid>,
) -> Result<StatusCode, (StatusCode, Json<ErrorResponse>)> {
    let result = sqlx::query!(
        "DELETE FROM remediation_plans WHERE id = $1",
        plan_id
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to delete remediation plan: {}", e),
        }),
    ))?;

    if result.rows_affected() == 0 {
        return Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Remediation plan not found".to_string(),
            }),
        ));
    }

    Ok(StatusCode::NO_CONTENT)
}
