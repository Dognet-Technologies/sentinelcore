// src/handlers/remediation_plan.rs
// Remediation plans management - Priority 4

use axum::{
    extract::{Path, State},
    http::StatusCode,
    Json,
};
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use crate::auth::Claims;
use crate::state::AppState;

#[derive(Debug, Serialize)]
pub struct ErrorResponse {
    pub error: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct RemediationPlan {
    pub id: Uuid,
    pub name: String,
    pub description: Option<String>,
    pub created_by: Uuid,
    pub assigned_team_id: Option<Uuid>,
    pub status: String,
    pub priority: i32,
    pub due_date: Option<DateTime<Utc>>,
    pub started_at: Option<DateTime<Utc>>,
    pub completed_at: Option<DateTime<Utc>>,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Debug, Deserialize)]
pub struct CreateRemediationPlanRequest {
    pub name: String,
    pub description: Option<String>,
    pub assigned_team_id: Option<Uuid>,
    pub priority: Option<i32>,
    pub due_date: Option<DateTime<Utc>>,
    pub device_ids: Vec<Uuid>,  // Devices to include in plan
}

#[derive(Debug, Deserialize)]
pub struct UpdateRemediationPlanRequest {
    pub name: Option<String>,
    pub description: Option<String>,
    pub assigned_team_id: Option<Uuid>,
    pub status: Option<String>,
    pub priority: Option<i32>,
    pub due_date: Option<DateTime<Utc>>,
}

#[derive(Debug, Deserialize)]
pub struct AddDevicesToPlanRequest {
    pub device_ids: Vec<Uuid>,
    pub auto_priority: Option<bool>,  // Auto-calculate priority scores
}

#[derive(Debug, Serialize)]
pub struct RemediationPlanWithDevices {
    #[serde(flatten)]
    pub plan: RemediationPlan,
    pub devices: Vec<PlanDevice>,
    pub total_devices: i32,
    pub completed_devices: i32,
}

#[derive(Debug, Serialize)]
pub struct PlanDevice {
    pub id: Uuid,
    pub device_id: Uuid,
    pub device_ip: String,
    pub device_hostname: Option<String>,
    pub priority_order: i32,
    pub priority_score: i32,
    pub status: String,
    pub assigned_user_id: Option<Uuid>,
    pub vulnerability_count: i64,
}

/// List all remediation plans
pub async fn list_remediation_plans(
    State(app_state): State<AppState>,
    _claims: Claims,
) -> Result<Json<Vec<RemediationPlan>>, (StatusCode, Json<ErrorResponse>)> {
    let pool = &*app_state.pool;

    let plans = sqlx::query_as!(
        RemediationPlan,
        r#"
        SELECT id, name, description, created_by, assigned_team_id,
               status, priority, due_date, started_at, completed_at,
               created_at, updated_at
        FROM remediation_plans
        ORDER BY created_at DESC
        "#
    )
    .fetch_all(pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch remediation plans: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to fetch remediation plans".to_string(),
            }),
        )
    })?;

    Ok(Json(plans))
}

/// Get single remediation plan with devices
pub async fn get_remediation_plan(
    State(app_state): State<AppState>,
    Path(plan_id): Path<Uuid>,
) -> Result<Json<RemediationPlanWithDevices>, (StatusCode, Json<ErrorResponse>)> {
    let pool = &*app_state.pool;

    // Get plan
    let plan = sqlx::query_as!(
        RemediationPlan,
        r#"
        SELECT id, name, description, created_by, assigned_team_id,
               status, priority, due_date, started_at, completed_at,
               created_at, updated_at
        FROM remediation_plans
        WHERE id = $1
        "#,
        plan_id
    )
    .fetch_optional(pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch plan: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to fetch plan".to_string(),
            }),
        )
    })?
    .ok_or_else(|| {
        (
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Plan not found".to_string(),
            }),
        )
    })?;

    // Get devices in plan
    let devices = sqlx::query!(
        r#"
        SELECT
            rpd.id,
            rpd.device_id,
            nd.ip_address::text as device_ip,
            nd.hostname as device_hostname,
            rpd.priority_order,
            rpd.priority_score,
            rpd.status,
            rpd.assigned_user_id,
            COUNT(dv.vulnerability_id) as "vulnerability_count!"
        FROM remediation_plan_devices rpd
        JOIN network_devices nd ON nd.id = rpd.device_id
        LEFT JOIN device_vulnerabilities dv ON dv.device_id = rpd.device_id
        WHERE rpd.plan_id = $1
        GROUP BY rpd.id, rpd.device_id, nd.ip_address, nd.hostname,
                 rpd.priority_order, rpd.priority_score, rpd.status, rpd.assigned_user_id
        ORDER BY rpd.priority_order ASC
        "#,
        plan_id
    )
    .fetch_all(pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch plan devices: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to fetch plan devices".to_string(),
            }),
        )
    })?;

    let plan_devices: Vec<PlanDevice> = devices
        .into_iter()
        .map(|d| PlanDevice {
            id: d.id,
            device_id: d.device_id,
            device_ip: d.device_ip.unwrap_or_default(),
            device_hostname: d.device_hostname,
            priority_order: d.priority_order,
            priority_score: d.priority_score,
            status: d.status,
            assigned_user_id: d.assigned_user_id,
            vulnerability_count: d.vulnerability_count,
        })
        .collect();

    let total_devices = plan_devices.len() as i32;
    let completed_devices = plan_devices.iter().filter(|d| d.status == "completed").count() as i32;

    Ok(Json(RemediationPlanWithDevices {
        plan,
        devices: plan_devices,
        total_devices,
        completed_devices,
    }))
}

/// Create new remediation plan
pub async fn create_remediation_plan(
    State(app_state): State<AppState>,
    claims: Claims,
    Json(request): Json<CreateRemediationPlanRequest>,
) -> Result<Json<RemediationPlan>, (StatusCode, Json<ErrorResponse>)> {
    let pool = &*app_state.pool;

    let user_id = claims.sub.parse::<Uuid>().map_err(|_| {
        (
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: "Invalid user ID".to_string(),
            }),
        )
    })?;

    // Create plan
    let plan = sqlx::query_as!(
        RemediationPlan,
        r#"
        INSERT INTO remediation_plans (name, description, created_by, assigned_team_id, priority, due_date, status)
        VALUES ($1, $2, $3, $4, $5, $6, 'draft')
        RETURNING id, name, description, created_by, assigned_team_id,
                  status, priority, due_date, started_at, completed_at,
                  created_at, updated_at
        "#,
        request.name,
        request.description,
        user_id,
        request.assigned_team_id,
        request.priority.unwrap_or(50),
        request.due_date,
    )
    .fetch_one(pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to create plan: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Failed to create plan: {}", e),
            }),
        )
    })?;

    // Add devices to plan with auto-prioritization
    for (index, device_id) in request.device_ids.iter().enumerate() {
        // Calculate priority score using database function
        let priority_score: i32 = sqlx::query_scalar!(
            "SELECT calculate_device_priority_score($1)",
            device_id
        )
        .fetch_one(&*pool)
        .await
        .unwrap_or(Some(50))
        .unwrap_or(50);

        sqlx::query!(
            "INSERT INTO remediation_plan_devices (plan_id, device_id, priority_order, priority_score)
             VALUES ($1, $2, $3, $4)",
            plan.id,
            device_id,
            index as i32,
            priority_score
        )
        .execute(&*pool)
        .await
        .map_err(|e| {
            tracing::error!("Failed to add device to plan: {}", e);
        })
        .ok();
    }

    Ok(Json(plan))
}

/// Update remediation plan
pub async fn update_remediation_plan(
    State(app_state): State<AppState>,
    Path(plan_id): Path<Uuid>,
    Json(request): Json<UpdateRemediationPlanRequest>,
) -> Result<Json<RemediationPlan>, (StatusCode, Json<ErrorResponse>)> {
    let pool = &*app_state.pool;

    let plan = sqlx::query_as!(
        RemediationPlan,
        r#"
        UPDATE remediation_plans
        SET
            name = COALESCE($2, name),
            description = COALESCE($3, description),
            assigned_team_id = COALESCE($4, assigned_team_id),
            status = COALESCE($5, status),
            priority = COALESCE($6, priority),
            due_date = COALESCE($7, due_date),
            updated_at = NOW()
        WHERE id = $1
        RETURNING id, name, description, created_by, assigned_team_id,
                  status, priority, due_date, started_at, completed_at,
                  created_at, updated_at
        "#,
        plan_id,
        request.name,
        request.description,
        request.assigned_team_id,
        request.status,
        request.priority,
        request.due_date,
    )
    .fetch_optional(pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to update plan: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Failed to update plan: {}", e),
            }),
        )
    })?
    .ok_or_else(|| {
        (
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Plan not found".to_string(),
            }),
        )
    })?;

    Ok(Json(plan))
}

/// Delete remediation plan
pub async fn delete_remediation_plan(
    State(app_state): State<AppState>,
    Path(plan_id): Path<Uuid>,
) -> Result<StatusCode, (StatusCode, Json<ErrorResponse>)> {
    let pool = &*app_state.pool;

    let result = sqlx::query!("DELETE FROM remediation_plans WHERE id = $1", plan_id)
        .execute(pool)
        .await
        .map_err(|e| {
            tracing::error!("Failed to delete plan: {}", e);
            (
                StatusCode::INTERNAL_SERVER_ERROR,
                Json(ErrorResponse {
                    error: "Failed to delete plan".to_string(),
                }),
            )
        })?;

    if result.rows_affected() == 0 {
        return Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Plan not found".to_string(),
            }),
        ));
    }

    Ok(StatusCode::NO_CONTENT)
}

/// Add devices to remediation plan
pub async fn add_devices_to_plan(
    State(app_state): State<AppState>,
    Path(plan_id): Path<Uuid>,
    Json(request): Json<AddDevicesToPlanRequest>,
) -> Result<Json<serde_json::Value>, (StatusCode, Json<ErrorResponse>)> {
    let pool = &*app_state.pool;

    let auto_priority = request.auto_priority.unwrap_or(true);

    // Get current max priority_order
    let max_order: Option<i32> = sqlx::query_scalar!(
        "SELECT MAX(priority_order) FROM remediation_plan_devices WHERE plan_id = $1",
        plan_id
    )
    .fetch_one(&*pool)
    .await
    .ok()
    .flatten();

    let starting_order = max_order.unwrap_or(-1) + 1;

    let mut added_count = 0;

    for (index, device_id) in request.device_ids.iter().enumerate() {
        let priority_score = if auto_priority {
            sqlx::query_scalar!("SELECT calculate_device_priority_score($1)", device_id)
                .fetch_one(&*pool)
                .await
                .unwrap_or(Some(50))
                .unwrap_or(50)
        } else {
            50
        };

        let result = sqlx::query!(
            "INSERT INTO remediation_plan_devices (plan_id, device_id, priority_order, priority_score)
             VALUES ($1, $2, $3, $4)
             ON CONFLICT (plan_id, device_id) DO NOTHING",
            plan_id,
            device_id,
            starting_order + index as i32,
            priority_score
        )
        .execute(&*pool)
        .await;

        if result.is_ok() {
            added_count += 1;
        }
    }

    Ok(Json(serde_json::json!({
        "success": true,
        "added_count": added_count,
        "message": format!("Added {} devices to plan", added_count)
    })))
}
