use axum::{
    extract::{State, Path},
    http::{StatusCode, HeaderMap},
    Json,
};
use serde_json::json;
use uuid::Uuid;
use chrono::{Utc, Duration};
use sha2::{Sha256, Digest};

use crate::state::AppState;
use crate::models::password_reset::*;
use crate::models::user::User;

#[derive(serde::Serialize)]
pub struct ErrorResponse {
    error: String,
}

pub async fn initiate_password_reset(
    State(app_state): State<AppState>,
    headers: HeaderMap,
    Json(request): Json<InitiatePasswordReset>,
) -> Result<Json<serde_json::Value>, (StatusCode, Json<ErrorResponse>)> {
    // Find user by email
    let user = sqlx::query_as!(
        User,
        r#"
        SELECT id, username, email, password_hash, role as "role: crate::models::user::Role",
               reputation_score, avatar_url, last_login, failed_login_attempts,
               account_locked_until, two_factor_enabled, two_factor_secret,
               phone_number, bio, preferred_language, created_at, updated_at
        FROM users 
        WHERE email = $1
        "#,
        request.email
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|_| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: "Database error".to_string(),
        }),
    ))?;

    // Always return success for security (don't reveal if email exists)
    if let Some(user) = user {
        // Generate secure reset token
        let reset_token = Uuid::new_v4().to_string();
        
        // Hash token for storage
        let mut hasher = Sha256::new();
        hasher.update(&reset_token);
        let token_hash = format!("{:x}", hasher.finalize());

        // Get IP and user agent
        let ip_str = headers
            .get("x-forwarded-for")
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.split(',').next())
            .unwrap_or("unknown");
        let ip_address = ip_str.parse::<ipnetwork::IpNetwork>().ok();
        
        let user_agent = headers
            .get("user-agent")
            .and_then(|h| h.to_str().ok())
            .map(|s| s.to_string());

        let expires_at = Utc::now() + Duration::hours(1);

        // Store token in database
        sqlx::query!(
            "INSERT INTO password_reset_tokens (user_id, token, token_hash, ip_address, user_agent, expires_at) 
             VALUES ($1, $2, $3, $4, $5, $6)",
            user.id,
            &reset_token,
            &token_hash,
            ip_address,
            user_agent,
            expires_at
        )
        .execute(&*app_state.pool)
        .await
        .ok();

        // TODO: Send email with reset link
        // For now, log the token (in production, send via email)
        tracing::info!("Password reset token generated for user {}: {}", user.email, reset_token);
    }

    Ok(Json(json!({
        "message": "Se l'indirizzo email è registrato, riceverai un'email con le istruzioni per reimpostare la password."
    })))
}

pub async fn confirm_password_reset(
    State(app_state): State<AppState>,
    headers: HeaderMap,
    Json(request): Json<ConfirmPasswordReset>,
) -> Result<Json<serde_json::Value>, (StatusCode, Json<ErrorResponse>)> {
    // Hash the provided token to find it in database
    let mut hasher = Sha256::new();
    hasher.update(&request.token);
    let token_hash = format!("{:x}", hasher.finalize());

    // Find the token
    let token_record = sqlx::query!(
        "SELECT id, user_id, expires_at, used_at FROM password_reset_tokens WHERE token_hash = $1",
        token_hash
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|_| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: "Database error".to_string(),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: "Token non valido o scaduto".to_string(),
        }),
    ))?;

    // Check if token is expired
    if token_record.expires_at < Utc::now() {
        return Err((
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: "Token scaduto. Richiedi un nuovo reset della password".to_string(),
            }),
        ));
    }

    // Check if token already used
    if token_record.used_at.is_some() {
        return Err((
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: "Token già utilizzato".to_string(),
            }),
        ));
    }

    // Validate and hash new password
    let password_hash = app_state.auth.hash_password(&request.new_password)
        .map_err(|e| (
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: format!("Errore di validazione password: {}", e),
            }),
        ))?;

    // Get IP for audit
    let ip_str = headers
        .get("x-forwarded-for")
        .and_then(|h| h.to_str().ok())
        .and_then(|s| s.split(',').next())
        .unwrap_or("unknown");
    let ip_address = ip_str.parse::<ipnetwork::IpNetwork>().ok();

    // Update password and mark token as used
    sqlx::query!(
        "UPDATE users SET password_hash = $1, last_password_change = NOW(), password_expires_at = NOW() + INTERVAL '90 days'
         WHERE id = $2",
        password_hash,
        token_record.user_id
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|_| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: "Errore nell'aggiornamento della password".to_string(),
        }),
    ))?;

    // Mark token as used
    sqlx::query!(
        "UPDATE password_reset_tokens SET used_at = NOW(), used_by_ip = $1 WHERE id = $2",
        ip_address,
        token_record.id
    )
    .execute(&*app_state.pool)
    .await
    .ok();

    // Log password reset
    sqlx::query!(
        "INSERT INTO password_reset_history (user_id, ip_address, request_method, success)
         VALUES ($1, $2, $3, $4)",
        token_record.user_id,
        ip_address,
        "token_reset",
        true
    )
    .execute(&*app_state.pool)
    .await
    .ok();

    Ok(Json(json!({
        "message": "Password reimpostata con successo. Puoi ora effettuare il login con le nuove credenziali."
    })))
}

pub async fn get_password_reset_status(
    State(app_state): State<AppState>,
    Path(token): Path<String>,
) -> Result<Json<serde_json::Value>, (StatusCode, Json<ErrorResponse>)> {
    // Hash the token
    let mut hasher = Sha256::new();
    hasher.update(&token);
    let token_hash = format!("{:x}", hasher.finalize());

    let token_record = sqlx::query!(
        "SELECT expires_at, used_at FROM password_reset_tokens WHERE token_hash = $1",
        token_hash
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|_| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: "Database error".to_string(),
        }),
    ))?
    .ok_or_else(|| (
        StatusCode::BAD_REQUEST,
        Json(ErrorResponse {
            error: "Token non valido".to_string(),
        }),
    ))?;

    let is_valid = token_record.used_at.is_none() && token_record.expires_at > Utc::now();

    Ok(Json(json!({
        "valid": is_valid,
        "expired": token_record.expires_at <= Utc::now(),
        "used": token_record.used_at.is_some()
    })))
}
