// src/handlers/management_report.rs
// Handler per generare report di gestione vulnerabilità

use axum::{
    extract::State,
    http::StatusCode,
    Json,
};
use chrono::{DateTime, Utc};
use uuid::Uuid;

use crate::auth::Claims;
use crate::models::{
    ManagementReport, ExecutiveSummary, ManagementMetrics, RiskAnalysis,
    TeamPerformance, VulnerabilityDetails, GenerateManagementReportRequest,
    VulnerabilitySeverity, VulnerabilityStatus, ReportType, ReportStatus, ReportFormat,
};
use crate::models::management_report::*;
use crate::state::AppState;

#[derive(Debug, serde::Serialize)]
pub struct ErrorResponse {
    pub error: String,
}

/// Genera un management report per vulnerabilità
pub async fn generate_management_report(
    State(app_state): State<AppState>,
    claims: Claims,
    Json(request): Json<GenerateManagementReportRequest>,
) -> Result<Json<ManagementReport>, (StatusCode, Json<ErrorResponse>)> {
    let user_id = Uuid::parse_str(&claims.sub)
        .map_err(|_| (
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: "ID utente non valido nel token".to_string(),
            }),
        ))?;

    let report_id = Uuid::new_v4();
    let generated_at = Utc::now();

    // 1. Executive Summary
    let executive_summary = calculate_executive_summary(
        &app_state,
        request.period_start,
        request.period_end,
        request.team_id,
        request.asset_id.as_ref(),
    ).await?;

    // 2. Management Metrics
    let management_metrics = calculate_management_metrics(
        &app_state,
        request.period_start,
        request.period_end,
        request.team_id,
        request.asset_id.as_ref(),
    ).await?;

    // 3. Risk Analysis
    let risk_analysis = calculate_risk_analysis(
        &app_state,
        request.period_start,
        request.period_end,
        request.team_id,
        request.asset_id.as_ref(),
    ).await?;

    // 4. Team Performance
    let team_performance = calculate_team_performance(
        &app_state,
        request.period_start,
        request.period_end,
    ).await?;

    // 5. Vulnerability Details
    let vulnerability_details = get_vulnerability_details(
        &app_state,
        request.period_start,
        request.period_end,
        request.team_id,
        request.asset_id.as_ref(),
    ).await?;

    let report = ManagementReport {
        report_id,
        report_name: request.name.clone(),
        period_start: request.period_start,
        period_end: request.period_end,
        generated_at,
        generated_by: user_id,
        executive_summary,
        management_metrics,
        risk_analysis,
        team_performance,
        vulnerability_details,
    };

    // Save report metadata to database so it appears in the reports list
    sqlx::query!(
        r#"
        INSERT INTO reports (
            id, name, report_type, format, status, source, created_by, scan_date
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
        "#,
        report_id,
        request.name,
        ReportType::Manual as _,
        ReportFormat::Json as _,
        ReportStatus::Completed as _,
        "Management Report Generator",
        user_id,
        Some(request.period_end)
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Failed to save report to database: {}", e),
        }),
    ))?;

    Ok(Json(report))
}

/// Calcola l'Executive Summary
async fn calculate_executive_summary(
    app_state: &AppState,
    period_start: DateTime<Utc>,
    period_end: DateTime<Utc>,
    team_id: Option<Uuid>,
    asset_id: Option<&Uuid>,
) -> Result<ExecutiveSummary, (StatusCode, Json<ErrorResponse>)> {
    // Query per vulnerabilità totali nel periodo (create_at nel range)
    let total_vulnerabilities: i64 = sqlx::query_scalar!(
        r#"
        SELECT COUNT(*) as "count!"
        FROM vulnerabilities v
        WHERE deleted_at IS NULL
        AND created_at BETWEEN $1 AND $2
        AND ($3::UUID IS NULL OR assigned_team_id = $3)
        AND ($4::UUID IS NULL OR asset_id = $4)
        "#,
        period_start,
        period_end,
        team_id,
        asset_id
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore query total_vulnerabilities: {}", e),
        }),
    ))?;

    // Nuove vulnerabilità nel periodo
    let new_vulnerabilities = total_vulnerabilities;

    // Vulnerabilità risolte nel periodo (usando audit_logs)
    let resolved_vulnerabilities: i64 = sqlx::query_scalar!(
        r#"
        SELECT COUNT(DISTINCT entity_id) as "count!"
        FROM audit_logs
        WHERE action = 'update_vulnerability'
        AND entity_type = 'vulnerability'
        AND created_at BETWEEN $1 AND $2
        AND new_values->>'status' IN ('resolved', 'closed')
        AND old_values->>'status' IN ('open', 'in_progress')
        "#,
        period_start,
        period_end
    )
    .fetch_one(&*app_state.pool)
    .await
    .unwrap_or(0);

    // Vulnerabilità aperte alla fine del periodo
    let open_vulnerabilities: i64 = sqlx::query_scalar!(
        r#"
        SELECT COUNT(*) as "count!"
        FROM vulnerabilities v
        WHERE deleted_at IS NULL
        AND status = 'open'
        AND created_at <= $1
        AND ($2::UUID IS NULL OR assigned_team_id = $2)
        AND ($3::UUID IS NULL OR asset_id = $3)
        "#,
        period_end,
        team_id,
        asset_id
    )
    .fetch_one(&*app_state.pool)
    .await
    .unwrap_or(0);

    // Vulnerabilità in progress alla fine del periodo
    let in_progress_vulnerabilities: i64 = sqlx::query_scalar!(
        r#"
        SELECT COUNT(*) as "count!"
        FROM vulnerabilities v
        WHERE deleted_at IS NULL
        AND status = 'in_progress'
        AND created_at <= $1
        AND ($2::UUID IS NULL OR assigned_team_id = $2)
        AND ($3::UUID IS NULL OR asset_id = $3)
        "#,
        period_end,
        team_id,
        asset_id
    )
    .fetch_one(&*app_state.pool)
    .await
    .unwrap_or(0);

    // Rischio eliminato (CVSS di vulnerabilità risolte)
    let risk_eliminated: Option<f64> = sqlx::query_scalar!(
        r#"
        SELECT CAST(COALESCE(SUM(v.cvss_score), 0) AS DOUBLE PRECISION) as "risk!"
        FROM vulnerabilities v
        JOIN audit_logs al ON al.entity_id = v.id
        WHERE v.deleted_at IS NULL
        AND al.action = 'update_vulnerability'
        AND al.entity_type = 'vulnerability'
        AND al.created_at BETWEEN $1 AND $2
        AND al.new_values->>'status' IN ('resolved', 'closed')
        AND al.old_values->>'status' IN ('open', 'in_progress')
        "#,
        period_start,
        period_end
    )
    .fetch_one(&*app_state.pool)
    .await
    .ok();

    // Rischio residuo (CVSS di vulnerabilità ancora aperte)
    let residual_risk: Option<f64> = sqlx::query_scalar!(
        r#"
        SELECT CAST(COALESCE(SUM(cvss_score), 0) AS DOUBLE PRECISION) as "risk!"
        FROM vulnerabilities v
        WHERE v.deleted_at IS NULL
        AND status IN ('open', 'in_progress')
        AND created_at <= $1
        AND ($2::UUID IS NULL OR assigned_team_id = $2)
        AND ($3::UUID IS NULL OR asset_id = $3)
        "#,
        period_end,
        team_id,
        asset_id
    )
    .fetch_one(&*app_state.pool)
    .await
    .ok();

    let risk_eliminated = risk_eliminated.unwrap_or(0.0);
    let residual_risk = residual_risk.unwrap_or(0.0);
    let net_change = resolved_vulnerabilities - new_vulnerabilities;
    let positive_trend = resolved_vulnerabilities >= new_vulnerabilities;

    Ok(ExecutiveSummary {
        total_vulnerabilities,
        new_vulnerabilities,
        resolved_vulnerabilities,
        open_vulnerabilities,
        in_progress_vulnerabilities,
        risk_eliminated,
        residual_risk,
        positive_trend,
        net_change,
    })
}

/// Calcola le Management Metrics
async fn calculate_management_metrics(
    app_state: &AppState,
    period_start: DateTime<Utc>,
    period_end: DateTime<Utc>,
    team_id: Option<Uuid>,
    asset_id: Option<&Uuid>,
) -> Result<ManagementMetrics, (StatusCode, Json<ErrorResponse>)> {
    // Tempo medio di risoluzione per severità
    let avg_resolution_critical: Option<f64> = sqlx::query_scalar!(
        r#"
        SELECT CAST(AVG(EXTRACT(EPOCH FROM (al.created_at - v.created_at)) / 86400) AS DOUBLE PRECISION) as "avg_days"
        FROM vulnerabilities v
        JOIN audit_logs al ON al.entity_id = v.id
        WHERE v.deleted_at IS NULL
        AND al.action = 'update_vulnerability'
        AND al.created_at BETWEEN $1 AND $2
        AND al.new_values->>'status' IN ('resolved', 'closed')
        AND v.severity = 'critical'
        "#,
        period_start,
        period_end
    )
    .fetch_one(&*app_state.pool)
    .await
    .ok()
    .flatten();

    let avg_resolution_high: Option<f64> = sqlx::query_scalar!(
        r#"
        SELECT CAST(AVG(EXTRACT(EPOCH FROM (al.created_at - v.created_at)) / 86400) AS DOUBLE PRECISION) as "avg_days"
        FROM vulnerabilities v
        JOIN audit_logs al ON al.entity_id = v.id
        WHERE v.deleted_at IS NULL
        AND al.action = 'update_vulnerability'
        AND al.created_at BETWEEN $1 AND $2
        AND al.new_values->>'status' IN ('resolved', 'closed')
        AND v.severity = 'high'
        "#,
        period_start,
        period_end
    )
    .fetch_one(&*app_state.pool)
    .await
    .ok()
    .flatten();

    let avg_resolution_medium: Option<f64> = sqlx::query_scalar!(
        r#"
        SELECT CAST(AVG(EXTRACT(EPOCH FROM (al.created_at - v.created_at)) / 86400) AS DOUBLE PRECISION) as "avg_days"
        FROM vulnerabilities v
        JOIN audit_logs al ON al.entity_id = v.id
        WHERE v.deleted_at IS NULL
        AND al.action = 'update_vulnerability'
        AND al.created_at BETWEEN $1 AND $2
        AND al.new_values->>'status' IN ('resolved', 'closed')
        AND v.severity = 'medium'
        "#,
        period_start,
        period_end
    )
    .fetch_one(&*app_state.pool)
    .await
    .ok()
    .flatten();

    let avg_resolution_low: Option<f64> = sqlx::query_scalar!(
        r#"
        SELECT CAST(AVG(EXTRACT(EPOCH FROM (al.created_at - v.created_at)) / 86400) AS DOUBLE PRECISION) as "avg_days"
        FROM vulnerabilities v
        JOIN audit_logs al ON al.entity_id = v.id
        WHERE v.deleted_at IS NULL
        AND al.action = 'update_vulnerability'
        AND al.created_at BETWEEN $1 AND $2
        AND al.new_values->>'status' IN ('resolved', 'closed')
        AND v.severity = 'low'
        "#,
        period_start,
        period_end
    )
    .fetch_one(&*app_state.pool)
    .await
    .ok()
    .flatten();

    // SLA Compliance - Critical entro 7 giorni
    let critical_total: i64 = sqlx::query_scalar!(
        r#"
        SELECT COUNT(*) as "count!"
        FROM vulnerabilities v
        JOIN audit_logs al ON al.entity_id = v.id
        WHERE v.deleted_at IS NULL
        AND al.action = 'update_vulnerability'
        AND al.created_at BETWEEN $1 AND $2
        AND al.new_values->>'status' IN ('resolved', 'closed')
        AND v.severity = 'critical'
        "#,
        period_start,
        period_end
    )
    .fetch_one(&*app_state.pool)
    .await
    .unwrap_or(0);

    let critical_compliant: i64 = sqlx::query_scalar!(
        r#"
        SELECT COUNT(*) as "count!"
        FROM vulnerabilities v
        JOIN audit_logs al ON al.entity_id = v.id
        WHERE v.deleted_at IS NULL
        AND al.action = 'update_vulnerability'
        AND al.created_at BETWEEN $1 AND $2
        AND al.new_values->>'status' IN ('resolved', 'closed')
        AND v.severity = 'critical'
        AND EXTRACT(EPOCH FROM (al.created_at - v.created_at)) / 86400 <= 7
        "#,
        period_start,
        period_end
    )
    .fetch_one(&*app_state.pool)
    .await
    .unwrap_or(0);

    // High entro 30 giorni
    let high_total: i64 = sqlx::query_scalar!(
        r#"
        SELECT COUNT(*) as "count!"
        FROM vulnerabilities v
        JOIN audit_logs al ON al.entity_id = v.id
        WHERE v.deleted_at IS NULL
        AND al.action = 'update_vulnerability'
        AND al.created_at BETWEEN $1 AND $2
        AND al.new_values->>'status' IN ('resolved', 'closed')
        AND v.severity = 'high'
        "#,
        period_start,
        period_end
    )
    .fetch_one(&*app_state.pool)
    .await
    .unwrap_or(0);

    let high_compliant: i64 = sqlx::query_scalar!(
        r#"
        SELECT COUNT(*) as "count!"
        FROM vulnerabilities v
        JOIN audit_logs al ON al.entity_id = v.id
        WHERE v.deleted_at IS NULL
        AND al.action = 'update_vulnerability'
        AND al.created_at BETWEEN $1 AND $2
        AND al.new_values->>'status' IN ('resolved', 'closed')
        AND v.severity = 'high'
        AND EXTRACT(EPOCH FROM (al.created_at - v.created_at)) / 86400 <= 30
        "#,
        period_start,
        period_end
    )
    .fetch_one(&*app_state.pool)
    .await
    .unwrap_or(0);

    // Medium entro 90 giorni
    let medium_total: i64 = sqlx::query_scalar!(
        r#"
        SELECT COUNT(*) as "count!"
        FROM vulnerabilities v
        JOIN audit_logs al ON al.entity_id = v.id
        WHERE v.deleted_at IS NULL
        AND al.action = 'update_vulnerability'
        AND al.created_at BETWEEN $1 AND $2
        AND al.new_values->>'status' IN ('resolved', 'closed')
        AND v.severity = 'medium'
        "#,
        period_start,
        period_end
    )
    .fetch_one(&*app_state.pool)
    .await
    .unwrap_or(0);

    let medium_compliant: i64 = sqlx::query_scalar!(
        r#"
        SELECT COUNT(*) as "count!"
        FROM vulnerabilities v
        JOIN audit_logs al ON al.entity_id = v.id
        WHERE v.deleted_at IS NULL
        AND al.action = 'update_vulnerability'
        AND al.created_at BETWEEN $1 AND $2
        AND al.new_values->>'status' IN ('resolved', 'closed')
        AND v.severity = 'medium'
        AND EXTRACT(EPOCH FROM (al.created_at - v.created_at)) / 86400 <= 90
        "#,
        period_start,
        period_end
    )
    .fetch_one(&*app_state.pool)
    .await
    .unwrap_or(0);

    // Backlog aging
    let age_0_30: i64 = sqlx::query_scalar!(
        r#"
        SELECT COUNT(*) as "count!"
        FROM vulnerabilities v
        WHERE v.deleted_at IS NULL
        AND status IN ('open', 'in_progress')
        AND EXTRACT(EPOCH FROM (NOW() - created_at)) / 86400 <= 30
        "#
    )
    .fetch_one(&*app_state.pool)
    .await
    .unwrap_or(0);

    let age_31_60: i64 = sqlx::query_scalar!(
        r#"
        SELECT COUNT(*) as "count!"
        FROM vulnerabilities v
        WHERE v.deleted_at IS NULL
        AND status IN ('open', 'in_progress')
        AND EXTRACT(EPOCH FROM (NOW() - created_at)) / 86400 BETWEEN 31 AND 60
        "#
    )
    .fetch_one(&*app_state.pool)
    .await
    .unwrap_or(0);

    let age_61_90: i64 = sqlx::query_scalar!(
        r#"
        SELECT COUNT(*) as "count!"
        FROM vulnerabilities v
        WHERE v.deleted_at IS NULL
        AND status IN ('open', 'in_progress')
        AND EXTRACT(EPOCH FROM (NOW() - created_at)) / 86400 BETWEEN 61 AND 90
        "#
    )
    .fetch_one(&*app_state.pool)
    .await
    .unwrap_or(0);

    let age_over_90: i64 = sqlx::query_scalar!(
        r#"
        SELECT COUNT(*) as "count!"
        FROM vulnerabilities v
        WHERE v.deleted_at IS NULL
        AND status IN ('open', 'in_progress')
        AND EXTRACT(EPOCH FROM (NOW() - created_at)) / 86400 > 90
        "#
    )
    .fetch_one(&*app_state.pool)
    .await
    .unwrap_or(0);

    // MTTR complessivo
    let overall_mttr: f64 = sqlx::query_scalar!(
        r#"
        SELECT CAST(COALESCE(AVG(EXTRACT(EPOCH FROM (al.created_at - v.created_at)) / 86400), 0) AS DOUBLE PRECISION) as "mttr!"
        FROM vulnerabilities v
        JOIN audit_logs al ON al.entity_id = v.id
        WHERE v.deleted_at IS NULL
        AND al.action = 'update_vulnerability'
        AND al.created_at BETWEEN $1 AND $2
        AND al.new_values->>'status' IN ('resolved', 'closed')
        "#,
        period_start,
        period_end
    )
    .fetch_one(&*app_state.pool)
    .await
    .unwrap_or(0.0);

    Ok(ManagementMetrics {
        avg_resolution_time: ResolutionTimeBySevert {
            critical: avg_resolution_critical,
            high: avg_resolution_high,
            medium: avg_resolution_medium,
            low: avg_resolution_low,
        },
        sla_compliance: SlaCompliance {
            critical_within_7d: if critical_total > 0 {
                (critical_compliant as f64 / critical_total as f64) * 100.0
            } else {
                0.0
            },
            critical_total,
            critical_compliant,
            high_within_30d: if high_total > 0 {
                (high_compliant as f64 / high_total as f64) * 100.0
            } else {
                0.0
            },
            high_total,
            high_compliant,
            medium_within_90d: if medium_total > 0 {
                (medium_compliant as f64 / medium_total as f64) * 100.0
            } else {
                0.0
            },
            medium_total,
            medium_compliant,
        },
        backlog_aging: BacklogAging {
            age_0_30,
            age_31_60,
            age_61_90,
            age_over_90,
        },
        overall_mttr,
    })
}

/// Calcola la Risk Analysis
async fn calculate_risk_analysis(
    app_state: &AppState,
    period_start: DateTime<Utc>,
    period_end: DateTime<Utc>,
    team_id: Option<Uuid>,
    asset_id: Option<&Uuid>,
) -> Result<RiskAnalysis, (StatusCode, Json<ErrorResponse>)> {
    // Top 10 vulnerabilità aperte più critiche (ordinato per CVSS * EPSS o solo CVSS)
    let top_open: Vec<VulnerabilitySummary> = sqlx::query_as!(
        VulnerabilityRecord,
        r#"
        SELECT
            id, title, severity as "severity!: VulnerabilitySeverity",
            cvss_score, epss_score, status as "status!: VulnerabilityStatus",
            host(ip_address) as "ip_address!", hostname,
            CAST(EXTRACT(EPOCH FROM (NOW() - created_at)) / 86400 AS DOUBLE PRECISION) as "days_open!",
            NULL as assigned_to
        FROM vulnerabilities v
        WHERE v.deleted_at IS NULL
        AND status IN ('open', 'in_progress')
        ORDER BY (cvss_score * COALESCE(epss_score, 1.0)) DESC
        LIMIT 10
        "#
    )
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore query top open vulnerabilities: {}", e),
        }),
    ))?
    .into_iter()
    .map(|r| VulnerabilitySummary {
        id: r.id,
        title: r.title,
        severity: format!("{:?}", r.severity).to_lowercase(),
        cvss_score: r.cvss_score,
        epss_score: r.epss_score,
        status: format!("{:?}", r.status).to_lowercase(),
        ip_address: r.ip_address,
        hostname: r.hostname,
        days_open: r.days_open as i64,
        assigned_to: r.assigned_to,
    })
    .collect();

    // Top vulnerabilità risolte (maggior CVSS)
    let top_resolved: Vec<ResolvedVulnerabilitySummary> = sqlx::query_as!(
        ResolvedVulnerabilityRecord,
        r#"
        SELECT
            v.id, v.title, v.severity as "severity!: VulnerabilitySeverity",
            v.cvss_score,
            al.created_at as "resolved_at!",
            u.username as resolved_by,
            CAST(EXTRACT(EPOCH FROM (al.created_at - v.created_at)) / 86400 AS DOUBLE PRECISION) as "days_to_resolve!"
        FROM vulnerabilities v
        JOIN audit_logs al ON al.entity_id = v.id
        LEFT JOIN users u ON u.id = al.user_id
        WHERE v.deleted_at IS NULL
        AND al.action = 'update_vulnerability'
        AND al.created_at BETWEEN $1 AND $2
        AND al.new_values->>'status' IN ('resolved', 'closed')
        ORDER BY v.cvss_score DESC
        LIMIT 10
        "#,
        period_start,
        period_end
    )
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Errore query top resolved vulnerabilities: {}", e),
        }),
    ))?
    .into_iter()
    .map(|r| ResolvedVulnerabilitySummary {
        id: r.id,
        title: r.title,
        severity: format!("{:?}", r.severity).to_lowercase(),
        cvss_score: r.cvss_score,
        resolved_at: r.resolved_at,
        resolved_by: r.resolved_by,
        days_to_resolve: r.days_to_resolve as i64,
        risk_eliminated: r.cvss_score,
    })
    .collect();

    // Rischio per severità
    let risk_by_severity = RiskBySeverity {
        critical_cvss_total: 0.0, // TODO: implement
        critical_count: 0,
        high_cvss_total: 0.0,
        high_count: 0,
        medium_cvss_total: 0.0,
        medium_count: 0,
        low_cvss_total: 0.0,
        low_count: 0,
    };

    // Rischio per asset
    let risk_by_asset: Vec<AssetRiskSummary> = Vec::new(); // TODO: implement

    Ok(RiskAnalysis {
        top_open_vulnerabilities: top_open,
        top_resolved_vulnerabilities: top_resolved,
        risk_by_severity,
        risk_by_asset,
    })
}

// Helper structs per query
#[derive(Debug, sqlx::FromRow)]
struct VulnerabilityRecord {
    id: Uuid,
    title: String,
    severity: VulnerabilitySeverity,
    cvss_score: f32,
    epss_score: Option<f32>,
    status: VulnerabilityStatus,
    ip_address: String,
    hostname: Option<String>,
    days_open: f64,
    assigned_to: Option<String>,
}

#[derive(Debug, sqlx::FromRow)]
struct ResolvedVulnerabilityRecord {
    id: Uuid,
    title: String,
    severity: VulnerabilitySeverity,
    cvss_score: f32,
    resolved_at: DateTime<Utc>,
    resolved_by: Option<String>,
    days_to_resolve: f64,
}

/// Calcola le performance dei team
async fn calculate_team_performance(
    app_state: &AppState,
    period_start: DateTime<Utc>,
    period_end: DateTime<Utc>,
) -> Result<Vec<TeamPerformance>, (StatusCode, Json<ErrorResponse>)> {
    // TODO: Implement team performance calculation
    // Per ora ritorna lista vuota
    Ok(Vec::new())
}

/// Ottiene i dettagli delle vulnerabilità
async fn get_vulnerability_details(
    app_state: &AppState,
    period_start: DateTime<Utc>,
    period_end: DateTime<Utc>,
    team_id: Option<Uuid>,
    asset_id: Option<&Uuid>,
) -> Result<VulnerabilityDetails, (StatusCode, Json<ErrorResponse>)> {
    // Vulnerabilità aperte
    let open: Vec<VulnerabilitySummary> = sqlx::query_as!(
        VulnerabilityRecord,
        r#"
        SELECT
            id, title, severity as "severity!: VulnerabilitySeverity",
            cvss_score, epss_score, status as "status!: VulnerabilityStatus",
            host(ip_address) as "ip_address!", hostname,
            CAST(EXTRACT(EPOCH FROM (NOW() - created_at)) / 86400 AS DOUBLE PRECISION) as "days_open!",
            NULL as assigned_to
        FROM vulnerabilities v
        WHERE v.deleted_at IS NULL
        AND status = 'open'
        AND created_at <= $1
        ORDER BY cvss_score DESC
        "#,
        period_end
    )
    .fetch_all(&*app_state.pool)
    .await
    .unwrap_or_default()
    .into_iter()
    .map(|r| VulnerabilitySummary {
        id: r.id,
        title: r.title,
        severity: format!("{:?}", r.severity).to_lowercase(),
        cvss_score: r.cvss_score,
        epss_score: r.epss_score,
        status: format!("{:?}", r.status).to_lowercase(),
        ip_address: r.ip_address,
        hostname: r.hostname,
        days_open: r.days_open as i64,
        assigned_to: r.assigned_to,
    })
    .collect();

    // Vulnerabilità in progress
    let in_progress: Vec<VulnerabilitySummary> = sqlx::query_as!(
        VulnerabilityRecord,
        r#"
        SELECT
            id, title, severity as "severity!: VulnerabilitySeverity",
            cvss_score, epss_score, status as "status!: VulnerabilityStatus",
            host(ip_address) as "ip_address!", hostname,
            CAST(EXTRACT(EPOCH FROM (NOW() - created_at)) / 86400 AS DOUBLE PRECISION) as "days_open!",
            NULL as assigned_to
        FROM vulnerabilities v
        WHERE v.deleted_at IS NULL
        AND status = 'in_progress'
        AND created_at <= $1
        ORDER BY cvss_score DESC
        "#,
        period_end
    )
    .fetch_all(&*app_state.pool)
    .await
    .unwrap_or_default()
    .into_iter()
    .map(|r| VulnerabilitySummary {
        id: r.id,
        title: r.title,
        severity: format!("{:?}", r.severity).to_lowercase(),
        cvss_score: r.cvss_score,
        epss_score: r.epss_score,
        status: format!("{:?}", r.status).to_lowercase(),
        ip_address: r.ip_address,
        hostname: r.hostname,
        days_open: r.days_open as i64,
        assigned_to: r.assigned_to,
    })
    .collect();

    // Vulnerabilità risolte - lista vuota per ora (sarebbe troppo grande)
    let resolved: Vec<ResolvedVulnerabilitySummary> = Vec::new();

    Ok(VulnerabilityDetails {
        open,
        in_progress,
        resolved,
    })
}
