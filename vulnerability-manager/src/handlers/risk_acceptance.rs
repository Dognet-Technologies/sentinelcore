// src/handlers/risk_acceptance.rs
// Risk acceptance workflow with approval and expiration tracking

use axum::{
    extract::{Path, State, Query},
    http::StatusCode,
    Json,
};
use uuid::Uuid;
use chrono::Utc;
use serde_json::json;
use sqlx::Row;

use crate::auth::Claims;
use crate::state::AppState;
use crate::models::risk_acceptance::*;

/// Create risk acceptance request
pub async fn create_risk_acceptance(
    State(app_state): State<AppState>,
    Claims { sub, .. }: Claims,
    Json(payload): Json<CreateRiskAcceptanceRequest>,
) -> Result<Json<RiskAcceptanceResponse>, (StatusCode, Json<serde_json::Value>)> {
    let user_id = Uuid::parse_str(&sub).unwrap_or(Uuid::nil());
    let pool = &*app_state.pool;

    // Verify vulnerability exists
    let vuln_title: String = sqlx::query_scalar(
        "SELECT title FROM vulnerabilities WHERE id = $1"
    )
    .bind(payload.vulnerability_id)
    .fetch_one(pool)
    .await
    .map_err(|_| (
        StatusCode::NOT_FOUND,
        Json(json!({"error": "Vulnerability not found"}))
    ))?;

    let acceptance_id = Uuid::new_v4();
    let now = Utc::now();
    let quarterly_review = payload.requires_quarterly_review.unwrap_or(true);
    let next_review = if quarterly_review {
        Some(now + chrono::Duration::days(90))
    } else {
        None
    };

    sqlx::query(
        r#"
        INSERT INTO risk_acceptances 
        (id, vulnerability_id, accepted_by, justification, mitigating_controls, 
         valid_from, expires_at, requires_quarterly_review, next_review_date)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
        "#
    )
    .bind(acceptance_id)
    .bind(payload.vulnerability_id)
    .bind(user_id)
    .bind(&payload.justification)
    .bind(&payload.mitigating_controls)
    .bind(now)
    .bind(payload.expires_at)
    .bind(quarterly_review)
    .bind(next_review)
    .execute(pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(json!({"error": format!("Database error: {}", e)}))
    ))?;

    // Get username
    let user_name: String = sqlx::query_scalar("SELECT username FROM users WHERE id = $1")
        .bind(user_id)
        .fetch_one(pool)
        .await
        .unwrap_or_else(|_| "Unknown".to_string());

    let days_until_expiry = (payload.expires_at.timestamp() - now.timestamp()) / 86400;

    Ok(Json(RiskAcceptanceResponse {
        id: acceptance_id,
        vulnerability_id: payload.vulnerability_id,
        vulnerability_title: vuln_title,
        accepted_by: user_id,
        accepted_by_name: user_name,
        accepted_at: now,
        justification: payload.justification,
        mitigating_controls: payload.mitigating_controls,
        approval_status: "pending".to_string(),
        approved_by: None,
        approved_by_name: None,
        approval_comment: None,
        approved_at: None,
        valid_from: now,
        expires_at: payload.expires_at,
        days_until_expiry: days_until_expiry as i32,
        is_expired: false,
        requires_quarterly_review: quarterly_review,
        last_review_date: None,
        next_review_date: next_review,
        review_notes: None,
        created_at: now,
        updated_at: now,
    }))
}

/// List risk acceptances
pub async fn list_risk_acceptances(
    State(app_state): State<AppState>,
    _claims: Claims,
    Query(filter): Query<RiskAcceptanceFilter>,
) -> Result<Json<RiskAcceptanceListResponse>, (StatusCode, Json<serde_json::Value>)> {
    let pool = &*app_state.pool;

    let mut query = "SELECT ra.*, v.title FROM risk_acceptances ra JOIN vulnerabilities v ON ra.vulnerability_id = v.id WHERE 1=1".to_string();
    
    if filter.approval_status.is_some() {
        query.push_str(" AND ra.approval_status = $1");
    }
    if filter.include_expired.is_none() || !filter.include_expired.unwrap() {
        query.push_str(" AND ra.expires_at > NOW()");
    }
    if filter.due_for_review.is_some() && filter.due_for_review.unwrap() {
        query.push_str(" AND ra.next_review_date <= NOW()");
    }

    query.push_str(" ORDER BY ra.expires_at ASC LIMIT 100");

    let acceptances_rows = sqlx::query(&query)
        .fetch_all(pool)
        .await
        .map_err(|e| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(json!({"error": format!("Database error: {}", e)}))
        ))?;
    
    let acceptances: Vec<(
        Uuid, Uuid, Uuid, chrono::DateTime<Utc>, String, String, String,
        Option<Uuid>, Option<String>, Option<chrono::DateTime<Utc>>,
        chrono::DateTime<Utc>, chrono::DateTime<Utc>, bool, Option<chrono::DateTime<Utc>>,
        Option<chrono::DateTime<Utc>>, Option<String>, chrono::DateTime<Utc>, chrono::DateTime<Utc>,
        String
    )> = acceptances_rows.into_iter().map(|row| (
        row.get("id"),
        row.get("vulnerability_id"),
        row.get("accepted_by"),
        row.get("accepted_at"),
        row.get("justification"),
        row.get("mitigating_controls"),
        row.get("approval_status"),
        row.get("approved_by"),
        row.get("approval_comment"),
        row.get("approved_at"),
        row.get("valid_from"),
        row.get("expires_at"),
        row.get("requires_quarterly_review"),
        row.get("last_review_date"),
        row.get("next_review_date"),
        row.get("review_notes"),
        row.get("created_at"),
        row.get("updated_at"),
        row.get("title"),
    )).collect();

    let now = Utc::now();
    let mut responses = Vec::new();
    let mut pending_approvals = 0i64;
    let mut expiring_soon = 0i64;
    let mut due_for_review = 0i64;

    for (id, vuln_id, accepted_by, accepted_at, justification, mitigating_controls, approval_status,
        approved_by, approval_comment, approved_at, valid_from, expires_at, quarterly_review,
        last_review_date, next_review_date, review_notes, created_at, updated_at, vuln_title) in acceptances {
        
        if approval_status == "pending" {
            pending_approvals += 1;
        }
        
        let days_until_expiry = (expires_at.timestamp() - now.timestamp()) / 86400;
        if days_until_expiry < 30 && days_until_expiry > 0 {
            expiring_soon += 1;
        }
        
        if let Some(next_review) = next_review_date {
            if next_review <= now {
                due_for_review += 1;
            }
        }

        let user_name: String = sqlx::query_scalar("SELECT username FROM users WHERE id = $1")
            .bind(accepted_by)
            .fetch_one(pool)
            .await
            .unwrap_or_else(|_| "Unknown".to_string());

        let approved_by_name = if let Some(approver_id) = approved_by {
            sqlx::query_scalar::<_, String>("SELECT username FROM users WHERE id = $1")
                .bind(approver_id)
                .fetch_optional(pool)
                .await
                .ok()
                .flatten()
        } else {
            None
        };

        responses.push(RiskAcceptanceResponse {
            id,
            vulnerability_id: vuln_id,
            vulnerability_title: vuln_title,
            accepted_by,
            accepted_by_name: user_name,
            accepted_at,
            justification,
            mitigating_controls,
            approval_status,
            approved_by,
            approved_by_name,
            approval_comment,
            approved_at,
            valid_from,
            expires_at,
            days_until_expiry: days_until_expiry as i32,
            is_expired: expires_at < now,
            requires_quarterly_review: quarterly_review,
            last_review_date,
            next_review_date,
            review_notes,
            created_at,
            updated_at,
        });
    }

    let total = responses.len() as i64;
    Ok(Json(RiskAcceptanceListResponse {
        acceptances: responses,
        total,
        pending_approvals,
        expiring_soon,
        due_for_review,
    }))
}

/// Get risk acceptance by ID
pub async fn get_risk_acceptance(
    State(app_state): State<AppState>,
    Path(acceptance_id): Path<Uuid>,
    _claims: Claims,
) -> Result<Json<RiskAcceptanceResponse>, (StatusCode, Json<serde_json::Value>)> {
    let pool = &*app_state.pool;

    let row = sqlx::query(
        r#"
        SELECT id, vulnerability_id, accepted_by, accepted_at, justification, mitigating_controls,
               approval_status, approved_by, approval_comment, approved_at, valid_from, expires_at,
               renewal_reminder_sent, renewal_reminder_sent_at, requires_quarterly_review,
               last_review_date, next_review_date, review_notes, created_at, updated_at
        FROM risk_acceptances WHERE id = $1
        "#
    )
    .bind(acceptance_id)
    .fetch_one(pool)
    .await
    .map_err(|_| (
        StatusCode::NOT_FOUND,
        Json(json!({"error": "Risk acceptance not found"}))
    ))?;

    let acceptance = RiskAcceptance {
        id: row.get("id"),
        vulnerability_id: row.get("vulnerability_id"),
        accepted_by: row.get("accepted_by"),
        accepted_at: row.get("accepted_at"),
        justification: row.get("justification"),
        mitigating_controls: row.get("mitigating_controls"),
        approval_status: row.get("approval_status"),
        approved_by: row.get("approved_by"),
        approval_comment: row.get("approval_comment"),
        approved_at: row.get("approved_at"),
        valid_from: row.get("valid_from"),
        expires_at: row.get("expires_at"),
        renewal_reminder_sent: row.get("renewal_reminder_sent"),
        renewal_reminder_sent_at: row.get("renewal_reminder_sent_at"),
        requires_quarterly_review: row.get("requires_quarterly_review"),
        last_review_date: row.get("last_review_date"),
        next_review_date: row.get("next_review_date"),
        review_notes: row.get("review_notes"),
        created_at: row.get("created_at"),
        updated_at: row.get("updated_at"),
    };

    let vuln_title: String = sqlx::query_scalar(
        "SELECT title FROM vulnerabilities WHERE id = $1"
    )
    .bind(acceptance.vulnerability_id)
    .fetch_one(pool)
    .await
    .unwrap_or_else(|_| "Unknown".to_string());

    let user_name: String = sqlx::query_scalar("SELECT username FROM users WHERE id = $1")
        .bind(acceptance.accepted_by)
        .fetch_one(pool)
        .await
        .unwrap_or_else(|_| "Unknown".to_string());

    let approved_by_name = if let Some(approver_id) = acceptance.approved_by {
        sqlx::query_scalar::<_, String>("SELECT username FROM users WHERE id = $1")
            .bind(approver_id)
            .fetch_optional(pool)
            .await
            .ok()
            .flatten()
    } else {
        None
    };

    let now = Utc::now();
    let days_until_expiry = (acceptance.expires_at.timestamp() - now.timestamp()) / 86400;

    Ok(Json(RiskAcceptanceResponse {
        id: acceptance.id,
        vulnerability_id: acceptance.vulnerability_id,
        vulnerability_title: vuln_title,
        accepted_by: acceptance.accepted_by,
        accepted_by_name: user_name,
        accepted_at: acceptance.accepted_at,
        justification: acceptance.justification,
        mitigating_controls: acceptance.mitigating_controls,
        approval_status: acceptance.approval_status,
        approved_by: acceptance.approved_by,
        approved_by_name,
        approval_comment: acceptance.approval_comment,
        approved_at: acceptance.approved_at,
        valid_from: acceptance.valid_from,
        expires_at: acceptance.expires_at,
        days_until_expiry: days_until_expiry as i32,
        is_expired: acceptance.expires_at < now,
        requires_quarterly_review: acceptance.requires_quarterly_review,
        last_review_date: acceptance.last_review_date,
        next_review_date: acceptance.next_review_date,
        review_notes: acceptance.review_notes,
        created_at: acceptance.created_at,
        updated_at: acceptance.updated_at,
    }))
}

/// Approve risk acceptance
pub async fn approve_risk_acceptance(
    State(app_state): State<AppState>,
    Path(acceptance_id): Path<Uuid>,
    Claims { sub, .. }: Claims,
    Json(payload): Json<ApproveRiskAcceptanceRequest>,
) -> Result<Json<RiskAcceptanceResponse>, (StatusCode, Json<serde_json::Value>)> {
    let user_id = Uuid::parse_str(&sub).unwrap_or(Uuid::nil());
    let pool = &*app_state.pool;
    let now = Utc::now();

    sqlx::query(
        r#"
        UPDATE risk_acceptances 
        SET approval_status = 'approved', approved_by = $2, approval_comment = $3, approved_at = $4, updated_at = $4
        WHERE id = $1
        "#
    )
    .bind(acceptance_id)
    .bind(user_id)
    .bind(&payload.comment)
    .bind(now)
    .execute(pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(json!({"error": format!("Database error: {}", e)}))
    ))?;

    get_risk_acceptance(State(app_state), Path(acceptance_id), crate::auth::Claims {
        sub: Uuid::nil().to_string(),
        role: "user".to_string(),
        exp: 0,
        iat: 0,
        jti: None,
    }).await
}

/// Reject risk acceptance
pub async fn reject_risk_acceptance(
    State(app_state): State<AppState>,
    Path(acceptance_id): Path<Uuid>,
    Claims { sub, .. }: Claims,
    Json(payload): Json<RejectRiskAcceptanceRequest>,
) -> Result<Json<RiskAcceptanceResponse>, (StatusCode, Json<serde_json::Value>)> {
    let user_id = Uuid::parse_str(&sub).unwrap_or(Uuid::nil());
    let pool = &*app_state.pool;
    let now = Utc::now();

    sqlx::query(
        r#"
        UPDATE risk_acceptances 
        SET approval_status = 'rejected', approved_by = $2, approval_comment = $3, approved_at = $4, updated_at = $4
        WHERE id = $1
        "#
    )
    .bind(acceptance_id)
    .bind(user_id)
    .bind(&payload.comment)
    .bind(now)
    .execute(pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(json!({"error": format!("Database error: {}", e)}))
    ))?;

    get_risk_acceptance(State(app_state), Path(acceptance_id), crate::auth::Claims {
        sub: Uuid::nil().to_string(),
        role: "user".to_string(),
        exp: 0,
        iat: 0,
        jti: None,
    }).await
}

/// Renew risk acceptance
pub async fn renew_risk_acceptance(
    State(app_state): State<AppState>,
    Path(acceptance_id): Path<Uuid>,
    Claims { sub, .. }: Claims,
    Json(payload): Json<RenewRiskAcceptanceRequest>,
) -> Result<Json<RiskAcceptanceResponse>, (StatusCode, Json<serde_json::Value>)> {
    let _user_id = Uuid::parse_str(&sub).unwrap_or(Uuid::nil());
    let pool = &*app_state.pool;
    let now = Utc::now();

    sqlx::query(
        r#"
        UPDATE risk_acceptances 
        SET expires_at = $2, 
            justification = COALESCE($3, justification),
            mitigating_controls = COALESCE($4, mitigating_controls),
            approval_status = 'pending',
            approved_by = NULL,
            approved_at = NULL,
            updated_at = $5
        WHERE id = $1
        "#
    )
    .bind(acceptance_id)
    .bind(payload.expires_at)
    .bind(payload.updated_justification)
    .bind(payload.updated_controls)
    .bind(now)
    .execute(pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(json!({"error": format!("Database error: {}", e)}))
    ))?;

    get_risk_acceptance(State(app_state), Path(acceptance_id), crate::auth::Claims {
        sub: Uuid::nil().to_string(),
        role: "user".to_string(),
        exp: 0,
        iat: 0,
        jti: None,
    }).await
}

/// Review/renew risk acceptance
pub async fn review_risk_acceptance(
    State(app_state): State<AppState>,
    Path(acceptance_id): Path<Uuid>,
    Claims { sub, .. }: Claims,
    Json(payload): Json<ReviewRiskAcceptanceRequest>,
) -> Result<StatusCode, (StatusCode, Json<serde_json::Value>)> {
    let user_id = Uuid::parse_str(&sub).unwrap_or(Uuid::nil());
    let pool = &*app_state.pool;
    let now = Utc::now();

    let review_id = Uuid::new_v4();

    sqlx::query(
        r#"
        INSERT INTO risk_acceptance_reviews 
        (id, risk_acceptance_id, reviewed_by, reviewed_at, decision, decision_notes, next_review_date)
        VALUES ($1, $2, $3, $4, $5, $6, $7)
        "#
    )
    .bind(review_id)
    .bind(acceptance_id)
    .bind(user_id)
    .bind(now)
    .bind(&payload.decision)
    .bind(&payload.decision_notes)
    .bind(payload.next_review_date)
    .execute(pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(json!({"error": format!("Database error: {}", e)}))
    ))?;

    // Update acceptance based on decision
    match payload.decision.as_str() {
        "renew" | "renew_with_conditions" => {
            sqlx::query(
                "UPDATE risk_acceptances SET last_review_date = $2, next_review_date = $3, approval_status = 'approved' WHERE id = $1"
            )
            .bind(acceptance_id)
            .bind(now)
            .bind(payload.next_review_date)
            .execute(pool)
            .await
            .map_err(|e| (
                StatusCode::INTERNAL_SERVER_ERROR,
                Json(json!({"error": format!("Database error: {}", e)}))
            ))?;
        },
        "revoke" => {
            sqlx::query("UPDATE risk_acceptances SET approval_status = 'rejected' WHERE id = $1")
                .bind(acceptance_id)
                .execute(pool)
                .await
                .map_err(|e| (
                    StatusCode::INTERNAL_SERVER_ERROR,
                    Json(json!({"error": format!("Database error: {}", e)}))
                ))?;
        },
        _ => {}
    }

    Ok(StatusCode::OK)
}
