// src/handlers/dashboard.rs
// Dashboard statistics and aggregated data

use axum::{
    extract::State,
    http::StatusCode,
    Json,
};
use chrono::{DateTime, Utc, Duration, Datelike};
use serde::{Deserialize, Serialize};
use crate::state::AppState;

#[derive(Serialize)]
pub struct ErrorResponse {
    error: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct DashboardStats {
    // Overall statistics
    pub total_vulnerabilities: i64,
    pub critical_vulnerabilities: i64,
    pub high_vulnerabilities: i64,
    pub medium_vulnerabilities: i64,
    pub low_vulnerabilities: i64,
    pub resolved_vulnerabilities: i64,
    pub open_vulnerabilities: i64,
    pub in_progress_vulnerabilities: i64,

    // Asset statistics
    pub total_assets: i64,
    pub total_hosts: i64,
    pub total_teams: i64,
    pub total_users: i64,

    // Recent activity
    pub recent_scans: i64,
    pub vulnerabilities_found_today: i64,
    pub vulnerabilities_resolved_today: i64,

    // Trends (last 6 months)
    pub monthly_trends: Vec<MonthlyTrend>,

    // Severity distribution
    pub severity_distribution: SeverityDistribution,

    // Top critical hosts
    pub critical_hosts: Vec<CriticalHost>,

    // Recent activities
    pub recent_activities: Vec<RecentActivity>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct MonthlyTrend {
    pub month: String,
    pub critical: i64,
    pub high: i64,
    pub medium: i64,
    pub low: i64,
    pub total: i64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct SeverityDistribution {
    pub critical: i64,
    pub high: i64,
    pub medium: i64,
    pub low: i64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct CriticalHost {
    pub hostname: String,
    pub ip_address: String,
    pub vulnerability_count: i64,
    pub critical_count: i64,
    pub high_count: i64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct RecentActivity {
    pub id: i64,
    pub activity_type: String,
    pub title: String,
    pub description: String,
    pub severity: Option<String>,
    pub timestamp: DateTime<Utc>,
}

/// GET /api/dashboard/stats
/// Get aggregated dashboard statistics
pub async fn get_statistics(
    State(app_state): State<AppState>,
) -> Result<Json<DashboardStats>, (StatusCode, Json<ErrorResponse>)> {

    // Get overall vulnerability counts by severity
    let severity_stats = sqlx::query!(
        r#"
        SELECT
            COUNT(*) FILTER (WHERE severity = 'critical') as critical,
            COUNT(*) FILTER (WHERE severity = 'high') as high,
            COUNT(*) FILTER (WHERE severity = 'medium') as medium,
            COUNT(*) FILTER (WHERE severity = 'low') as low,
            COUNT(*) as total
        FROM vulnerabilities
        "#
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?;

    // Get vulnerability counts by status
    let status_stats = sqlx::query!(
        r#"
        SELECT
            COUNT(*) FILTER (WHERE status = 'open') as open,
            COUNT(*) FILTER (WHERE status = 'in_progress') as in_progress,
            COUNT(*) FILTER (WHERE status = 'resolved') as resolved,
            COUNT(*) FILTER (WHERE status = 'closed') as closed
        FROM vulnerabilities
        "#
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?;

    // Get asset counts
    let asset_count: i64 = sqlx::query_scalar!("SELECT COUNT(*) FROM assets")
        .fetch_one(&*app_state.pool)
        .await
        .map_err(|e| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Database error: {}", e),
            }),
        ))?
        .unwrap_or(0);

    // Get team count
    let team_count: i64 = sqlx::query_scalar!("SELECT COUNT(*) FROM teams")
        .fetch_one(&*app_state.pool)
        .await
        .map_err(|e| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Database error: {}", e),
            }),
        ))?
        .unwrap_or(0);

    // Get user count
    let user_count: i64 = sqlx::query_scalar!("SELECT COUNT(*) FROM users")
        .fetch_one(&*app_state.pool)
        .await
        .map_err(|e| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Database error: {}", e),
            }),
        ))?
        .unwrap_or(0);

    // Get today's statistics
    let today = Utc::now().date_naive();
    let today_stats = sqlx::query!(
        r#"
        SELECT
            COUNT(*) FILTER (WHERE DATE(discovered_at) = $1) as found_today,
            COUNT(*) FILTER (WHERE DATE(updated_at) = $1 AND status = 'resolved') as resolved_today
        FROM vulnerabilities
        "#,
        today
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?;

    // Get monthly trends for last 6 months
    let mut monthly_trends = Vec::new();
    let now = Utc::now();

    for i in (0..6).rev() {
        let month_date = now - Duration::days(i * 30);
        let month_name = month_date.format("%b").to_string();

        let month_stats = sqlx::query!(
            r#"
            SELECT
                COUNT(*) FILTER (WHERE severity = 'critical') as critical,
                COUNT(*) FILTER (WHERE severity = 'high') as high,
                COUNT(*) FILTER (WHERE severity = 'medium') as medium,
                COUNT(*) FILTER (WHERE severity = 'low') as low,
                COUNT(*) as total
            FROM vulnerabilities
            WHERE EXTRACT(MONTH FROM discovered_at)::INTEGER = $1
            AND EXTRACT(YEAR FROM discovered_at)::INTEGER = $2
            "#,
            month_date.month() as i32,
            month_date.year()
        )
        .fetch_one(&*app_state.pool)
        .await
        .map_err(|e| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Database error: {}", e),
            }),
        ))?;

        monthly_trends.push(MonthlyTrend {
            month: month_name,
            critical: month_stats.critical.unwrap_or(0),
            high: month_stats.high.unwrap_or(0),
            medium: month_stats.medium.unwrap_or(0),
            low: month_stats.low.unwrap_or(0),
            total: month_stats.total.unwrap_or(0),
        });
    }

    // Get top critical hosts
    let critical_hosts_data = sqlx::query!(
        r#"
        SELECT
            COALESCE(hostname, 'Unknown Host') as hostname,
            ip_address::TEXT as ip,
            COUNT(*) as vuln_count,
            COUNT(*) FILTER (WHERE severity = 'critical') as critical_count,
            COUNT(*) FILTER (WHERE severity = 'high') as high_count
        FROM vulnerabilities
        WHERE status != 'closed' AND status != 'resolved'
        GROUP BY hostname, ip_address
        ORDER BY critical_count DESC, high_count DESC
        LIMIT 10
        "#
    )
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?;

    let critical_hosts = critical_hosts_data
        .into_iter()
        .map(|row| CriticalHost {
            hostname: row.hostname.unwrap_or_else(|| "Unknown".to_string()),
            ip_address: row.ip.unwrap_or_else(|| "N/A".to_string()),
            vulnerability_count: row.vuln_count.unwrap_or(0),
            critical_count: row.critical_count.unwrap_or(0),
            high_count: row.high_count.unwrap_or(0),
        })
        .collect();

    // Get recent activities from audit logs
    let recent_activities_data = sqlx::query!(
        r#"
        SELECT
            id,
            action,
            entity_type,
            created_at
        FROM audit_logs
        ORDER BY created_at DESC
        LIMIT 10
        "#
    )
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?;

    let recent_activities = recent_activities_data
        .into_iter()
        .enumerate()
        .map(|(idx, row)| {
            let (activity_type, title, description) = match row.action.as_str() {
                "create_vulnerability" => ("vulnerability", "Nuova vulnerabilità", "Una nuova vulnerabilità è stata registrata"),
                "update_vulnerability" => ("update", "Vulnerabilità aggiornata", "Aggiornamento dello stato di una vulnerabilità"),
                "resolve_vulnerability" => ("resolve", "Vulnerabilità risolta", "Una vulnerabilità è stata risolta"),
                "scan_completed" => ("scan", "Scansione completata", "Scansione della rete completata"),
                _ => ("system", "Attività di sistema", "Operazione eseguita sul sistema"),
            };

            RecentActivity {
                id: idx as i64,
                activity_type: activity_type.to_string(),
                title: title.to_string(),
                description: description.to_string(),
                severity: if activity_type == "vulnerability" { Some("high".to_string()) } else { None },
                timestamp: row.created_at.unwrap_or_else(|| Utc::now()),
            }
        })
        .collect();

    let stats = DashboardStats {
        total_vulnerabilities: severity_stats.total.unwrap_or(0),
        critical_vulnerabilities: severity_stats.critical.unwrap_or(0),
        high_vulnerabilities: severity_stats.high.unwrap_or(0),
        medium_vulnerabilities: severity_stats.medium.unwrap_or(0),
        low_vulnerabilities: severity_stats.low.unwrap_or(0),
        resolved_vulnerabilities: status_stats.resolved.unwrap_or(0) + status_stats.closed.unwrap_or(0),
        open_vulnerabilities: status_stats.open.unwrap_or(0),
        in_progress_vulnerabilities: status_stats.in_progress.unwrap_or(0),
        total_assets: asset_count,
        total_hosts: asset_count, // For now, same as assets
        total_teams: team_count,
        total_users: user_count,
        recent_scans: 0, // TODO: Implement scan tracking
        vulnerabilities_found_today: today_stats.found_today.unwrap_or(0),
        vulnerabilities_resolved_today: today_stats.resolved_today.unwrap_or(0),
        monthly_trends,
        severity_distribution: SeverityDistribution {
            critical: severity_stats.critical.unwrap_or(0),
            high: severity_stats.high.unwrap_or(0),
            medium: severity_stats.medium.unwrap_or(0),
            low: severity_stats.low.unwrap_or(0),
        },
        critical_hosts,
        recent_activities,
    };

    Ok(Json(stats))
}
