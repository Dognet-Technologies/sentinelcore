// src/handlers/dashboard.rs
<<<<<<< HEAD
// Dashboard statistics and aggregated data
=======
// Dashboard statistics with real data from database
>>>>>>> 54070529ca4023dda12368a2460afbc4608bd835

use axum::{
    extract::State,
    http::StatusCode,
    Json,
};
<<<<<<< HEAD
use chrono::{DateTime, Utc, Duration, Datelike};
use serde::{Deserialize, Serialize};
use crate::state::AppState;

#[derive(Serialize)]
pub struct ErrorResponse {
    error: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct DashboardStats {
    // Overall statistics
=======
use serde::Serialize;
use crate::state::AppState;

#[derive(Debug, Serialize)]
pub struct DashboardStats {
>>>>>>> 54070529ca4023dda12368a2460afbc4608bd835
    pub total_vulnerabilities: i64,
    pub critical_vulnerabilities: i64,
    pub high_vulnerabilities: i64,
    pub medium_vulnerabilities: i64,
    pub low_vulnerabilities: i64,
    pub resolved_vulnerabilities: i64,
<<<<<<< HEAD
    pub open_vulnerabilities: i64,
    pub in_progress_vulnerabilities: i64,

    // Asset statistics
    pub total_assets: i64,
    pub total_hosts: i64,
    pub total_teams: i64,
    pub total_users: i64,

    // Recent activity
    pub recent_scans: i64,
    pub vulnerabilities_found_today: i64,
    pub vulnerabilities_resolved_today: i64,

    // Trends (last 6 months)
    pub monthly_trends: Vec<MonthlyTrend>,

    // Severity distribution
    pub severity_distribution: SeverityDistribution,

    // Top critical hosts
    pub critical_hosts: Vec<CriticalHost>,

    // Recent activities
    pub recent_activities: Vec<RecentActivity>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct MonthlyTrend {
    pub month: String,
    pub critical: i64,
    pub high: i64,
    pub medium: i64,
    pub low: i64,
    pub total: i64,
}

#[derive(Debug, Serialize, Deserialize)]
=======
    pub total_assets: i64,
    pub total_teams: i64,
    pub total_users: i64,
    pub recent_scans: i64,
    pub vulnerability_trend: Vec<TrendData>,
    pub severity_distribution: SeverityDistribution,
    pub top_vulnerable_assets: Vec<AssetVulnerabilityCount>,
}

#[derive(Debug, Serialize)]
pub struct TrendData {
    pub date: String,
    pub count: i64,
}

#[derive(Debug, Serialize)]
>>>>>>> 54070529ca4023dda12368a2460afbc4608bd835
pub struct SeverityDistribution {
    pub critical: i64,
    pub high: i64,
    pub medium: i64,
    pub low: i64,
}

<<<<<<< HEAD
#[derive(Debug, Serialize, Deserialize)]
pub struct CriticalHost {
    pub hostname: String,
    pub ip_address: String,
    pub vulnerability_count: i64,
    pub critical_count: i64,
    pub high_count: i64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct RecentActivity {
    pub id: i64,
    pub activity_type: String,
    pub title: String,
    pub description: String,
    pub severity: Option<String>,
    pub timestamp: DateTime<Utc>,
}

/// GET /api/dashboard/stats
/// Get aggregated dashboard statistics
pub async fn get_statistics(
    State(app_state): State<AppState>,
) -> Result<Json<DashboardStats>, (StatusCode, Json<ErrorResponse>)> {

    // Get overall vulnerability counts by severity
    let severity_stats = sqlx::query!(
        r#"
        SELECT
            COUNT(*) FILTER (WHERE severity = 'critical') as critical,
            COUNT(*) FILTER (WHERE severity = 'high') as high,
            COUNT(*) FILTER (WHERE severity = 'medium') as medium,
            COUNT(*) FILTER (WHERE severity = 'low') as low,
            COUNT(*) as total
        FROM vulnerabilities
        "#
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?;

    // Get vulnerability counts by status
    let status_stats = sqlx::query!(
        r#"
        SELECT
            COUNT(*) FILTER (WHERE status = 'open') as open,
            COUNT(*) FILTER (WHERE status = 'in_progress') as in_progress,
            COUNT(*) FILTER (WHERE status = 'resolved') as resolved,
            COUNT(*) FILTER (WHERE status = 'closed') as closed
        FROM vulnerabilities
        "#
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?;

    // Get asset counts
    let asset_count: i64 = sqlx::query_scalar!("SELECT COUNT(*) FROM assets")
        .fetch_one(&*app_state.pool)
        .await
        .map_err(|e| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Database error: {}", e),
            }),
        ))?
        .unwrap_or(0);

    // Get team count
    let team_count: i64 = sqlx::query_scalar!("SELECT COUNT(*) FROM teams")
        .fetch_one(&*app_state.pool)
        .await
        .map_err(|e| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Database error: {}", e),
            }),
        ))?
        .unwrap_or(0);

    // Get user count
    let user_count: i64 = sqlx::query_scalar!("SELECT COUNT(*) FROM users")
        .fetch_one(&*app_state.pool)
        .await
        .map_err(|e| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Database error: {}", e),
            }),
        ))?
        .unwrap_or(0);

    // Get today's statistics
    let today = Utc::now().date_naive();
    let today_stats = sqlx::query!(
        r#"
        SELECT
            COUNT(*) FILTER (WHERE DATE(discovered_at) = $1) as found_today,
            COUNT(*) FILTER (WHERE DATE(updated_at) = $1 AND status = 'resolved') as resolved_today
        FROM vulnerabilities
        "#,
        today
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?;

    // Get monthly trends for last 6 months
    let mut monthly_trends = Vec::new();
    let now = Utc::now();

    for i in (0..6).rev() {
        let month_date = now - Duration::days(i * 30);
        let month_name = month_date.format("%b").to_string();

        let month_stats = sqlx::query!(
            r#"
            SELECT
                COUNT(*) FILTER (WHERE severity = 'critical') as critical,
                COUNT(*) FILTER (WHERE severity = 'high') as high,
                COUNT(*) FILTER (WHERE severity = 'medium') as medium,
                COUNT(*) FILTER (WHERE severity = 'low') as low,
                COUNT(*) as total
            FROM vulnerabilities
            WHERE EXTRACT(MONTH FROM discovered_at)::INTEGER = $1
            AND EXTRACT(YEAR FROM discovered_at)::INTEGER = $2
            "#,
            month_date.month() as i32,
            month_date.year()
        )
        .fetch_one(&*app_state.pool)
        .await
        .map_err(|e| (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Database error: {}", e),
            }),
        ))?;

        monthly_trends.push(MonthlyTrend {
            month: month_name,
            critical: month_stats.critical.unwrap_or(0),
            high: month_stats.high.unwrap_or(0),
            medium: month_stats.medium.unwrap_or(0),
            low: month_stats.low.unwrap_or(0),
            total: month_stats.total.unwrap_or(0),
        });
    }

    // Get top critical hosts
    let critical_hosts_data = sqlx::query!(
        r#"
        SELECT
            COALESCE(hostname, 'Unknown Host') as hostname,
            ip_address::TEXT as ip,
            COUNT(*) as vuln_count,
            COUNT(*) FILTER (WHERE severity = 'critical') as critical_count,
            COUNT(*) FILTER (WHERE severity = 'high') as high_count
        FROM vulnerabilities
        WHERE status != 'closed' AND status != 'resolved'
        GROUP BY hostname, ip_address
        ORDER BY critical_count DESC, high_count DESC
        LIMIT 10
        "#
    )
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?;

    let critical_hosts = critical_hosts_data
        .into_iter()
        .map(|row| CriticalHost {
            hostname: row.hostname.unwrap_or_else(|| "Unknown".to_string()),
            ip_address: row.ip.unwrap_or_else(|| "N/A".to_string()),
            vulnerability_count: row.vuln_count.unwrap_or(0),
            critical_count: row.critical_count.unwrap_or(0),
            high_count: row.high_count.unwrap_or(0),
        })
        .collect();

    // Get recent activities from audit logs
    let recent_activities_data = sqlx::query!(
        r#"
        SELECT
            id,
            action,
            entity_type,
            created_at
        FROM audit_logs
        ORDER BY created_at DESC
        LIMIT 10
        "#
    )
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| (
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(ErrorResponse {
            error: format!("Database error: {}", e),
        }),
    ))?;

    let recent_activities = recent_activities_data
        .into_iter()
        .enumerate()
        .map(|(idx, row)| {
            let (activity_type, title, description) = match row.action.as_str() {
                "create_vulnerability" => ("vulnerability", "Nuova vulnerabilità", "Una nuova vulnerabilità è stata registrata"),
                "update_vulnerability" => ("update", "Vulnerabilità aggiornata", "Aggiornamento dello stato di una vulnerabilità"),
                "resolve_vulnerability" => ("resolve", "Vulnerabilità risolta", "Una vulnerabilità è stata risolta"),
                "scan_completed" => ("scan", "Scansione completata", "Scansione della rete completata"),
                _ => ("system", "Attività di sistema", "Operazione eseguita sul sistema"),
            };

            RecentActivity {
                id: idx as i64,
                activity_type: activity_type.to_string(),
                title: title.to_string(),
                description: description.to_string(),
                severity: if activity_type == "vulnerability" { Some("high".to_string()) } else { None },
                timestamp: row.created_at.unwrap_or_else(|| Utc::now()),
            }
=======
#[derive(Debug, Serialize)]
pub struct AssetVulnerabilityCount {
    pub asset_name: String,
    pub asset_type: String,
    pub vulnerability_count: i64,
}

/// Get dashboard statistics with real data from database
pub async fn get_dashboard_stats(
    State(state): State<AppState>,
) -> Result<Json<DashboardStats>, (StatusCode, String)> {
    let pool = &*state.pool;

    // Get total vulnerabilities count
    let total_vulnerabilities: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM vulnerabilities WHERE deleted_at IS NULL"
    )
    .fetch_one(pool)
    .await
    .unwrap_or(0);

    // Get critical vulnerabilities count
    let critical_vulnerabilities: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM vulnerabilities WHERE severity = 'critical' AND status != 'resolved' AND deleted_at IS NULL"
    )
    .fetch_one(pool)
    .await
    .unwrap_or(0);

    // Get high vulnerabilities count
    let high_vulnerabilities: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM vulnerabilities WHERE severity = 'high' AND status != 'resolved' AND deleted_at IS NULL"
    )
    .fetch_one(pool)
    .await
    .unwrap_or(0);

    // Get medium vulnerabilities count
    let medium_vulnerabilities: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM vulnerabilities WHERE severity = 'medium' AND status != 'resolved' AND deleted_at IS NULL"
    )
    .fetch_one(pool)
    .await
    .unwrap_or(0);

    // Get low vulnerabilities count
    let low_vulnerabilities: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM vulnerabilities WHERE severity = 'low' AND status != 'resolved' AND deleted_at IS NULL"
    )
    .fetch_one(pool)
    .await
    .unwrap_or(0);

    // Get resolved vulnerabilities count
    let resolved_vulnerabilities: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM vulnerabilities WHERE status = 'resolved' AND deleted_at IS NULL"
    )
    .fetch_one(pool)
    .await
    .unwrap_or(0);

    // Get total assets count
    let total_assets: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM assets WHERE deleted_at IS NULL"
    )
    .fetch_one(pool)
    .await
    .unwrap_or(0);

    // Get total teams count
    let total_teams: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM teams WHERE deleted_at IS NULL"
    )
    .fetch_one(pool)
    .await
    .unwrap_or(0);

    // Get total users count
    let total_users: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM users WHERE deleted_at IS NULL"
    )
    .fetch_one(pool)
    .await
    .unwrap_or(0);

    // Get recent scans count (last 7 days)
    let recent_scans: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM vulnerabilities
         WHERE created_at >= NOW() - INTERVAL '7 days'
         AND deleted_at IS NULL"
    )
    .fetch_one(pool)
    .await
    .unwrap_or(0);

    // Get vulnerability trend for last 30 days
    let trend_query = sqlx::query_as::<_, (String, i64)>(
        "SELECT
            DATE(created_at) as date,
            COUNT(*) as count
         FROM vulnerabilities
         WHERE created_at >= NOW() - INTERVAL '30 days'
         AND deleted_at IS NULL
         GROUP BY DATE(created_at)
         ORDER BY date DESC
         LIMIT 30"
    )
    .fetch_all(pool)
    .await
    .unwrap_or_default();

    let vulnerability_trend: Vec<TrendData> = trend_query
        .into_iter()
        .map(|(date, count)| TrendData { date, count })
        .collect();

    // Severity distribution
    let severity_distribution = SeverityDistribution {
        critical: critical_vulnerabilities,
        high: high_vulnerabilities,
        medium: medium_vulnerabilities,
        low: low_vulnerabilities,
    };

    // Get top vulnerable assets
    let top_assets_query = sqlx::query_as::<_, (String, String, i64)>(
        "SELECT
            a.name as asset_name,
            a.asset_type,
            COUNT(v.id) as vulnerability_count
         FROM assets a
         LEFT JOIN vulnerabilities v ON v.asset_id = a.id AND v.status != 'resolved' AND v.deleted_at IS NULL
         WHERE a.deleted_at IS NULL
         GROUP BY a.id, a.name, a.asset_type
         HAVING COUNT(v.id) > 0
         ORDER BY vulnerability_count DESC
         LIMIT 10"
    )
    .fetch_all(pool)
    .await
    .unwrap_or_default();

    let top_vulnerable_assets: Vec<AssetVulnerabilityCount> = top_assets_query
        .into_iter()
        .map(|(asset_name, asset_type, vulnerability_count)| AssetVulnerabilityCount {
            asset_name,
            asset_type,
            vulnerability_count,
>>>>>>> 54070529ca4023dda12368a2460afbc4608bd835
        })
        .collect();

    let stats = DashboardStats {
<<<<<<< HEAD
        total_vulnerabilities: severity_stats.total.unwrap_or(0),
        critical_vulnerabilities: severity_stats.critical.unwrap_or(0),
        high_vulnerabilities: severity_stats.high.unwrap_or(0),
        medium_vulnerabilities: severity_stats.medium.unwrap_or(0),
        low_vulnerabilities: severity_stats.low.unwrap_or(0),
        resolved_vulnerabilities: status_stats.resolved.unwrap_or(0) + status_stats.closed.unwrap_or(0),
        open_vulnerabilities: status_stats.open.unwrap_or(0),
        in_progress_vulnerabilities: status_stats.in_progress.unwrap_or(0),
        total_assets: asset_count,
        total_hosts: asset_count, // For now, same as assets
        total_teams: team_count,
        total_users: user_count,
        recent_scans: 0, // TODO: Implement scan tracking
        vulnerabilities_found_today: today_stats.found_today.unwrap_or(0),
        vulnerabilities_resolved_today: today_stats.resolved_today.unwrap_or(0),
        monthly_trends,
        severity_distribution: SeverityDistribution {
            critical: severity_stats.critical.unwrap_or(0),
            high: severity_stats.high.unwrap_or(0),
            medium: severity_stats.medium.unwrap_or(0),
            low: severity_stats.low.unwrap_or(0),
        },
        critical_hosts,
        recent_activities,
=======
        total_vulnerabilities,
        critical_vulnerabilities,
        high_vulnerabilities,
        medium_vulnerabilities,
        low_vulnerabilities,
        resolved_vulnerabilities,
        total_assets,
        total_teams,
        total_users,
        recent_scans,
        vulnerability_trend,
        severity_distribution,
        top_vulnerable_assets,
>>>>>>> 54070529ca4023dda12368a2460afbc4608bd835
    };

    Ok(Json(stats))
}
