// src/handlers/dashboard.rs
// Dashboard statistics with real data from database

use axum::{
    extract::State,
    http::StatusCode,
    Json,
};
use serde::Serialize;
use crate::state::AppState;
use crate::auth::Claims;

#[derive(Debug, Serialize)]
pub struct DashboardStats {
    pub total_vulnerabilities: i64,
    pub critical_vulnerabilities: i64,
    pub high_vulnerabilities: i64,
    pub medium_vulnerabilities: i64,
    pub low_vulnerabilities: i64,
    pub resolved_vulnerabilities: i64,
    pub total_assets: i64,
    pub total_teams: i64,
    pub total_users: i64,
    pub recent_scans: i64,
    pub vulnerability_trend: Vec<TrendData>,
    pub severity_distribution: SeverityDistribution,
    pub top_vulnerable_assets: Vec<AssetVulnerabilityCount>,
}

#[derive(Debug, Serialize)]
pub struct TrendData {
    pub date: String,
    pub count: i64,
}

#[derive(Debug, Serialize)]
pub struct SeverityDistribution {
    pub critical: i64,
    pub high: i64,
    pub medium: i64,
    pub low: i64,
}

#[derive(Debug, Serialize)]
pub struct AssetVulnerabilityCount {
    pub asset_name: String,
    pub asset_type: String,
    pub vulnerability_count: i64,
}

/// Get dashboard statistics with real data from database
pub async fn get_dashboard_stats(
    State(state): State<AppState>,
    _claims: Claims,
) -> Result<Json<DashboardStats>, (StatusCode, String)> {
    let pool = &*state.pool;

    // Get total vulnerabilities count
    let total_vulnerabilities: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM vulnerabilities"
    )
    .fetch_one(pool)
    .await
    .unwrap_or(0);

    // Get critical vulnerabilities count
    let critical_vulnerabilities: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM vulnerabilities WHERE severity = 'critical' AND status != 'resolved'"
    )
    .fetch_one(pool)
    .await
    .unwrap_or(0);

    // Get high vulnerabilities count
    let high_vulnerabilities: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM vulnerabilities WHERE severity = 'high' AND status != 'resolved'"
    )
    .fetch_one(pool)
    .await
    .unwrap_or(0);

    // Get medium vulnerabilities count
    let medium_vulnerabilities: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM vulnerabilities WHERE severity = 'medium' AND status != 'resolved'"
    )
    .fetch_one(pool)
    .await
    .unwrap_or(0);

    // Get low vulnerabilities count
    let low_vulnerabilities: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM vulnerabilities WHERE severity = 'low' AND status != 'resolved'"
    )
    .fetch_one(pool)
    .await
    .unwrap_or(0);

    // Get resolved vulnerabilities count
    let resolved_vulnerabilities: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM vulnerabilities WHERE status = 'resolved'"
    )
    .fetch_one(pool)
    .await
    .unwrap_or(0);

    // Get total assets count (assets table doesn't have deleted_at)
    let total_assets: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM assets"
    )
    .fetch_one(pool)
    .await
    .unwrap_or(0);

    // Get total teams count (teams table doesn't have deleted_at)
    let total_teams: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM teams"
    )
    .fetch_one(pool)
    .await
    .unwrap_or(0);

    // Get total users count (users table HAS deleted_at)
    let total_users: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM users WHERE deleted_at IS NULL"
    )
    .fetch_one(pool)
    .await
    .unwrap_or(0);

    // Get recent scans count (last 7 days)
    let recent_scans: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM vulnerabilities
         WHERE created_at >= NOW() - INTERVAL '7 days'"
    )
    .fetch_one(pool)
    .await
    .unwrap_or(0);

    // Get vulnerability trend for last 30 days
    let trend_query = sqlx::query_as::<_, (String, i64)>(
        "SELECT
            DATE(created_at) as date,
            COUNT(*) as count
         FROM vulnerabilities
         WHERE created_at >= NOW() - INTERVAL '30 days'
         GROUP BY DATE(created_at)
         ORDER BY date DESC
         LIMIT 30"
    )
    .fetch_all(pool)
    .await
    .unwrap_or_default();

    let vulnerability_trend: Vec<TrendData> = trend_query
        .into_iter()
        .map(|(date, count)| TrendData { date, count })
        .collect();

    // Severity distribution
    let severity_distribution = SeverityDistribution {
        critical: critical_vulnerabilities,
        high: high_vulnerabilities,
        medium: medium_vulnerabilities,
        low: low_vulnerabilities,
    };

    // Get top vulnerable assets
    let top_assets_query = sqlx::query_as::<_, (String, String, i64)>(
        "SELECT
            a.name as asset_name,
            a.asset_type,
            COUNT(v.id) as vulnerability_count
         FROM assets a
         LEFT JOIN vulnerabilities v ON v.asset_id = a.id AND v.status != 'resolved'
         GROUP BY a.id, a.name, a.asset_type
         HAVING COUNT(v.id) > 0
         ORDER BY vulnerability_count DESC
         LIMIT 10"
    )
    .fetch_all(pool)
    .await
    .unwrap_or_default();

    let top_vulnerable_assets: Vec<AssetVulnerabilityCount> = top_assets_query
        .into_iter()
        .map(|(asset_name, asset_type, vulnerability_count)| AssetVulnerabilityCount {
            asset_name,
            asset_type,
            vulnerability_count,
        })
        .collect();

    let stats = DashboardStats {
        total_vulnerabilities,
        critical_vulnerabilities,
        high_vulnerabilities,
        medium_vulnerabilities,
        low_vulnerabilities,
        resolved_vulnerabilities,
        total_assets,
        total_teams,
        total_users,
        recent_scans,
        vulnerability_trend,
        severity_distribution,
        top_vulnerable_assets,
    };

    Ok(Json(stats))
}
