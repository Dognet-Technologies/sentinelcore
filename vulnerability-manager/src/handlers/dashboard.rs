// src/handlers/dashboard.rs
// Dashboard statistics with real data from database

use axum::{
    extract::State,
    http::StatusCode,
    Json,
};
use serde::Serialize;
use crate::state::AppState;
use crate::auth::Claims;

#[derive(Debug, Serialize)]
pub struct DashboardStats {
    // Vulnerability metrics (only open + in_progress)
    pub total_vulnerabilities: i64,
    pub critical_vulnerabilities: i64,
    pub high_vulnerabilities: i64,
    pub medium_vulnerabilities: i64,
    pub low_vulnerabilities: i64,
    pub resolved_vulnerabilities: i64,

    // Asset metrics
    pub total_assets: i64,
    pub vulnerable_assets: i64,

    // Team and user metrics
    pub total_teams: i64,
    pub total_users: i64,
    pub recent_scans: i64,

    // Remediation metrics
    pub open_remediations: i64,
    pub in_progress_remediations: i64,
    pub completed_remediations: i64,

    // Performance metrics
    pub top_teams: Vec<TeamPerformance>,
    pub top_users: Vec<UserPerformance>,
    pub recent_assignments: Vec<RecentAssignment>,

    // Charts data
    pub vulnerability_trend: Vec<TrendData>,
    pub severity_distribution: SeverityDistribution,
    pub top_vulnerable_assets: Vec<AssetVulnerabilityCount>,
}

#[derive(Debug, Serialize)]
pub struct TrendData {
    pub date: String,
    pub count: i64,
}

#[derive(Debug, Serialize)]
pub struct SeverityDistribution {
    pub critical: i64,
    pub high: i64,
    pub medium: i64,
    pub low: i64,
}

#[derive(Debug, Serialize)]
pub struct AssetVulnerabilityCount {
    pub asset_name: String,
    pub asset_type: String,
    pub vulnerability_count: i64,
}

#[derive(Debug, Serialize)]
pub struct TeamPerformance {
    pub team_id: String,
    pub team_name: String,
    pub resolved_count: i64,
    pub assigned_count: i64,
    pub avg_resolution_time_days: Option<f64>,
}

#[derive(Debug, Serialize)]
pub struct UserPerformance {
    pub user_id: String,
    pub username: String,
    pub resolved_count: i64,
    pub assigned_count: i64,
    pub avg_resolution_time_days: Option<f64>,
}

#[derive(Debug, Serialize)]
pub struct RecentAssignment {
    pub vulnerability_id: String,
    pub title: String,
    pub severity: String,
    pub assigned_to_team: Option<String>,
    pub assigned_to_user: Option<String>,
    pub assigned_at: String,
}

/// Get dashboard statistics with real data from database
pub async fn get_dashboard_stats(
    State(state): State<AppState>,
    _claims: Claims,
) -> Result<Json<DashboardStats>, (StatusCode, String)> {
    let pool = &*state.pool;

    // Get total vulnerabilities count (only unresolved)
    let total_vulnerabilities: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM vulnerabilities WHERE status != 'resolved'"
    )
    .fetch_one(pool)
    .await
    .unwrap_or(0);

    // Get critical vulnerabilities count
    let critical_vulnerabilities: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM vulnerabilities WHERE severity = 'critical' AND status != 'resolved'"
    )
    .fetch_one(pool)
    .await
    .unwrap_or(0);

    // Get high vulnerabilities count
    let high_vulnerabilities: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM vulnerabilities WHERE severity = 'high' AND status != 'resolved'"
    )
    .fetch_one(pool)
    .await
    .unwrap_or(0);

    // Get medium vulnerabilities count
    let medium_vulnerabilities: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM vulnerabilities WHERE severity = 'medium' AND status != 'resolved'"
    )
    .fetch_one(pool)
    .await
    .unwrap_or(0);

    // Get low vulnerabilities count
    let low_vulnerabilities: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM vulnerabilities WHERE severity = 'low' AND status != 'resolved'"
    )
    .fetch_one(pool)
    .await
    .unwrap_or(0);

    // Get resolved vulnerabilities count
    let resolved_vulnerabilities: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM vulnerabilities WHERE status = 'resolved'"
    )
    .fetch_one(pool)
    .await
    .unwrap_or(0);

    // Get total assets count (assets table doesn't have deleted_at)
    let total_assets: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM assets"
    )
    .fetch_one(pool)
    .await
    .unwrap_or(0);

    // Get total teams count (teams table doesn't have deleted_at)
    let total_teams: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM teams"
    )
    .fetch_one(pool)
    .await
    .unwrap_or(0);

    // Get total users count (users table HAS deleted_at)
    let total_users: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM users WHERE deleted_at IS NULL"
    )
    .fetch_one(pool)
    .await
    .unwrap_or(0);

    // Get recent scans count (last 7 days)
    let recent_scans: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM network_scans
         WHERE status = 'completed' AND completed_at >= NOW() - INTERVAL '7 days'"
    )
    .fetch_one(pool)
    .await
    .unwrap_or(0);

    // Get vulnerability trend for last 30 days (only unresolved)
    let trend_query = sqlx::query_as::<_, (String, i64)>(
        "SELECT
            DATE(created_at)::text as date,
            COUNT(*) as count
         FROM vulnerabilities
         WHERE created_at >= NOW() - INTERVAL '30 days' AND status != 'resolved'
         GROUP BY DATE(created_at)
         ORDER BY date DESC
         LIMIT 30"
    )
    .fetch_all(pool)
    .await
    .unwrap_or_default();

    let vulnerability_trend: Vec<TrendData> = trend_query
        .into_iter()
        .map(|(date, count)| TrendData { date, count })
        .collect();

    // Severity distribution
    let severity_distribution = SeverityDistribution {
        critical: critical_vulnerabilities,
        high: high_vulnerabilities,
        medium: medium_vulnerabilities,
        low: low_vulnerabilities,
    };

    // Get top vulnerable assets
    let top_assets_query = sqlx::query_as::<_, (String, String, i64)>(
        "SELECT
            a.name as asset_name,
            a.asset_type::text as asset_type,
            COUNT(v.id) as vulnerability_count
         FROM assets a
         LEFT JOIN vulnerabilities v ON v.asset_id = a.id AND v.status != 'resolved'
         GROUP BY a.id, a.name, a.asset_type
         HAVING COUNT(v.id) > 0
         ORDER BY vulnerability_count DESC
         LIMIT 10"
    )
    .fetch_all(pool)
    .await
    .unwrap_or_default();

    let top_vulnerable_assets: Vec<AssetVulnerabilityCount> = top_assets_query
        .into_iter()
        .map(|(asset_name, asset_type, vulnerability_count)| AssetVulnerabilityCount {
            asset_name,
            asset_type,
            vulnerability_count,
        })
        .collect();

    // Count vulnerable assets (assets with at least one vulnerability)
    let vulnerable_assets: i64 = sqlx::query_scalar(
        "SELECT COUNT(DISTINCT asset_id) FROM vulnerabilities WHERE asset_id IS NOT NULL"
    )
    .fetch_one(pool)
    .await
    .unwrap_or(0);

    // Remediation metrics
    let open_remediations: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM remediation_plans WHERE status = 'open'"
    )
    .fetch_one(pool)
    .await
    .unwrap_or(0);

    let in_progress_remediations: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM remediation_plans WHERE status = 'in_progress'"
    )
    .fetch_one(pool)
    .await
    .unwrap_or(0);

    let completed_remediations: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM remediation_plans WHERE status = 'completed'"
    )
    .fetch_one(pool)
    .await
    .unwrap_or(0);

    // Top teams by resolved vulnerabilities (last 30 days)
    let top_teams_query = sqlx::query_as::<_, (String, String, i64, i64, Option<f64>)>(
        "SELECT
            t.id::text as team_id,
            t.name as team_name,
            COUNT(DISTINCT v.id) FILTER (WHERE v.status = 'resolved') as resolved_count,
            COUNT(DISTINCT v.id) as assigned_count,
            AVG(EXTRACT(EPOCH FROM (v.updated_at - v.created_at)) / 86400) FILTER (WHERE v.status = 'resolved') as avg_days
         FROM teams t
         LEFT JOIN vulnerabilities v ON v.assigned_team_id = t.id
         WHERE v.created_at >= NOW() - INTERVAL '30 days' OR v.created_at IS NULL
         GROUP BY t.id, t.name
         HAVING COUNT(DISTINCT v.id) FILTER (WHERE v.status = 'resolved') > 0
         ORDER BY resolved_count DESC
         LIMIT 5"
    )
    .fetch_all(pool)
    .await
    .unwrap_or_default();

    let top_teams: Vec<TeamPerformance> = top_teams_query
        .into_iter()
        .map(|(team_id, team_name, resolved_count, assigned_count, avg_days)| TeamPerformance {
            team_id,
            team_name,
            resolved_count,
            assigned_count,
            avg_resolution_time_days: avg_days,
        })
        .collect();

    // Top users by resolved vulnerabilities (last 30 days)
    let top_users_query = sqlx::query_as::<_, (String, String, i64, i64, Option<f64>)>(
        "SELECT
            u.id::text as user_id,
            u.username,
            COUNT(DISTINCT v.id) FILTER (WHERE v.status = 'resolved') as resolved_count,
            COUNT(DISTINCT v.id) as assigned_count,
            AVG(EXTRACT(EPOCH FROM (v.updated_at - v.created_at)) / 86400) FILTER (WHERE v.status = 'resolved') as avg_days
         FROM users u
         LEFT JOIN vulnerabilities v ON v.assigned_user_id = u.id
         WHERE (v.created_at >= NOW() - INTERVAL '30 days' OR v.created_at IS NULL) AND u.deleted_at IS NULL
         GROUP BY u.id, u.username
         HAVING COUNT(DISTINCT v.id) FILTER (WHERE v.status = 'resolved') > 0
         ORDER BY resolved_count DESC
         LIMIT 5"
    )
    .fetch_all(pool)
    .await
    .unwrap_or_default();

    let top_users: Vec<UserPerformance> = top_users_query
        .into_iter()
        .map(|(user_id, username, resolved_count, assigned_count, avg_days)| UserPerformance {
            user_id,
            username,
            resolved_count,
            assigned_count,
            avg_resolution_time_days: avg_days,
        })
        .collect();

    // Recent assignments (last 10)
    let recent_assignments_query = sqlx::query_as::<_, (String, String, String, Option<String>, Option<String>, String)>(
        "SELECT
            v.id::text as vulnerability_id,
            v.title,
            v.severity::text,
            t.name as team_name,
            u.username as user_name,
            v.updated_at::text
         FROM vulnerabilities v
         LEFT JOIN teams t ON t.id = v.assigned_team_id
         LEFT JOIN users u ON u.id = v.assigned_user_id
         WHERE v.assigned_team_id IS NOT NULL OR v.assigned_user_id IS NOT NULL
         ORDER BY v.updated_at DESC
         LIMIT 10"
    )
    .fetch_all(pool)
    .await
    .unwrap_or_default();

    let recent_assignments: Vec<RecentAssignment> = recent_assignments_query
        .into_iter()
        .map(|(vulnerability_id, title, severity, team_name, user_name, assigned_at)| RecentAssignment {
            vulnerability_id,
            title,
            severity,
            assigned_to_team: team_name,
            assigned_to_user: user_name,
            assigned_at,
        })
        .collect();

    let stats = DashboardStats {
        total_vulnerabilities,
        critical_vulnerabilities,
        high_vulnerabilities,
        medium_vulnerabilities,
        low_vulnerabilities,
        resolved_vulnerabilities,
        total_assets,
        vulnerable_assets,
        total_teams,
        total_users,
        recent_scans,
        open_remediations,
        in_progress_remediations,
        completed_remediations,
        top_teams,
        top_users,
        recent_assignments,
        vulnerability_trend,
        severity_distribution,
        top_vulnerable_assets,
    };

    Ok(Json(stats))
}

// Network topology types for Entuity-style visualization
#[derive(Debug, Serialize)]
pub struct NetworkTopology {
    pub devices: Vec<NetworkDeviceWithMetrics>,
    pub links: Vec<NetworkLink>,
    pub last_updated: String,
}

#[derive(Debug, Serialize)]
pub struct NetworkDeviceWithMetrics {
    pub id: String,
    pub name: String,
    pub asset_type: String,
    pub status: String,
    pub ip_address: Option<String>,
    pub mac_address: Option<String>,
    pub hostname: Option<String>,
    pub manufacturer: Option<String>,
    pub model: Option<String>,
    pub os_version: Option<String>,
    pub location: Option<DeviceLocation>,
    pub severity: String,
    pub incident_count: i64,
    pub last_seen: String,
    pub vulnerability_metrics: VulnerabilityMetrics,
    pub remediation_info: Option<RemediationInfo>,
    pub assignment: Option<DeviceAssignment>,
}

#[derive(Debug, Serialize)]
pub struct DeviceLocation {
    pub building: Option<String>,
    pub floor: Option<String>,
    pub room: Option<String>,
    pub datacenter: Option<String>,
}

#[derive(Debug, Serialize)]
pub struct VulnerabilityMetrics {
    pub total_vulnerabilities: i64,
    pub critical_count: i64,
    pub high_count: i64,
    pub medium_count: i64,
    pub low_count: i64,
    pub resolved_count: i64,
    pub risk_score: i32,
    pub last_scan_date: Option<String>,
    pub scan_status: String,
    pub compliance_score: Option<i32>,
}

#[derive(Debug, Serialize)]
pub struct RemediationInfo {
    pub last_remediation_date: Option<String>,
    pub last_remediation_type: Option<String>,
    pub pending_remediations: i64,
    pub applied_remediations: i64,
    pub failed_remediations: i64,
}

#[derive(Debug, Serialize)]
pub struct DeviceAssignment {
    pub assigned_team_id: Option<String>,
    pub assigned_team_name: Option<String>,
    pub assigned_user_id: Option<String>,
    pub assigned_user_name: Option<String>,
    pub assigned_date: Option<String>,
}

#[derive(Debug, Serialize)]
pub struct NetworkLink {
    pub id: String,
    pub source: String,
    pub target: String,
    pub status: String,
    pub utilization: i32,
    pub bandwidth: i32,
}

/// Get network topology with vulnerability metrics for Entuity-style dashboard
pub async fn get_network_topology(
    State(state): State<AppState>,
    _claims: Claims,
) -> Result<Json<NetworkTopology>, (StatusCode, String)> {
    let pool = &*state.pool;

    // Query all assets with aggregated vulnerability metrics
    let assets_query = sqlx::query!(
        r#"
        SELECT
            a.id,
            a.name,
            a.asset_type::text as "asset_type!",
            a.ip_address::text as ip_address,
            a.mac_address,
            a.hostname,
            a.operating_system,
            a.location,
            a.tags,
            a.created_at,
            a.updated_at,
            COUNT(DISTINCT v.id) FILTER (WHERE v.status != 'resolved') as active_vulns,
            COUNT(DISTINCT v.id) FILTER (WHERE v.severity = 'critical' AND v.status != 'resolved') as critical_count,
            COUNT(DISTINCT v.id) FILTER (WHERE v.severity = 'high' AND v.status != 'resolved') as high_count,
            COUNT(DISTINCT v.id) FILTER (WHERE v.severity = 'medium' AND v.status != 'resolved') as medium_count,
            COUNT(DISTINCT v.id) FILTER (WHERE v.severity = 'low' AND v.status != 'resolved') as low_count,
            COUNT(DISTINCT v.id) FILTER (WHERE v.status = 'resolved') as resolved_count,
            MAX(v.created_at) as last_scan_date
        FROM assets a
        LEFT JOIN vulnerabilities v ON v.asset_id = a.id
        GROUP BY a.id, a.name, a.asset_type, a.ip_address, a.mac_address, a.hostname, 
                 a.operating_system, a.location, a.tags, a.created_at, a.updated_at
        ORDER BY a.name
        "#
    )
    .fetch_all(pool)
    .await
    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

    let mut devices = Vec::new();

    for asset in assets_query {
        // Calculate risk score (0-100) based on vulnerabilities
        let critical = asset.critical_count.unwrap_or(0);
        let high = asset.high_count.unwrap_or(0);
        let medium = asset.medium_count.unwrap_or(0);
        let low = asset.low_count.unwrap_or(0);
        
        let risk_score = std::cmp::min(100, 
            (critical * 25 + high * 10 + medium * 5 + low * 2) as i32
        );

        // Determine overall severity
        let severity = if critical > 0 {
            "critical"
        } else if high > 0 {
            "high"
        } else if medium > 0 {
            "medium"
        } else if low > 0 {
            "low"
        } else {
            "none"
        };

        // Determine status (simplified - in production would check last_seen, etc.)
        let status = "online";

        // Get assignment info for this asset
        let assignment_query = sqlx::query!(
            r#"
            SELECT 
                v.assigned_team_id,
                t.name as team_name,
                v.assigned_user_id,
                u.username as user_name,
                v.updated_at
            FROM vulnerabilities v
            LEFT JOIN teams t ON t.id = v.assigned_team_id
            LEFT JOIN users u ON u.id = v.assigned_user_id
            WHERE v.asset_id = $1 
                AND v.assigned_team_id IS NOT NULL
            ORDER BY v.updated_at DESC
            LIMIT 1
            "#,
            asset.id
        )
        .fetch_optional(pool)
        .await
        .ok()
        .flatten();

        let assignment = assignment_query.map(|a| DeviceAssignment {
            assigned_team_id: a.assigned_team_id.map(|id| id.to_string()),
            assigned_team_name: Some(a.team_name),
            assigned_user_id: a.assigned_user_id.map(|id| id.to_string()),
            assigned_user_name: Some(a.user_name),
            assigned_date: Some(a.updated_at.to_rfc3339()),
        });

        // Parse location from string (format: "Building X - Floor Y")
        let location = asset.location.map(|loc| {
            let parts: Vec<&str> = loc.split(" - ").collect();
            DeviceLocation {
                building: parts.get(0).map(|s| s.to_string()),
                floor: parts.get(1).map(|s| s.to_string()),
                room: parts.get(2).map(|s| s.to_string()),
                datacenter: if loc.contains("Datacenter") {
                    Some(loc.clone())
                } else {
                    None
                },
            }
        });

        let device = NetworkDeviceWithMetrics {
            id: asset.id.to_string(),
            name: asset.name,
            asset_type: asset.asset_type,
            status: status.to_string(),
            ip_address: asset.ip_address,
            mac_address: asset.mac_address,
            hostname: asset.hostname,
            manufacturer: None, // Could be extracted from tags or separate field
            model: None,
            os_version: asset.operating_system,
            location,
            severity: severity.to_string(),
            incident_count: asset.active_vulns.unwrap_or(0),
            last_seen: asset.updated_at.to_rfc3339(),
            vulnerability_metrics: VulnerabilityMetrics {
                total_vulnerabilities: asset.active_vulns.unwrap_or(0) + asset.resolved_count.unwrap_or(0),
                critical_count: critical,
                high_count: high,
                medium_count: medium,
                low_count: low,
                resolved_count: asset.resolved_count.unwrap_or(0),
                risk_score,
                last_scan_date: asset.last_scan_date.map(|dt| dt.to_rfc3339()),
                scan_status: "completed".to_string(),
                compliance_score: Some(100 - risk_score),
            },
            remediation_info: None, // Could be calculated from vulnerability history
            assignment,
        };

        devices.push(device);
    }

    // Create simple network links (for topology visualization)
    // In production, this would come from actual network topology data
    let mut links = Vec::new();
    if devices.len() > 1 {
        // Create star topology with first device as hub
        for i in 1..devices.len() {
            links.push(NetworkLink {
                id: format!("link-{}", i),
                source: devices[0].id.clone(),
                target: devices[i].id.clone(),
                status: "active".to_string(),
                utilization: 45 + (i as i32 * 5) % 40, // Mock utilization
                bandwidth: 1000, // 1 Gbps
            });
        }
    }

    let topology = NetworkTopology {
        devices,
        links,
        last_updated: chrono::Utc::now().to_rfc3339(),
    };

    Ok(Json(topology))
}
