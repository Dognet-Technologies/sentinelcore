// src/main.rs
// FIXED: Corrected for Axum 0.6 compatibility (axum::serve doesn't exist in 0.6)

use anyhow::Result;
use sqlx::postgres::PgPoolOptions;
use std::net::SocketAddr;
use std::sync::Arc;
use std::time::Duration;
use tracing::info;
use tracing_subscriber::prelude::*;

// Import from the library crate instead of redefining modules
use vulnerability_manager::auth::Auth;
use vulnerability_manager::{config, api};
use vulnerability_manager::network::RemediationExecutor;

#[tokio::main]
async fn main() -> Result<()> {
    // Inizializza il logging
    tracing_subscriber::registry()
        .with(
            tracing_subscriber::fmt::layer()
                .with_target(false)
                .with_thread_ids(true)
                .with_level(true)
        )
        .with(tracing_subscriber::EnvFilter::from_default_env())
        .init();

    // Carica la configurazione
    let config = config::load_config()?;

    info!("üöÄ Starting Vulnerability Manager v{}", env!("CARGO_PKG_VERSION"));

    // Connetti al database con configurazioni ottimizzate
    let mut pool_opts = PgPoolOptions::new()
        .max_connections(config.database.max_connections);
    
    if let Some(timeout_secs) = config.database.connection_timeout_seconds {
        pool_opts = pool_opts.acquire_timeout(Duration::from_secs(timeout_secs));
    } else {
        pool_opts = pool_opts.acquire_timeout(Duration::from_secs(10));
    }
    
    if let Some(idle_secs) = config.database.idle_timeout_seconds {
        pool_opts = pool_opts.idle_timeout(Duration::from_secs(idle_secs));
    } else {
        pool_opts = pool_opts.idle_timeout(Duration::from_secs(600));
    }
    
    if let Some(lifetime_secs) = config.database.max_lifetime_seconds {
        pool_opts = pool_opts.max_lifetime(Duration::from_secs(lifetime_secs));
    } else {
        pool_opts = pool_opts.max_lifetime(Duration::from_secs(1800));
    }
    
    let pool = pool_opts.connect(&config.database.url).await?;

    info!("‚úÖ Connected to database (max_connections: {}, timeouts: acquire={}s, idle={}s)", 
          config.database.max_connections,
          config.database.connection_timeout_seconds.unwrap_or(10),
          config.database.idle_timeout_seconds.unwrap_or(600));

    // Esegui le migrazioni se disponibili
    // sqlx::migrate!("./migrations").run(&pool).await?;
    info!("‚úÖ Database migrations completed");

    // Salva server port prima di convertire config in Arc
    let server_port = config.server.port;

    // Crea istanze Arc per condivisione thread-safe
    let pool = Arc::new(pool);
    let auth = Arc::new(Auth::new(&config.auth));
    let config = Arc::new(config);

    info!("‚úÖ Authentication system initialized");

    // Start remediation executor worker
    let executor = RemediationExecutor::new((*pool).clone());
    executor.start_worker().await;
    info!("‚úÖ Remediation executor worker started");

    // Start background workers
    vulnerability_manager::workers::start_sla_checker(pool.clone());
    info!("‚úÖ SLA breach checker worker started");

    vulnerability_manager::workers::start_jira_sync(pool.clone());
    info!("‚úÖ JIRA sync worker started");

    vulnerability_manager::workers::start_notification_digest(pool.clone());
    info!("‚úÖ Notification digest worker started");

    vulnerability_manager::workers::start_nvd_enrichment(pool.clone());
    info!("‚úÖ NVD enrichment worker started");

    vulnerability_manager::workers::start_epss_updater(pool.clone());
    info!("‚úÖ EPSS updater worker started");

    vulnerability_manager::workers::start_report_generator(pool.clone());
    info!("‚úÖ Report generator worker started");

    // Crea il router dell'applicazione
    let app = api::create_router(pool, auth, config);

    // Configura l'indirizzo del server
    let addr = SocketAddr::from(([0, 0, 0, 0], server_port));
    info!("üåê Server listening on {}", addr);
    
    // FIXED: Usa axum::Server per Axum 0.6 invece di axum::serve (che non esiste)
    axum::Server::bind(&addr)
        .serve(app.into_make_service())
        .await?;
    
    Ok(())
}