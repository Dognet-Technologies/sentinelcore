// src/scanners/owasp_zap.rs
// OWASP ZAP JSON/XML scanner parser

use crate::scanners::{ScannerPlugin, ParsedVulnerability};
use anyhow::{Result, Context};
use serde::{Deserialize, Serialize};
use std::net::IpAddr;

pub struct OwaspZapScanner;

#[derive(Debug, Deserialize)]
struct ZapReport {
    #[serde(rename = "@version")]
    version: Option<String>,
    #[serde(rename = "@generated")]
    generated: Option<String>,
    site: Vec<ZapSite>,
}

#[derive(Debug, Deserialize)]
struct ZapSite {
    #[serde(rename = "@name")]
    name: String,
    #[serde(rename = "@host")]
    host: String,
    #[serde(rename = "@port")]
    port: String,
    #[serde(rename = "@ssl")]
    ssl: String,
    alerts: Option<ZapAlerts>,
}

#[derive(Debug, Deserialize)]
struct ZapAlerts {
    #[serde(rename = "alertitem", default)]
    items: Vec<ZapAlert>,
}

#[derive(Debug, Deserialize)]
struct ZapAlert {
    pluginid: String,
    alert: String,
    name: String,
    riskcode: String,
    confidence: String,
    riskdesc: String,
    desc: String,
    instances: Option<ZapInstances>,
    solution: Option<String>,
    reference: Option<String>,
    cweid: Option<String>,
    wascid: Option<String>,
}

#[derive(Debug, Deserialize)]
struct ZapInstances {
    #[serde(rename = "instance", default)]
    items: Vec<ZapInstance>,
}

#[derive(Debug, Deserialize)]
struct ZapInstance {
    uri: String,
    method: String,
    param: Option<String>,
    evidence: Option<String>,
}

#[async_trait::async_trait]
impl ScannerPlugin for OwaspZapScanner {
    fn name(&self) -> &str {
        "OWASP ZAP"
    }

    fn description(&self) -> &str {
        "OWASP Zed Attack Proxy XML/JSON Report Parser"
    }

    fn supported_formats(&self) -> Vec<&str> {
        vec!["xml", "json"]
    }

    async fn parse(&self, content: &str, format: &str) -> Result<Vec<ParsedVulnerability>> {
        match format {
            "xml" => self.parse_xml(content).await,
            "json" => self.parse_json(content).await,
            _ => Err(anyhow::anyhow!("Unsupported format: {}", format)),
        }
    }

    fn get_scanner_type(&self) -> &str {
        "web"
    }
}

impl OwaspZapScanner {
    pub fn new() -> Self {
        Self
    }

    async fn parse_xml(&self, content: &str) -> Result<Vec<ParsedVulnerability>> {
        let report: ZapReport = quick_xml::de::from_str(content)
            .context("Failed to parse ZAP XML report")?;

        let mut vulnerabilities = Vec::new();

        for site in report.site {
            let host = site.host.clone();
            let port: u16 = site.port.parse().unwrap_or(80);
            let ssl = site.ssl == "true";
            let protocol = if ssl { "https" } else { "http" };

            if let Some(alerts) = site.alerts {
                for alert in alerts.items {
                    let severity = self.map_risk_to_severity(&alert.riskcode);
                    let cvss_score = self.estimate_cvss(&alert.riskcode);

                    let description = format!(
                        "{}\n\nConfidence: {}\nPlugin ID: {}",
                        alert.desc, alert.confidence, alert.pluginid
                    );

                    let vuln = ParsedVulnerability {
                        title: alert.name.clone(),
                        description: Some(description),
                        severity,
                        cvss_score: Some(cvss_score),
                        epss_score: None,
                        cve_id: None,
                        cwe_id: alert.cweid.clone(),
                        ip_address: host.parse().ok(),
                        hostname: Some(host.clone()),
                        port: Some(port),
                        protocol: Some(protocol.to_string()),
                        service: None,
                        operating_system: None,
                        solution: alert.solution.clone(),
                        references: alert.reference.clone(),
                        exploit_available: None,
                        scanner_name: self.name().to_string(),
                        raw_data: serde_json::to_value(&alert).ok(),
                    };

                    vulnerabilities.push(vuln);
                }
            }
        }

        Ok(vulnerabilities)
    }

    async fn parse_json(&self, content: &str) -> Result<Vec<ParsedVulnerability>> {
        // JSON parsing similar to XML
        let report: serde_json::Value = serde_json::from_str(content)?;

        // TODO: Implement JSON parsing (ZAP can export in multiple JSON formats)
        // For now, return empty vec
        Ok(Vec::new())
    }

    fn map_risk_to_severity(&self, risk: &str) -> String {
        match risk {
            "3" => "Critical".to_string(),
            "2" => "High".to_string(),
            "1" => "Medium".to_string(),
            "0" => "Low".to_string(),
            _ => "Info".to_string(),
        }
    }

    fn estimate_cvss(&self, risk: &str) -> f32 {
        match risk {
            "3" => 9.0,  // Critical
            "2" => 7.0,  // High
            "1" => 5.0,  // Medium
            "0" => 2.0,  // Low
            _ => 0.0,    // Info
        }
    }
}
