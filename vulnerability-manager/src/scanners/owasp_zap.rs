// src/scanners/owasp_zap.rs
// OWASP ZAP JSON/XML scanner parser

use crate::scanners::{ScannerPlugin, ScannerMetadata, ParsedVulnerability, VulnerabilitySeverity};
use anyhow::{Result, Context};
use serde::{Deserialize, Serialize};

pub struct OwaspZapPlugin {
    metadata: ScannerMetadata,
}

#[derive(Debug, Deserialize)]
struct ZapReport {
    #[serde(rename = "@version")]
    version: Option<String>,
    #[serde(rename = "@generated")]
    generated: Option<String>,
    site: Vec<ZapSite>,
}

#[derive(Debug, Deserialize)]
struct ZapSite {
    #[serde(rename = "@name")]
    name: String,
    #[serde(rename = "@host")]
    host: String,
    #[serde(rename = "@port")]
    port: String,
    #[serde(rename = "@ssl")]
    ssl: String,
    alerts: Option<ZapAlerts>,
}

#[derive(Debug, Deserialize)]
struct ZapAlerts {
    #[serde(rename = "alertitem", default)]
    items: Vec<ZapAlert>,
}

#[derive(Debug, Deserialize, Serialize)]
struct ZapAlert {
    pluginid: String,
    alert: String,
    name: String,
    riskcode: String,
    confidence: String,
    riskdesc: String,
    desc: String,
    instances: Option<ZapInstances>,
    solution: Option<String>,
    reference: Option<String>,
    cweid: Option<String>,
    wascid: Option<String>,
}

#[derive(Debug, Deserialize, Serialize)]
struct ZapInstances {
    #[serde(rename = "instance", default)]
    items: Vec<ZapInstance>,
}

#[derive(Debug, Deserialize, Serialize)]
struct ZapInstance {
    uri: String,
    method: String,
    param: Option<String>,
    evidence: Option<String>,
}

impl OwaspZapPlugin {
    pub fn new() -> Self {
        Self {
            metadata: ScannerMetadata {
                name: "owasp_zap".to_string(),
                display_name: "OWASP ZAP".to_string(),
                version: "1.0.0".to_string(),
                description: "OWASP Zed Attack Proxy XML/JSON Report Parser".to_string(),
                supported_formats: vec!["xml".to_string(), "json".to_string()],
                vendor: "OWASP".to_string(),
            },
        }
    }

    async fn parse_xml(&self, content: &str) -> Result<Vec<ParsedVulnerability>> {
        let report: ZapReport = quick_xml::de::from_str(content)
            .context("Failed to parse ZAP XML report")?;

        let mut vulnerabilities = Vec::new();

        for site in report.site {
            let host = site.host.clone();
            let port: u16 = site.port.parse().unwrap_or(80);
            let ssl = site.ssl == "true";
            let protocol = if ssl { "https" } else { "http" };

            if let Some(alerts) = site.alerts {
                for alert in alerts.items {
                    let severity = self.map_risk_to_severity(&alert.riskcode);
                    let cvss_score = self.estimate_cvss(&alert.riskcode);

                    let description = format!(
                        "{}\n\nConfidence: {}\nPlugin ID: {}",
                        alert.desc, alert.confidence, alert.pluginid
                    );

                    let cwe_ids = if let Some(ref cwe) = alert.cweid {
                        vec![cwe.clone()]
                    } else {
                        vec![]
                    };

                    let references = if let Some(ref ref_str) = alert.reference {
                        ref_str.split('\n').map(|s| s.to_string()).collect()
                    } else {
                        vec![]
                    };

                    let vuln = ParsedVulnerability {
                        scanner_id: alert.pluginid.clone(),
                        title: alert.name.clone(),
                        description,
                        severity,
                        cvss_score: Some(cvss_score),
                        cvss_vector: None,
                        cve_ids: vec![],
                        cwe_ids,
                        tags: vec!["web".to_string()],
                        host: host.clone(),
                        port: Some(port),
                        protocol: Some(protocol.to_string()),
                        service: None,
                        solution: alert.solution.clone(),
                        references,
                        first_detected: None,
                        last_detected: None,
                        raw_data: serde_json::to_value(&alert).ok(),
                    };

                    vulnerabilities.push(vuln);
                }
            }
        }

        Ok(vulnerabilities)
    }

    async fn parse_json(&self, content: &str) -> Result<Vec<ParsedVulnerability>> {
        // JSON parsing similar to XML
        let _report: serde_json::Value = serde_json::from_str(content)?;

        // TODO: Implement JSON parsing (ZAP can export in multiple JSON formats)
        // For now, return empty vec
        Ok(Vec::new())
    }

    fn map_risk_to_severity(&self, risk: &str) -> VulnerabilitySeverity {
        match risk {
            "3" => VulnerabilitySeverity::Critical,
            "2" => VulnerabilitySeverity::High,
            "1" => VulnerabilitySeverity::Medium,
            "0" => VulnerabilitySeverity::Low,
            _ => VulnerabilitySeverity::Info,
        }
    }

    fn estimate_cvss(&self, risk: &str) -> f32 {
        match risk {
            "3" => 9.0,  // Critical
            "2" => 7.0,  // High
            "1" => 5.0,  // Medium
            "0" => 2.0,  // Low
            _ => 0.0,    // Info
        }
    }
}

#[async_trait::async_trait]
impl ScannerPlugin for OwaspZapPlugin {
    fn metadata(&self) -> &ScannerMetadata {
        &self.metadata
    }

    async fn parse(&self, data: &[u8], format: &str) -> Result<Vec<ParsedVulnerability>> {
        let content = std::str::from_utf8(data)
            .context("Invalid UTF-8 in scan data")?;

        match format {
            "xml" => self.parse_xml(content).await,
            "json" => self.parse_json(content).await,
            _ => Err(anyhow::anyhow!("Unsupported format: {}", format)),
        }
    }

    fn validate(&self, data: &[u8], format: &str) -> Result<bool> {
        let content = std::str::from_utf8(data)?;

        match format {
            "xml" => {
                // Try to parse as XML to validate
                let result: Result<ZapReport, _> = quick_xml::de::from_str(content);
                Ok(result.is_ok())
            }
            "json" => {
                // Try to parse as JSON to validate
                let result: Result<serde_json::Value, _> = serde_json::from_str(content);
                Ok(result.is_ok())
            }
            _ => Ok(false),
        }
    }
}
