// src/scanners/grype.rs
// Anchore Grype vulnerability scanner plugin

use super::{ParsedVulnerability, ScannerMetadata, ScannerPlugin, VulnerabilitySeverity};
use async_trait::async_trait;
use anyhow::{anyhow, Result};
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
struct GrypeScan {
    #[serde(rename = "schema")]
    schema: GrypeScanSchema,
    #[serde(rename = "source")]
    source: GryeSource,
    #[serde(rename = "distroSource")]
    distro_source: Option<GryeDistroSource>,
    #[serde(rename = "matches")]
    matches: Vec<GryeMatch>,
    #[serde(rename = "metadata")]
    metadata: GrypeScanMetadata,
}

#[derive(Debug, Serialize, Deserialize)]
struct GrypeScanSchema {
    version: String,
}

#[derive(Debug, Serialize, Deserialize)]
struct GryeSource {
    #[serde(rename = "type")]
    source_type: String,
    target: String,
}

#[derive(Debug, Serialize, Deserialize)]
struct GryeDistroSource {
    #[serde(rename = "prettyName")]
    pretty_name: Option<String>,
}

#[derive(Debug, Serialize, Deserialize)]
struct GryeMatch {
    pub vulnerability: GryeVulnerability,
    pub artifact: GryeArtifact,
}

#[derive(Debug, Serialize, Deserialize)]
struct GryeVulnerability {
    #[serde(rename = "ID")]
    id: String,
    #[serde(rename = "DataSource")]
    data_source: String,
    #[serde(rename = "Namespace")]
    namespace: String,
    #[serde(rename = "Severity")]
    severity: String,
    #[serde(rename = "URLs")]
    urls: Option<Vec<String>>,
    #[serde(rename = "Description")]
    description: Option<String>,
    #[serde(rename = "Cvss")]
    cvss: Option<Vec<GrypeCVSS>>,
    #[serde(rename = "Fix")]
    fix: Option<GrypeFix>,
    #[serde(rename = "CweIDs")]
    cwe_ids: Option<Vec<String>>,
    #[serde(rename = "RelatedVulnerabilities")]
    related_vulnerabilities: Option<Vec<String>>,
    #[serde(rename = "PublishedTime")]
    published_time: Option<String>,
}

#[derive(Debug, Serialize, Deserialize)]
struct GrypeCVSS {
    #[serde(rename = "Metrics")]
    metrics: Option<GrypeCVSSMetrics>,
}

#[derive(Debug, Serialize, Deserialize)]
struct GrypeCVSSMetrics {
    #[serde(rename = "BaseScore")]
    base_score: Option<f32>,
}

#[derive(Debug, Serialize, Deserialize)]
struct GrypeFix {
    #[serde(rename = "State")]
    state: String,
    #[serde(rename = "Versions")]
    versions: Option<Vec<String>>,
}

#[derive(Debug, Serialize, Deserialize)]
struct GryeArtifact {
    #[serde(rename = "ID")]
    id: String,
    #[serde(rename = "Name")]
    name: String,
    #[serde(rename = "Version")]
    version: String,
    #[serde(rename = "Type")]
    artifact_type: String,
    #[serde(rename = "Locations")]
    locations: Option<Vec<GryeLocation>>,
    #[serde(rename = "Language")]
    language: Option<String>,
}

#[derive(Debug, Serialize, Deserialize)]
struct GryeLocation {
    #[serde(rename = "Path")]
    path: String,
}

#[derive(Debug, Serialize, Deserialize)]
struct GrypeScanMetadata {
    #[serde(rename = "timestamp")]
    timestamp: String,
    #[serde(rename = "tool")]
    tool: GrypeTool,
}

#[derive(Debug, Serialize, Deserialize)]
struct GrypeTool {
    #[serde(rename = "name")]
    name: String,
    #[serde(rename = "version")]
    version: String,
}

pub struct GrypePlugin;

impl GrypePlugin {
    pub fn new() -> Self {
        Self
    }

    fn parse_severity(&self, severity_str: &str) -> VulnerabilitySeverity {
        match severity_str.to_uppercase().as_str() {
            "CRITICAL" => VulnerabilitySeverity::Critical,
            "HIGH" => VulnerabilitySeverity::High,
            "MEDIUM" => VulnerabilitySeverity::Medium,
            "LOW" => VulnerabilitySeverity::Low,
            _ => VulnerabilitySeverity::Info,
        }
    }

    fn extract_cvss_score(&self, cvss: &Option<Vec<GrypeCVSS>>) -> Option<f32> {
        cvss.as_ref()
            .and_then(|scores| scores.first())
            .and_then(|score| score.metrics.as_ref())
            .and_then(|metrics| metrics.base_score)
    }
}

#[async_trait]
impl ScannerPlugin for GrypePlugin {
    fn metadata(&self) -> &ScannerMetadata {
        &GRYPE_METADATA
    }

    async fn parse(&self, data: &[u8], format: &str) -> Result<Vec<ParsedVulnerability>> {
        match format.to_lowercase().as_str() {
            "json" => self.parse_json(data),
            _ => Err(anyhow!("Unsupported format: {}", format)),
        }
    }

    fn validate(&self, data: &[u8], format: &str) -> Result<bool> {
        match format.to_lowercase().as_str() {
            "json" => {
                match serde_json::from_slice::<GrypeScan>(data) {
                    Ok(_) => Ok(true),
                    Err(_) => Ok(false),
                }
            }
            _ => Ok(false),
        }
    }
}

impl GrypePlugin {
    fn parse_json(&self, data: &[u8]) -> Result<Vec<ParsedVulnerability>> {
        let scan: GrypeScan = serde_json::from_slice(data)?;
        let mut vulnerabilities = Vec::new();

        let scan_time = DateTime::parse_from_rfc3339(&scan.metadata.timestamp)
            .ok()
            .map(|dt| dt.with_timezone(&Utc));

        for grype_match in scan.matches {
            let vuln = &grype_match.vulnerability;
            let artifact = &grype_match.artifact;

            let mut cve_ids = vec![];
            let mut cwe_ids = vuln.cwe_ids.clone().unwrap_or_default();

            // Grype ID might be a CVE
            if vuln.id.starts_with("CVE-") {
                cve_ids.push(vuln.id.clone());
            }

            // Add related vulnerabilities as CVE IDs
            if let Some(related) = &vuln.related_vulnerabilities {
                for related_id in related {
                    if related_id.starts_with("CVE-") && !cve_ids.contains(related_id) {
                        cve_ids.push(related_id.clone());
                    }
                }
            }

            let mut references = vuln.urls.clone().unwrap_or_default();

            // Add data source URL
            if !vuln.data_source.is_empty() {
                references.push(format!("Source: {}", vuln.data_source));
            }

            let solution = vuln
                .fix
                .as_ref()
                .and_then(|fix| fix.versions.as_ref())
                .and_then(|v| v.first())
                .map(|v| format!("Update to {}", v));

            let parsed = ParsedVulnerability {
                scanner_id: vuln.id.clone(),
                title: format!("{} in {}", vuln.id, artifact.name),
                description: vuln.description.as_ref().unwrap_or(&String::new()).clone(),
                severity: self.parse_severity(&vuln.severity),
                cvss_score: self.extract_cvss_score(&vuln.cvss),
                cvss_vector: None,
                cve_ids,
                cwe_ids,
                tags: vec![
                    artifact.artifact_type.clone(),
                    artifact.language.as_ref().unwrap_or(&"unknown".to_string()).clone(),
                    vuln.namespace.clone(),
                ],
                host: scan.source.target.clone(),
                port: None,
                protocol: None,
                service: None,
                solution,
                references,
                first_detected: scan_time,
                last_detected: scan_time,
                raw_data: Some(serde_json::json!({
                    "vulnerability": vuln,
                    "artifact": artifact
                })),
            };

            vulnerabilities.push(parsed);
        }

        Ok(vulnerabilities)
    }
}

const GRYPE_METADATA: ScannerMetadata = ScannerMetadata {
    name: "grype",
    display_name: "Anchore Grype",
    version: "0.1.0",
    description: "Anchore Grype - Vulnerability scanner for container images and filesystems",
    supported_formats: &["json"],
    vendor: "Anchore",
};
