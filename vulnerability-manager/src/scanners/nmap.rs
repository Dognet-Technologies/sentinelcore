// src/scanners/nmap.rs
// Nmap XML scanner parser with NSE script output

use crate::scanners::{ScannerPlugin, ParsedVulnerability};
use anyhow::{Result, Context};
use serde::{Deserialize, Serialize};
use std::net::IpAddr;

pub struct NmapScanner;

#[derive(Debug, Deserialize)]
struct NmapRun {
    #[serde(rename = "@scanner")]
    scanner: Option<String>,
    #[serde(rename = "@version")]
    version: Option<String>,
    #[serde(rename = "host", default)]
    hosts: Vec<NmapHost>,
}

#[derive(Debug, Deserialize)]
struct NmapHost {
    #[serde(rename = "address")]
    addresses: Vec<NmapAddress>,
    #[serde(rename = "hostnames")]
    hostnames: Option<NmapHostnames>,
    #[serde(rename = "ports")]
    ports: Option<NmapPorts>,
    #[serde(rename = "os")]
    os: Option<NmapOs>,
}

#[derive(Debug, Deserialize)]
struct NmapAddress {
    #[serde(rename = "@addr")]
    addr: String,
    #[serde(rename = "@addrtype")]
    addrtype: String,
}

#[derive(Debug, Deserialize)]
struct NmapHostnames {
    #[serde(rename = "hostname", default)]
    hostnames: Vec<NmapHostname>,
}

#[derive(Debug, Deserialize)]
struct NmapHostname {
    #[serde(rename = "@name")]
    name: String,
}

#[derive(Debug, Deserialize)]
struct NmapPorts {
    #[serde(rename = "port", default)]
    ports: Vec<NmapPort>,
}

#[derive(Debug, Deserialize)]
struct NmapPort {
    #[serde(rename = "@protocol")]
    protocol: String,
    #[serde(rename = "@portid")]
    portid: String,
    #[serde(rename = "state")]
    state: NmapState,
    #[serde(rename = "service")]
    service: Option<NmapService>,
    #[serde(rename = "script", default)]
    scripts: Vec<NmapScript>,
}

#[derive(Debug, Deserialize)]
struct NmapState {
    #[serde(rename = "@state")]
    state: String,
}

#[derive(Debug, Deserialize)]
struct NmapService {
    #[serde(rename = "@name")]
    name: String,
    #[serde(rename = "@product")]
    product: Option<String>,
    #[serde(rename = "@version")]
    version: Option<String>,
}

#[derive(Debug, Deserialize)]
struct NmapScript {
    #[serde(rename = "@id")]
    id: String,
    #[serde(rename = "@output")]
    output: String,
}

#[derive(Debug, Deserialize)]
struct NmapOs {
    #[serde(rename = "osmatch", default)]
    matches: Vec<NmapOsMatch>,
}

#[derive(Debug, Deserialize)]
struct NmapOsMatch {
    #[serde(rename = "@name")]
    name: String,
    #[serde(rename = "@accuracy")]
    accuracy: String,
}

#[async_trait::async_trait]
impl ScannerPlugin for NmapScanner {
    fn name(&self) -> &str {
        "Nmap"
    }

    fn description(&self) -> &str {
        "Nmap Network Scanner with NSE script support"
    }

    fn supported_formats(&self) -> Vec<&str> {
        vec!["xml"]
    }

    async fn parse(&self, content: &str, _format: &str) -> Result<Vec<ParsedVulnerability>> {
        let run: NmapRun = quick_xml::de::from_str(content)
            .context("Failed to parse Nmap XML report")?;

        let mut vulnerabilities = Vec::new();

        for host in run.hosts {
            let ip = host.addresses.iter()
                .find(|a| a.addrtype == "ipv4")
                .map(|a| a.addr.clone())
                .unwrap_or_default();

            let hostname = host.hostnames
                .and_then(|h| h.hostnames.first().map(|hn| hn.name.clone()));

            let os = host.os
                .and_then(|o| o.matches.first().map(|m| m.name.clone()));

            if let Some(ports_data) = host.ports {
                for port in ports_data.ports {
                    if port.state.state != "open" {
                        continue;
                    }

                    let port_num: u16 = port.portid.parse().unwrap_or(0);
                    let service = port.service
                        .as_ref()
                        .map(|s| format!("{} {}", s.name, s.version.as_ref().unwrap_or(&String::new())))
                        .unwrap_or_else(|| "unknown".to_string());

                    // Parse NSE scripts for vulnerabilities
                    for script in &port.scripts {
                        if self.is_vulnerability_script(&script.id) {
                            let (severity, cvss) = self.estimate_severity_from_script(&script.id, &script.output);

                            let vuln = ParsedVulnerability {
                                title: format!("{} on {}", script.id, service),
                                description: Some(script.output.clone()),
                                severity,
                                cvss_score: Some(cvss),
                                epss_score: None,
                                cve_id: self.extract_cve_from_output(&script.output),
                                cwe_id: None,
                                ip_address: ip.parse().ok(),
                                hostname: hostname.clone(),
                                port: Some(port_num),
                                protocol: Some(port.protocol.clone()),
                                service: Some(service.clone()),
                                operating_system: os.clone(),
                                solution: None,
                                references: None,
                                exploit_available: None,
                                scanner_name: self.name().to_string(),
                                raw_data: serde_json::to_value(&script).ok(),
                            };

                            vulnerabilities.push(vuln);
                        }
                    }

                    // Check for outdated services
                    if let Some(svc) = &port.service {
                        if svc.version.is_some() {
                            // Potential outdated service
                            let vuln = ParsedVulnerability {
                                title: format!("Potentially outdated service: {}", svc.name),
                                description: Some(format!("Service {} version {} detected", svc.name, svc.version.as_ref().unwrap())),
                                severity: "Info".to_string(),
                                cvss_score: Some(0.0),
                                epss_score: None,
                                cve_id: None,
                                cwe_id: None,
                                ip_address: ip.parse().ok(),
                                hostname: hostname.clone(),
                                port: Some(port_num),
                                protocol: Some(port.protocol.clone()),
                                service: Some(service.clone()),
                                operating_system: os.clone(),
                                solution: Some("Verify if service version is up-to-date".to_string()),
                                references: None,
                                exploit_available: None,
                                scanner_name: self.name().to_string(),
                                raw_data: None,
                            };
                            vulnerabilities.push(vuln);
                        }
                    }
                }
            }
        }

        Ok(vulnerabilities)
    }

    fn get_scanner_type(&self) -> &str {
        "network"
    }
}

impl NmapScanner {
    pub fn new() -> Self {
        Self
    }

    fn is_vulnerability_script(&self, script_id: &str) -> bool {
        script_id.contains("vuln") ||
        script_id.contains("exploit") ||
        script_id.contains("cve") ||
        script_id.contains("auth") ||
        script_id.contains("brute") ||
        script_id.contains("dos")
    }

    fn estimate_severity_from_script(&self, script_id: &str, output: &str) -> (String, f32) {
        if output.to_lowercase().contains("critical") || script_id.contains("exploit") {
            ("Critical".to_string(), 9.0)
        } else if output.to_lowercase().contains("high") || script_id.contains("dos") {
            ("High".to_string(), 7.0)
        } else if output.to_lowercase().contains("medium") || script_id.contains("brute") {
            ("Medium".to_string(), 5.0)
        } else {
            ("Low".to_string(), 3.0)
        }
    }

    fn extract_cve_from_output(&self, output: &str) -> Option<String> {
        // Simple CVE extraction from script output
        if let Some(idx) = output.find("CVE-") {
            let cve_part = &output[idx..];
            if let Some(end) = cve_part.find(|c: char| !c.is_alphanumeric() && c != '-') {
                return Some(cve_part[..end].to_string());
            }
        }
        None
    }
}
