// src/scanners/nmap.rs
// Nmap XML scanner parser with NSE script output

use crate::scanners::{ScannerPlugin, ScannerMetadata, ParsedVulnerability, VulnerabilitySeverity};
use anyhow::{Result, Context};
use serde::Deserialize;

pub struct NmapPlugin {
    metadata: ScannerMetadata,
}

#[derive(Debug, Deserialize)]
struct NmapRun {
    #[serde(rename = "@scanner")]
    scanner: Option<String>,
    #[serde(rename = "@version")]
    version: Option<String>,
    #[serde(rename = "host", default)]
    hosts: Vec<NmapHost>,
}

#[derive(Debug, Deserialize)]
struct NmapHost {
    #[serde(rename = "address")]
    addresses: Vec<NmapAddress>,
    #[serde(rename = "hostnames")]
    hostnames: Option<NmapHostnames>,
    #[serde(rename = "ports")]
    ports: Option<NmapPorts>,
    #[serde(rename = "os")]
    os: Option<NmapOs>,
}

#[derive(Debug, Deserialize)]
struct NmapAddress {
    #[serde(rename = "@addr")]
    addr: String,
    #[serde(rename = "@addrtype")]
    addrtype: String,
}

#[derive(Debug, Deserialize)]
struct NmapHostnames {
    #[serde(rename = "hostname", default)]
    hostnames: Vec<NmapHostname>,
}

#[derive(Debug, Deserialize)]
struct NmapHostname {
    #[serde(rename = "@name")]
    name: String,
}

#[derive(Debug, Deserialize)]
struct NmapPorts {
    #[serde(rename = "port", default)]
    ports: Vec<NmapPort>,
}

#[derive(Debug, Deserialize)]
struct NmapPort {
    #[serde(rename = "@protocol")]
    protocol: String,
    #[serde(rename = "@portid")]
    portid: String,
    #[serde(rename = "state")]
    state: NmapState,
    #[serde(rename = "service")]
    service: Option<NmapService>,
    #[serde(rename = "script", default)]
    scripts: Vec<NmapScript>,
}

#[derive(Debug, Deserialize)]
struct NmapState {
    #[serde(rename = "@state")]
    state: String,
}

#[derive(Debug, Deserialize)]
struct NmapService {
    #[serde(rename = "@name")]
    name: String,
    #[serde(rename = "@product")]
    product: Option<String>,
    #[serde(rename = "@version")]
    version: Option<String>,
}

#[derive(Debug, Deserialize)]
struct NmapScript {
    #[serde(rename = "@id")]
    id: String,
    #[serde(rename = "@output")]
    output: String,
}

#[derive(Debug, Deserialize)]
struct NmapOs {
    #[serde(rename = "osmatch", default)]
    matches: Vec<NmapOsMatch>,
}

#[derive(Debug, Deserialize)]
struct NmapOsMatch {
    #[serde(rename = "@name")]
    name: String,
    #[serde(rename = "@accuracy")]
    accuracy: String,
}

impl NmapPlugin {
    pub fn new() -> Self {
        Self {
            metadata: ScannerMetadata {
                name: "nmap".to_string(),
                display_name: "Nmap".to_string(),
                version: "1.0.0".to_string(),
                description: "Nmap Network Scanner with NSE script support".to_string(),
                supported_formats: vec!["xml".to_string()],
                vendor: "Nmap Project".to_string(),
            },
        }
    }

    fn parse_xml(&self, content: &str) -> Result<Vec<ParsedVulnerability>> {
        let run: NmapRun = quick_xml::de::from_str(content)
            .context("Failed to parse Nmap XML report")?;

        let mut vulnerabilities = Vec::new();

        for host in run.hosts {
            let ip = host.addresses.iter()
                .find(|a| a.addrtype == "ipv4")
                .map(|a| a.addr.clone())
                .unwrap_or_default();

            let hostname = host.hostnames
                .and_then(|h| h.hostnames.first().map(|hn| hn.name.clone()));

            if let Some(ports_data) = host.ports {
                for port in ports_data.ports {
                    if port.state.state != "open" {
                        continue;
                    }

                    let port_num: u16 = port.portid.parse().unwrap_or(0);
                    let service_name = port.service
                        .as_ref()
                        .map(|s| s.name.clone())
                        .unwrap_or_else(|| "unknown".to_string());

                    // Parse NSE scripts for vulnerabilities
                    for script in &port.scripts {
                        if self.is_vulnerability_script(&script.id) {
                            let (severity, cvss) = self.estimate_severity_from_script(&script.id, &script.output);
                            let cve_ids = self.extract_cves_from_output(&script.output);

                            let vuln = ParsedVulnerability {
                                scanner_id: script.id.clone(),
                                title: format!("{} on {}", script.id, service_name),
                                description: script.output.clone(),
                                severity,
                                cvss_score: Some(cvss),
                                cvss_vector: None,
                                cve_ids,
                                cwe_ids: vec![],
                                tags: vec!["network".to_string()],
                                host: ip.clone(),
                                port: Some(port_num),
                                protocol: Some(port.protocol.clone()),
                                service: Some(service_name.clone()),
                                solution: None,
                                references: vec![],
                                first_detected: None,
                                last_detected: None,
                                raw_data: serde_json::to_value(&script).ok(),
                            };

                            vulnerabilities.push(vuln);
                        }
                    }

                    // Check for outdated services
                    if let Some(svc) = &port.service {
                        if svc.version.is_some() {
                            // Potential outdated service
                            let vuln = ParsedVulnerability {
                                scanner_id: format!("outdated-{}-{}", svc.name, port_num),
                                title: format!("Potentially outdated service: {}", svc.name),
                                description: format!("Service {} version {} detected",
                                    svc.name,
                                    svc.version.as_ref().unwrap()),
                                severity: VulnerabilitySeverity::Info,
                                cvss_score: Some(0.0),
                                cvss_vector: None,
                                cve_ids: vec![],
                                cwe_ids: vec![],
                                tags: vec!["network".to_string(), "service-version".to_string()],
                                host: ip.clone(),
                                port: Some(port_num),
                                protocol: Some(port.protocol.clone()),
                                service: Some(service_name.clone()),
                                solution: Some("Verify if service version is up-to-date".to_string()),
                                references: vec![],
                                first_detected: None,
                                last_detected: None,
                                raw_data: None,
                            };
                            vulnerabilities.push(vuln);
                        }
                    }
                }
            }
        }

        Ok(vulnerabilities)
    }

    fn is_vulnerability_script(&self, script_id: &str) -> bool {
        script_id.contains("vuln") ||
        script_id.contains("exploit") ||
        script_id.contains("cve") ||
        script_id.contains("auth") ||
        script_id.contains("brute") ||
        script_id.contains("dos")
    }

    fn estimate_severity_from_script(&self, script_id: &str, output: &str) -> (VulnerabilitySeverity, f32) {
        if output.to_lowercase().contains("critical") || script_id.contains("exploit") {
            (VulnerabilitySeverity::Critical, 9.0)
        } else if output.to_lowercase().contains("high") || script_id.contains("dos") {
            (VulnerabilitySeverity::High, 7.0)
        } else if output.to_lowercase().contains("medium") || script_id.contains("brute") {
            (VulnerabilitySeverity::Medium, 5.0)
        } else {
            (VulnerabilitySeverity::Low, 3.0)
        }
    }

    fn extract_cves_from_output(&self, output: &str) -> Vec<String> {
        let mut cves = Vec::new();
        let mut search_from = 0;

        while let Some(idx) = output[search_from..].find("CVE-") {
            let abs_idx = search_from + idx;
            let cve_part = &output[abs_idx..];

            if let Some(end) = cve_part.find(|c: char| !c.is_alphanumeric() && c != '-') {
                cves.push(cve_part[..end].to_string());
                search_from = abs_idx + end;
            } else {
                break;
            }
        }

        cves
    }
}

#[async_trait::async_trait]
impl ScannerPlugin for NmapPlugin {
    fn metadata(&self) -> &ScannerMetadata {
        &self.metadata
    }

    async fn parse(&self, data: &[u8], _format: &str) -> Result<Vec<ParsedVulnerability>> {
        let content = std::str::from_utf8(data)
            .context("Invalid UTF-8 in scan data")?;

        self.parse_xml(content)
    }

    fn validate(&self, data: &[u8], _format: &str) -> Result<bool> {
        let content = std::str::from_utf8(data)?;

        // Try to parse as XML to validate
        let result: Result<NmapRun, _> = quick_xml::de::from_str(content);
        Ok(result.is_ok())
    }
}
