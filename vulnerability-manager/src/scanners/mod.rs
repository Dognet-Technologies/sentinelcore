// src/scanners/mod.rs
// Scanner plugin system for importing vulnerability data from various security scanners

use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use uuid::Uuid;
use anyhow::Result;

pub mod qualys;
pub mod nessus;
pub mod openvas;
pub mod nexpose;
pub mod burp;
pub mod owasp_zap;
pub mod nmap;

/// Scanner plugin metadata
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScannerMetadata {
    pub name: String,
    pub display_name: String,
    pub version: String,
    pub description: String,
    pub supported_formats: Vec<String>, // e.g., ["xml", "json", "csv"]
    pub vendor: String,
}

/// Parsed vulnerability from any scanner
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ParsedVulnerability {
    // Vulnerability identification
    pub scanner_id: String,          // Scanner-specific ID (e.g., CVE, QID, plugin ID)
    pub title: String,
    pub description: String,

    // Severity
    pub severity: VulnerabilitySeverity,
    pub cvss_score: Option<f32>,
    pub cvss_vector: Option<String>,

    // Classification
    pub cve_ids: Vec<String>,
    pub cwe_ids: Vec<String>,
    pub tags: Vec<String>,

    // Affected asset
    pub host: String,
    pub port: Option<u16>,
    pub protocol: Option<String>,
    pub service: Option<String>,

    // Additional info
    pub solution: Option<String>,
    pub references: Vec<String>,
    pub first_detected: Option<chrono::DateTime<chrono::Utc>>,
    pub last_detected: Option<chrono::DateTime<chrono::Utc>>,

    // Scanner-specific raw data (for debugging/auditing)
    pub raw_data: Option<serde_json::Value>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum VulnerabilitySeverity {
    Critical,
    High,
    Medium,
    Low,
    Info,
}

/// Result of a scan import operation
#[derive(Debug, Serialize, Deserialize)]
pub struct ScanImportResult {
    pub scanner_name: String,
    pub scan_id: Option<String>,
    pub scan_date: Option<chrono::DateTime<chrono::Utc>>,
    pub total_vulnerabilities: usize,
    pub imported_count: usize,
    pub updated_count: usize,
    pub skipped_count: usize,
    pub errors: Vec<String>,
}

/// Scanner plugin trait
/// Each scanner plugin implements this trait to parse its specific format
#[async_trait]
pub trait ScannerPlugin: Send + Sync {
    /// Get scanner metadata
    fn metadata(&self) -> &ScannerMetadata;

    /// Parse scan data from raw bytes
    /// Returns a list of parsed vulnerabilities
    async fn parse(&self, data: &[u8], format: &str) -> Result<Vec<ParsedVulnerability>>;

    /// Validate that the data is in the correct format
    fn validate(&self, data: &[u8], format: &str) -> Result<bool>;

    /// Get scanner-specific configuration requirements (optional)
    fn required_config(&self) -> Vec<String> {
        vec![]
    }
}

/// Scanner registry
/// Manages all available scanner plugins
pub struct ScannerRegistry {
    scanners: HashMap<String, Box<dyn ScannerPlugin>>,
}

impl ScannerRegistry {
    pub fn new() -> Self {
        Self {
            scanners: HashMap::new(),
        }
    }

    /// Register a scanner plugin
    pub fn register(&mut self, plugin: Box<dyn ScannerPlugin>) {
        let name = plugin.metadata().name.clone();
        self.scanners.insert(name, plugin);
    }

    /// Get a scanner plugin by name
    pub fn get(&self, name: &str) -> Option<&dyn ScannerPlugin> {
        self.scanners.get(name).map(|b| b.as_ref())
    }

    /// List all available scanners
    pub fn list(&self) -> Vec<&ScannerMetadata> {
        self.scanners.values().map(|p| p.metadata()).collect()
    }

    /// Check if scanner is registered
    pub fn has_scanner(&self, name: &str) -> bool {
        self.scanners.contains_key(name)
    }
}

impl Default for ScannerRegistry {
    fn default() -> Self {
        let mut registry = Self::new();

        // Register all available scanner plugins
        registry.register(Box::new(qualys::QualysPlugin::new()));
        registry.register(Box::new(nessus::NessusPlugin::new()));
        registry.register(Box::new(openvas::OpenVASPlugin::new()));
        registry.register(Box::new(nexpose::NexposePlugin::new()));
        registry.register(Box::new(burp::BurpPlugin::new()));

        registry
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_scanner_registry() {
        let registry = ScannerRegistry::default();

        // Check that all scanners are registered
        assert!(registry.has_scanner("qualys"));
        assert!(registry.has_scanner("nessus"));
        assert!(registry.has_scanner("openvas"));
        assert!(registry.has_scanner("nexpose"));
        assert!(registry.has_scanner("burp"));

        // Check scanner count
        assert_eq!(registry.list().len(), 5);
    }
}
