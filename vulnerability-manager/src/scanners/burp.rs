// src/scanners/burp.rs
// Burp Suite scanner plugin - parses Burp Suite scan reports

use super::*;
use serde::Deserialize;

pub struct BurpPlugin {
    metadata: ScannerMetadata,
}

impl BurpPlugin {
    pub fn new() -> Self {
        Self {
            metadata: ScannerMetadata {
                name: "burp".to_string(),
                display_name: "Burp Suite / Burp Scanner".to_string(),
                version: "1.0.0".to_string(),
                description: "Imports web vulnerability scan results from Burp Suite".to_string(),
                supported_formats: vec!["xml".to_string(), "json".to_string()],
                vendor: "PortSwigger".to_string(),
            },
        }
    }
}

// Burp JSON structure (simplified)
#[derive(Debug, Deserialize)]
struct BurpReport {
    #[serde(rename = "issue")]
    issues: Vec<BurpIssue>,
}

#[derive(Debug, Deserialize)]
struct BurpIssue {
    #[serde(rename = "type")]
    issue_type: String,

    name: String,
    host: Option<BurpHost>,
    path: Option<String>,
    location: Option<String>,
    severity: String,
    confidence: String,

    #[serde(rename = "issueBackground")]
    issue_background: Option<String>,

    #[serde(rename = "remediationBackground")]
    remediation_background: Option<String>,

    references: Option<Vec<String>>,
}

#[derive(Debug, Deserialize)]
struct BurpHost {
    #[serde(rename = "#text")]
    host: String,
    ip: Option<String>,
}

#[async_trait]
impl ScannerPlugin for BurpPlugin {
    fn metadata(&self) -> &ScannerMetadata {
        &self.metadata
    }

    async fn parse(&self, data: &[u8], format: &str) -> Result<Vec<ParsedVulnerability>> {
        match format {
            "xml" => self.parse_xml(data).await,
            "json" => self.parse_json(data).await,
            _ => anyhow::bail!("Burp plugin supports XML and JSON formats"),
        }
    }

    fn validate(&self, data: &[u8], format: &str) -> Result<bool> {
        let content = std::str::from_utf8(data)?;

        match format {
            "xml" => Ok(content.contains("<issues") && content.contains("burpVersion")),
            "json" => Ok(content.contains("\"issue\"") &&
                        (content.contains("\"burp\"") || content.contains("serialNumber"))),
            _ => Ok(false),
        }
    }
}

impl BurpPlugin {
    async fn parse_xml(&self, data: &[u8]) -> Result<Vec<ParsedVulnerability>> {
        tracing::info!("Parsing Burp XML report ({} bytes)", data.len());

        // TODO: Implement Burp XML parsing
        // Burp uses <issues><issue> structure

        Ok(vec![])
    }

    async fn parse_json(&self, data: &[u8]) -> Result<Vec<ParsedVulnerability>> {
        let json_str = std::str::from_utf8(data)?;
        let report: BurpReport = serde_json::from_str(json_str)
            .map_err(|e| anyhow::anyhow!("Failed to parse Burp JSON: {}", e))?;

        let mut vulnerabilities = Vec::new();

        for issue in report.issues {
            let host = issue.host.as_ref()
                .map(|h| h.host.clone())
                .unwrap_or_else(|| "unknown".to_string());

            vulnerabilities.push(ParsedVulnerability {
                scanner_id: format!("BURP-{}", issue.issue_type),
                title: issue.name.clone(),
                description: issue.issue_background.clone().unwrap_or_default(),
                severity: Self::map_severity(&issue.severity),
                cvss_score: None,
                cvss_vector: None,
                cve_ids: vec![],
                cwe_ids: vec![],
                tags: vec!["burp".to_string(), "web".to_string(), issue.confidence],
                host,
                port: None, // Burp doesn't always specify port explicitly
                protocol: Some("http".to_string()),
                service: Some("web".to_string()),
                solution: issue.remediation_background,
                references: issue.references.unwrap_or_default(),
                first_detected: Some(chrono::Utc::now()),
                last_detected: Some(chrono::Utc::now()),
                raw_data: None,
            });
        }

        Ok(vulnerabilities)
    }

    fn map_severity(severity: &str) -> VulnerabilitySeverity {
        match severity.to_lowercase().as_str() {
            "critical" => VulnerabilitySeverity::Critical,
            "high" => VulnerabilitySeverity::High,
            "medium" => VulnerabilitySeverity::Medium,
            "low" => VulnerabilitySeverity::Low,
            _ => VulnerabilitySeverity::Info,
        }
    }
}
