// src/scanners/trivy.rs
// Aqua Security Trivy scanner plugin for importing container/image scan results

use super::{ParsedVulnerability, ScannerMetadata, ScannerPlugin, VulnerabilitySeverity};
use async_trait::async_trait;
use anyhow::{anyhow, Result};
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
struct TrivyReport {
    #[serde(rename = "SchemaVersion")]
    schema_version: i32,
    #[serde(rename = "ArtifactName")]
    artifact_name: String,
    #[serde(rename = "ArtifactType")]
    artifact_type: String,
    #[serde(rename = "Metadata")]
    metadata: Option<TrivyMetadata>,
    #[serde(rename = "Results")]
    results: Option<Vec<TrivyResult>>,
}

#[derive(Debug, Serialize, Deserialize)]
struct TrivyMetadata {
    #[serde(rename = "ScanStartedAt")]
    scan_started_at: Option<String>,
    #[serde(rename = "ScanFinishedAt")]
    scan_finished_at: Option<String>,
}

#[derive(Debug, Serialize, Deserialize)]
struct TrivyResult {
    #[serde(rename = "Type")]
    result_type: String,
    #[serde(rename = "Target")]
    target: String,
    #[serde(rename = "Vulnerabilities")]
    vulnerabilities: Option<Vec<TrivyVulnerability>>,
}

#[derive(Debug, Serialize, Deserialize)]
struct TrivyVulnerability {
    #[serde(rename = "VulnerabilityID")]
    vulnerability_id: String,
    #[serde(rename = "PkgName")]
    pkg_name: String,
    #[serde(rename = "Title")]
    title: Option<String>,
    #[serde(rename = "Description")]
    description: Option<String>,
    #[serde(rename = "Severity")]
    severity: String,
    #[serde(rename = "CVSS")]
    cvss: Option<TrivyCVSS>,
    #[serde(rename = "CweIDs")]
    cwe_ids: Option<Vec<String>>,
    #[serde(rename = "References")]
    references: Option<Vec<String>>,
    #[serde(rename = "PrimaryURL")]
    primary_url: Option<String>,
    #[serde(rename = "FixedVersion")]
    fixed_version: Option<String>,
}

#[derive(Debug, Serialize, Deserialize)]
struct TrivyCVSS {
    #[serde(rename = "ghsa")]
    ghsa: Option<TrivyCVSSScore>,
    #[serde(rename = "nvd")]
    nvd: Option<TrivyCVSSScore>,
    #[serde(rename = "redhat")]
    redhat: Option<TrivyCVSSScore>,
}

#[derive(Debug, Serialize, Deserialize)]
struct TrivyCVSSScore {
    #[serde(rename = "V3Score")]
    v3_score: Option<f32>,
    #[serde(rename = "V2Score")]
    v2_score: Option<f32>,
}

pub struct TrivyPlugin;

impl TrivyPlugin {
    pub fn new() -> Self {
        Self
    }

    fn parse_severity(&self, severity_str: &str) -> VulnerabilitySeverity {
        match severity_str.to_uppercase().as_str() {
            "CRITICAL" => VulnerabilitySeverity::Critical,
            "HIGH" => VulnerabilitySeverity::High,
            "MEDIUM" => VulnerabilitySeverity::Medium,
            "LOW" => VulnerabilitySeverity::Low,
            _ => VulnerabilitySeverity::Info,
        }
    }

    fn extract_cvss_score(&self, cvss: &Option<TrivyCVSS>) -> Option<f32> {
        if let Some(cvss_data) = cvss {
            // Prefer NVD score, fallback to GHSA
            if let Some(nvd) = &cvss_data.nvd {
                return nvd.v3_score.or(nvd.v2_score);
            }
            if let Some(ghsa) = &cvss_data.ghsa {
                return ghsa.v3_score.or(ghsa.v2_score);
            }
            if let Some(redhat) = &cvss_data.redhat {
                return redhat.v3_score.or(redhat.v2_score);
            }
        }
        None
    }
}

#[async_trait]
impl ScannerPlugin for TrivyPlugin {
    fn metadata(&self) -> &ScannerMetadata {
        &TRIVY_METADATA
    }

    async fn parse(&self, data: &[u8], format: &str) -> Result<Vec<ParsedVulnerability>> {
        match format.to_lowercase().as_str() {
            "json" => self.parse_json(data),
            _ => Err(anyhow!("Unsupported format: {}", format)),
        }
    }

    fn validate(&self, data: &[u8], format: &str) -> Result<bool> {
        match format.to_lowercase().as_str() {
            "json" => {
                // Try to parse as JSON to validate
                match serde_json::from_slice::<TrivyReport>(data) {
                    Ok(_) => Ok(true),
                    Err(_) => Ok(false),
                }
            }
            _ => Ok(false),
        }
    }
}

impl TrivyPlugin {
    fn parse_json(&self, data: &[u8]) -> Result<Vec<ParsedVulnerability>> {
        let report: TrivyReport = serde_json::from_slice(data)?;
        let mut vulnerabilities = Vec::new();

        let scan_time = report
            .metadata
            .as_ref()
            .and_then(|m| m.scan_finished_at.as_ref())
            .and_then(|s| DateTime::parse_from_rfc3339(s).ok())
            .map(|dt| dt.with_timezone(&Utc));

        if let Some(results) = report.results {
            for result in results {
                if let Some(vulns) = result.vulnerabilities {
                    for vuln in vulns {
                        let mut cve_ids = vec![];
                        let mut cwe_ids = vuln.cwe_ids.as_ref().unwrap_or(&vec![]).clone();

                        // Trivy uses VulnerabilityID for CVE
                        if vuln.vulnerability_id.starts_with("CVE-") {
                            cve_ids.push(vuln.vulnerability_id.clone());
                        }

                        let mut references = vuln.references.as_ref().unwrap_or(&vec![]).clone();
                        if let Some(url) = &vuln.primary_url {
                            if !references.contains(url) {
                                references.push(url.clone());
                            }
                        }

                        let solution = vuln.fixed_version.as_ref().map(|v| format!("Update to {}", v));

                        let parsed = ParsedVulnerability {
                            scanner_id: vuln.vulnerability_id.clone(),
                            title: vuln
                                .title
                                .as_ref()
                                .unwrap_or(&format!("{} in {}", vuln.vulnerability_id, vuln.pkg_name))
                                .clone(),
                            description: vuln.description.as_ref().unwrap_or(&String::new()).clone(),
                            severity: self.parse_severity(&vuln.severity),
                            cvss_score: self.extract_cvss_score(&vuln.cvss),
                            cvss_vector: None,
                            cve_ids,
                            cwe_ids,
                            tags: vec![result.result_type.clone(), vuln.pkg_name.clone()],
                            host: report.artifact_name.clone(),
                            port: None,
                            protocol: None,
                            service: Some(result.target.clone()),
                            solution,
                            references,
                            first_detected: scan_time,
                            last_detected: scan_time,
                            raw_data: Some(serde_json::to_value(&vuln)?),
                        };

                        vulnerabilities.push(parsed);
                    }
                }
            }
        }

        Ok(vulnerabilities)
    }
}

const TRIVY_METADATA: ScannerMetadata = ScannerMetadata {
    name: "trivy",
    display_name: "Aqua Trivy",
    version: "0.1.0",
    description: "Aqua Security Trivy - Container/image vulnerability scanner",
    supported_formats: &["json"],
    vendor: "Aqua Security",
};
