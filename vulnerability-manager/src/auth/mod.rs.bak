use argon2::{
    password_hash::{rand_core::OsRng, PasswordHash, PasswordHasher, PasswordVerifier, SaltString},
    Argon2,
};
use axum::{
    extract::State,
    http::{Request, StatusCode},
    middleware::Next,
    response::Response,
};
use chrono::{Duration, Utc};
use jsonwebtoken::{decode, encode, DecodingKey, EncodingKey, Header, Validation};
use serde::{Deserialize, Serialize};
use thiserror::Error;
use uuid::Uuid;
use std::sync::Arc;

use crate::config::AuthConfig;
use crate::models::Role;  // RIMUOVI IL DUPLICATO - usa solo questo

// Esporta i moduli pubblicamente
pub mod password_validator;
pub use password_validator::{PasswordValidator, PasswordValidationError};

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Claims {
    pub sub: String,     // Subject (user ID)
    pub role: String,    // User role
    pub exp: i64,        // Expiration time
    pub iat: i64,        // Issued at
}

#[derive(Debug, Error)]
pub enum AuthError {
    #[error("Invalid credentials")]
    InvalidCredentials,
    
    #[error("Token expired")]
    TokenExpired,
    
    #[error("Invalid token")]
    InvalidToken,
    
    #[error("Insufficient permissions")]
    InsufficientPermissions,
    
    #[error("Authentication required")]
    AuthenticationRequired,
    
    #[error("Password hashing error: {0}")]
    PasswordHashingError(String),
    
    #[error("JWT error: {0}")]
    JwtError(#[from] jsonwebtoken::errors::Error),
}

pub struct Auth {
    encoding_key: EncodingKey,
    decoding_key: DecodingKey,
    token_duration: Duration,
    password_validator: PasswordValidator,
}

impl Auth {
    pub fn new(config: &AuthConfig) -> Self {
        let secret = config.secret_key.as_bytes();
        let token_duration = Duration::hours(config.token_duration_hours as i64);
        let password_validator = PasswordValidator::new(config.password_policy.clone());
        
        Self {
            encoding_key: EncodingKey::from_secret(secret),
            decoding_key: DecodingKey::from_secret(secret),
            token_duration,
            password_validator,
        }
    }
    
    // Metodo per validare password
    pub fn validate_password(&self, password: &str) -> Result<(), PasswordValidationError> {
        self.password_validator.validate(password)
    }
    
    pub fn create_token(&self, user_id: Uuid, role: Role) -> Result<String, AuthError> {
        let now = Utc::now();
        let exp = (now + self.token_duration).timestamp();
        
        let claims = Claims {
            sub: user_id.to_string(),
            role: role.as_str().to_string(),
            exp,
            iat: now.timestamp(),
        };
        
        encode(&Header::default(), &claims, &self.encoding_key)
            .map_err(AuthError::JwtError)
    }
    
    pub fn verify_token(&self, token: &str) -> Result<Claims, AuthError> {
        let mut validation = Validation::default();
        validation.validate_exp = true;
        
        let token_data = decode::<Claims>(
            token,
            &self.decoding_key,
            &validation,
        )
        .map_err(|e| match e.kind() {
            jsonwebtoken::errors::ErrorKind::ExpiredSignature => AuthError::TokenExpired,
            _ => AuthError::InvalidToken,
        })?;
        
        Ok(token_data.claims)
    }
    
    // Nota: hash_password Ã¨ ora un metodo di istanza, non statico
    pub fn hash_password(&self, password: &str) -> Result<String, AuthError> {
        // Prima validiamo la password
        self.validate_password(password)
            .map_err(|e| AuthError::PasswordHashingError(e.to_string()))?;
            
        let salt = SaltString::generate(&mut OsRng);
        let argon2 = Argon2::default();
        
        argon2
            .hash_password(password.as_bytes(), &salt)
            .map(|hash| hash.to_string())
            .map_err(|e| AuthError::PasswordHashingError(e.to_string()))
    }
    
    pub fn verify_password(&self, password: &str, hash: &str) -> Result<bool, AuthError> {
        let parsed_hash = PasswordHash::new(hash)
            .map_err(|e| AuthError::PasswordHashingError(e.to_string()))?;
        
        Ok(Argon2::default()
            .verify_password(password.as_bytes(), &parsed_hash)
            .is_ok())
    }
}

// Middleware per richiedere autenticazione
pub async fn require_auth<B>(
    State(auth): State<Arc<Auth>>,
    mut req: Request<B>,
    next: Next<B>,
) -> Result<Response, StatusCode> {
    let auth_header = req
        .headers()
        .get("Authorization")
        .and_then(|header| header.to_str().ok())
        .and_then(|header| {
            if header.starts_with("Bearer ") {
                Some(header[7..].to_string())
            } else {
                None
            }
        });
    
    let auth_header = auth_header.ok_or(StatusCode::UNAUTHORIZED)?;
    
    let claims = auth
        .verify_token(&auth_header)
        .map_err(|e| match e {
            AuthError::TokenExpired => StatusCode::UNAUTHORIZED,
            _ => StatusCode::UNAUTHORIZED,
        })?;
    
    req.extensions_mut().insert(claims);
    
    Ok(next.run(req).await)
}

// Middleware per richiedere ruolo admin
pub async fn require_admin<B>(
    req: Request<B>,
    next: Next<B>,
) -> Result<Response, StatusCode> {
    let claims = req
        .extensions()
        .get::<Claims>()
        .ok_or(StatusCode::UNAUTHORIZED)?;
    
    if claims.role != Role::Admin.as_str() {
        return Err(StatusCode::FORBIDDEN);
    }
    
    Ok(next.run(req).await)
}