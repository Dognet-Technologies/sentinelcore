// src/auth/mod.rs
// FIXED: Convertito middleware da Extension a State per Axum 0.6

use argon2::{
    password_hash::{rand_core::OsRng, PasswordHash, PasswordHasher, PasswordVerifier, SaltString},
    Argon2,
};
use axum::{
    extract::State, // FIXED: State invece di Extension
    http::{Request, StatusCode},
    middleware::Next,
    response::Response,
};
use chrono::{Duration, Utc};
use jsonwebtoken::{decode, encode, DecodingKey, EncodingKey, Header, Validation};
use serde::{Deserialize, Serialize};
use thiserror::Error;
use uuid::Uuid;

use crate::config::AuthConfig;
use crate::models::user::Role;
use crate::AppState; // FIXED: Import AppState from lib.rs

// Export password validator
pub mod password_validator;
pub use password_validator::{PasswordValidator, PasswordValidationError};

// ADDED: Claims extractor
pub mod claims_extractor;

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Claims {
    pub sub: String,         // Subject (user ID)
    pub role: String,        // User role
    pub exp: i64,            // Expiration time
    pub iat: i64,            // Issued at
    pub jti: Option<String>, // JWT ID for session tracking
}

#[derive(Debug, Error)]
pub enum AuthError {
    #[error("Invalid credentials")]
    InvalidCredentials,
    
    #[error("Token expired")]
    TokenExpired,
    
    #[error("Invalid token")]
    InvalidToken,
    
    #[error("Insufficient permissions")]
    InsufficientPermissions,
    
    #[error("Authentication required")]
    AuthenticationRequired,
    
    #[error("Password hashing error: {0}")]
    PasswordHashingError(String),
    
    #[error("Password validation error: {0}")]
    PasswordValidationError(#[from] PasswordValidationError),
    
    #[error("JWT error: {0}")]
    JwtError(#[from] jsonwebtoken::errors::Error),
}

pub struct Auth {
    encoding_key: EncodingKey,
    decoding_key: DecodingKey,
    token_duration: Duration,
    password_validator: PasswordValidator,
}

impl Auth {
    pub fn new(config: &AuthConfig) -> Self {
        let secret = config.secret_key.as_bytes();
        let token_duration = Duration::hours(config.token_duration_hours as i64);
        let password_validator = PasswordValidator::new(config.password_policy.clone());
        
        Self {
            encoding_key: EncodingKey::from_secret(secret),
            decoding_key: DecodingKey::from_secret(secret),
            token_duration,
            password_validator,
        }
    }
    
    pub fn validate_password(&self, password: &str) -> Result<(), PasswordValidationError> {
        self.password_validator.validate(password)
    }
    
    pub fn create_token(&self, user_id: Uuid, role: Role) -> Result<String, AuthError> {
        self.create_token_with_session(user_id, role, None)
    }
    
    pub fn create_token_with_session(
        &self, 
        user_id: Uuid, 
        role: Role,
        session_id: Option<String>
    ) -> Result<String, AuthError> {
        let now = Utc::now();
        let exp = (now + self.token_duration).timestamp();
        
        let claims = Claims {
            sub: user_id.to_string(),
            role: role.as_str().to_string(),
            exp,
            iat: now.timestamp(),
            jti: session_id,
        };
        
        encode(&Header::default(), &claims, &self.encoding_key)
            .map_err(AuthError::JwtError)
    }
    
    pub fn verify_token(&self, token: &str) -> Result<Claims, AuthError> {
        let mut validation = Validation::default();
        validation.validate_exp = true;
        
        let token_data = decode::<Claims>(
            token,
            &self.decoding_key,
            &validation,
        )
        .map_err(|e| match e.kind() {
            jsonwebtoken::errors::ErrorKind::ExpiredSignature => AuthError::TokenExpired,
            _ => AuthError::InvalidToken,
        })?;
        
        Ok(token_data.claims)
    }
    
    pub fn hash_password(&self, password: &str) -> Result<String, AuthError> {
        // First validate the password
        self.validate_password(password)?;
            
        let salt = SaltString::generate(&mut OsRng);
        let argon2 = Argon2::default();
        
        argon2
            .hash_password(password.as_bytes(), &salt)
            .map(|hash| hash.to_string())
            .map_err(|e| AuthError::PasswordHashingError(e.to_string()))
    }
    
    pub fn verify_password(&self, password: &str, hash: &str) -> Result<bool, AuthError> {
        let parsed_hash = PasswordHash::new(hash)
            .map_err(|e| AuthError::PasswordHashingError(e.to_string()))?;
        
        Ok(Argon2::default()
            .verify_password(password.as_bytes(), &parsed_hash)
            .is_ok())
    }
}

// FIXED: Middleware convertito a State per Axum 0.6
pub async fn require_auth<B>(
    State(app_state): State<AppState>, // FIXED: State invece di Extension
    mut req: Request<B>,
    next: Next<B>,
) -> Result<Response, StatusCode> {
    let auth_header = req
        .headers()
        .get("Authorization")
        .and_then(|header| header.to_str().ok())
        .and_then(|header| {
            if header.starts_with("Bearer ") {
                Some(header[7..].to_string())
            } else {
                None
            }
        });
    
    let auth_header = auth_header.ok_or(StatusCode::UNAUTHORIZED)?;
    
    let claims = app_state.auth
        .verify_token(&auth_header)
        .map_err(|e| match e {
            AuthError::TokenExpired => StatusCode::UNAUTHORIZED,
            _ => StatusCode::UNAUTHORIZED,
        })?;
    
    req.extensions_mut().insert(claims);
    
    Ok(next.run(req).await)
}

// FIXED: Middleware per ruolo admin - convertito a State
pub async fn require_admin<B>(
    req: Request<B>,
    next: Next<B>,
) -> Result<Response, StatusCode> {
    let claims = req
        .extensions()
        .get::<Claims>()
        .ok_or(StatusCode::UNAUTHORIZED)?;
    
    if claims.role != Role::Admin.as_str() {
        return Err(StatusCode::FORBIDDEN);
    }
    
    Ok(next.run(req).await)
}

// FIXED: Middleware per team leader o admin - convertito a State
pub async fn require_team_leader<B>(
    req: Request<B>,
    next: Next<B>,
) -> Result<Response, StatusCode> {
    let claims = req
        .extensions()
        .get::<Claims>()
        .ok_or(StatusCode::UNAUTHORIZED)?;
    
    if claims.role != Role::Admin.as_str() && claims.role != Role::TeamLeader.as_str() {
        return Err(StatusCode::FORBIDDEN);
    }
    
    Ok(next.run(req).await)
}