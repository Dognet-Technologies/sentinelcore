// src/auth/password_validator.rs
// Password validation according to OWASP guidelines

use thiserror::Error;
use crate::config::PasswordPolicyConfig;

#[derive(Debug, Error)]
pub enum PasswordValidationError {
    #[error("Password is too short (minimum {min} characters)")]
    TooShort { min: u8 },
    
    #[error("Password is too long (maximum {max} characters)")]
    TooLong { max: u8 },
    
    #[error("Password must contain at least one uppercase letter")]
    NoUppercase,
    
    #[error("Password must contain at least one lowercase letter")]
    NoLowercase,
    
    #[error("Password must contain at least one number")]
    NoNumbers,
    
    #[error("Password must contain at least one special character ({chars})")]
    NoSpecialChars { chars: String },
    
    #[error("Password is too common and easily guessable")]
    CommonPassword,
}

pub struct PasswordValidator {
    config: PasswordPolicyConfig,
    common_passwords: Vec<&'static str>,
}

impl PasswordValidator {
    pub fn new(config: PasswordPolicyConfig) -> Self {
        // Common passwords list (simplified - in production use a comprehensive list)
        let common_passwords = vec![
            "password", "123456", "password123", "admin", "qwerty",
            "letmein", "welcome", "monkey", "dragon", "12345678",
            "abc123", "mustang", "michael", "shadow", "master",
            "jennifer", "111111", "jordan", "superman", "harley",
        ];
        
        Self {
            config,
            common_passwords,
        }
    }
    
    pub fn validate(&self, password: &str) -> Result<(), PasswordValidationError> {
        let len = password.len() as u8;
        
        // Check length
        if len < self.config.min_length {
            return Err(PasswordValidationError::TooShort { 
                min: self.config.min_length 
            });
        }
        
        if len > self.config.max_length {
            return Err(PasswordValidationError::TooLong { 
                max: self.config.max_length 
            });
        }
        
        // Check uppercase requirement
        if self.config.require_uppercase && !password.chars().any(|c| c.is_uppercase()) {
            return Err(PasswordValidationError::NoUppercase);
        }
        
        // Check lowercase requirement
        if self.config.require_lowercase && !password.chars().any(|c| c.is_lowercase()) {
            return Err(PasswordValidationError::NoLowercase);
        }
        
        // Check numbers requirement
        if self.config.require_numbers && !password.chars().any(|c| c.is_numeric()) {
            return Err(PasswordValidationError::NoNumbers);
        }
        
        // Check special characters requirement
        if self.config.require_special_chars {
            if !password.chars().any(|c| self.config.special_chars.contains(c)) {
                return Err(PasswordValidationError::NoSpecialChars { 
                    chars: self.config.special_chars.clone() 
                });
            }
        }
        
        // Check against common passwords
        if self.config.prevent_common_passwords {
            let password_lower = password.to_lowercase();
            if self.common_passwords.iter().any(|&common| password_lower == common) {
                return Err(PasswordValidationError::CommonPassword);
            }
        }
        
        Ok(())
    }
    
    pub fn strength_score(&self, password: &str) -> u8 {
        let mut score = 0u8;
        
        // Base score for length
        if password.len() >= self.config.min_length as usize {
            score += 25;
        }
        
        // Bonus for character variety
        if password.chars().any(|c| c.is_uppercase()) { score += 15; }
        if password.chars().any(|c| c.is_lowercase()) { score += 15; }
        if password.chars().any(|c| c.is_numeric()) { score += 15; }
        if password.chars().any(|c| self.config.special_chars.contains(c)) { score += 15; }
        
        // Bonus for length beyond minimum
        let extra_length = password.len().saturating_sub(self.config.min_length as usize);
        score += std::cmp::min(extra_length as u8 * 2, 15);
        
        // Penalty for common passwords
        if self.common_passwords.iter().any(|&common| password.to_lowercase() == common) {
            score = score.saturating_sub(50);
        }
        
        std::cmp::min(score, 100)
    }
}