// src/api/remediation_api.rs
// API endpoints for Risk-Based Remediation Engine

use axum::{
    extract::{Path, State},
    http::StatusCode,
    response::IntoResponse,
    Json,
};
use serde::{Deserialize, Serialize};
use sqlx::FromRow;
use uuid::Uuid;

use crate::state::AppState;
use crate::remediation::{
    RBRECalculator, RBREFactors, RemediationPriorityScore, AssetCriticality, ExposureLevel, ThreatContext,
};

#[derive(Debug, Serialize, Deserialize)]
pub struct CalculateRPSRequest {
    pub device_id: Uuid,
    pub vulnerability_id: Uuid,
    pub cvss_score: f64,
    pub epss_score: f64,
    pub business_criticality: String,
    pub exposure_level: String,
    pub threat_context: String,
    pub days_open: u32,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct CalculateRPSResponse {
    pub rps: f64,
    pub priority_tier: String,
    pub explanation: String,
    pub sla_days: u16,
    pub factors: RBREFactors,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct GenerateRemediationPlanRequest {
    pub device_ids: Vec<Uuid>,
    pub name: String,
    pub description: Option<String>,
}

#[derive(Debug, Serialize, Deserialize, FromRow)]
pub struct RemediationPlan {
    pub id: Uuid,
    pub name: String,
    pub description: Option<String>,
    pub status: String,
    pub total_devices: i32,
    pub critical_count: i32,
    pub high_count: i32,
    pub medium_count: i32,
    pub low_count: i32,
    pub estimated_hours_total: f64,
    pub estimated_start_date: Option<chrono::NaiveDate>,
    pub estimated_completion_date: Option<chrono::NaiveDate>,
}

/// Calculate RPS for a specific vulnerability on a device
pub async fn calculate_rps(
    State(_): State<AppState>,
    Json(req): Json<CalculateRPSRequest>,
) -> Result<Json<CalculateRPSResponse>, (StatusCode, String)> {
    // Parse categorical fields
    let business_criticality = match req.business_criticality.as_str() {
        "mission_critical" => AssetCriticality::MissionCritical,
        "core_business" => AssetCriticality::CoreBusiness,
        "supporto" => AssetCriticality::Supporto,
        "lab_test" => AssetCriticality::LabTest,
        _ => AssetCriticality::Supporto,
    };

    let exposure_level = match req.exposure_level.as_str() {
        "internet_facing" => ExposureLevel::InternetFacing,
        "dmz" => ExposureLevel::DMZ,
        "internal" => ExposureLevel::Internal,
        "segmented" => ExposureLevel::Segmented,
        _ => ExposureLevel::Internal,
    };

    let threat_context = match req.threat_context.as_str() {
        "in_the_wild" => ThreatContext::InTheWild,
        "public_exploit" => ThreatContext::PublicExploit,
        "poc" => ThreatContext::PoC,
        "no_exploit" => ThreatContext::NoExploit,
        _ => ThreatContext::NoExploit,
    };

    // Calculate factors (normalized)
    let factors = RBREFactors {
        technical_severity: RBRECalculator::normalize_cvss(req.cvss_score),
        exploit_probability: req.epss_score.min(1.0).max(0.0),
        asset_criticality: business_criticality.score(),
        exposure_factor: exposure_level.score(),
        threat_context: threat_context.score(),
        time_factor: RBRECalculator::calculate_time_factor(req.days_open),
    };

    // Calculate RPS
    let rps_result = RBRECalculator::calculate_rps(&factors);

    Ok(Json(CalculateRPSResponse {
        rps: rps_result.rps,
        priority_tier: rps_result.priority_tier.label().to_string(),
        explanation: rps_result.explanation,
        sla_days: rps_result.priority_tier.sla_days(),
        factors,
    }))
}

/// Generate a remediation plan for selected devices
pub async fn generate_remediation_plan(
    State(state): State<AppState>,
    Json(req): Json<GenerateRemediationPlanRequest>,
) -> Result<Json<RemediationPlan>, (StatusCode, String)> {
    // Placeholder implementation
    // In a real scenario, this would:
    // 1. Load all vulnerabilities for the selected devices
    // 2. Calculate RPS for each vulnerability
    // 3. Group by priority and create phases
    // 4. Assign to teams based on capacity
    // 5. Generate detailed remediation tasks
    // 6. Store in remediation_plans and remediation_plan_items tables

    let plan = RemediationPlan {
        id: Uuid::new_v4(),
        name: req.name,
        description: req.description,
        status: "draft".to_string(),
        total_devices: req.device_ids.len() as i32,
        critical_count: 0,
        high_count: 0,
        medium_count: 0,
        low_count: 0,
        estimated_hours_total: 0.0,
        estimated_start_date: None,
        estimated_completion_date: None,
    };

    Ok(Json(plan))
}

/// Validate if device has required fields for RBRE calculation
#[derive(Debug, Serialize, Deserialize)]
pub struct ValidationResult {
    pub is_valid: bool,
    pub missing_fields: Vec<String>,
    pub warnings: Vec<String>,
}

pub async fn validate_device_for_rbre(
    State(state): State<AppState>,
    Path(device_id): Path<Uuid>,
) -> Result<Json<ValidationResult>, (StatusCode, String)> {
    let mut missing_fields = Vec::new();
    let mut warnings = Vec::new();

    // Query the device from database - check if device exists
    let device_exists = sqlx::query_scalar::<_, bool>("SELECT EXISTS(SELECT 1 FROM network_devices WHERE id = $1)")
        .bind(device_id)
        .fetch_one(state.pool.as_ref())
        .await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

    if !device_exists {
        return Err((StatusCode::NOT_FOUND, "Device not found".to_string()));
    }

    // Required fields for RBRE calculation
    missing_fields.push("business_criticality".to_string());
    missing_fields.push("exposure_level".to_string());
    missing_fields.push("device_use_case".to_string());
    missing_fields.push("patch_availability".to_string());
    missing_fields.push("remediation_difficulty".to_string());

    // Optional but recommended
    warnings.push("compensating_controls not documented".to_string());
    warnings.push("deployment_impact not documented".to_string());

    // Note: Once database schema is updated with RBRE fields, these validations
    // will be replaced with actual column checks

    Ok(Json(ValidationResult {
        is_valid: missing_fields.is_empty(),
        missing_fields,
        warnings,
    }))
}
