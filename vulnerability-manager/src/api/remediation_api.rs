// src/api/remediation_api.rs
// API endpoints for Risk-Based Remediation Engine

use axum::{
    extract::{Path, State},
    http::StatusCode,
    response::IntoResponse,
    Json,
};
use serde::{Deserialize, Serialize};
use sqlx::FromRow;
use uuid::Uuid;
use chrono;

use crate::state::AppState;
use crate::remediation::{
    RBRECalculator, RBREFactors, RemediationPriorityScore, AssetCriticality, ExposureLevel, ThreatContext,
};

#[derive(Debug, Serialize, Deserialize)]
pub struct CalculateRPSRequest {
    pub device_id: Uuid,
    pub vulnerability_id: Uuid,
    pub cvss_score: f64,
    pub epss_score: f64,
    pub business_criticality: String,
    pub exposure_level: String,
    pub threat_context: String,
    pub days_open: u32,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct CalculateRPSResponse {
    pub rps: f64,
    pub priority_tier: String,
    pub explanation: String,
    pub sla_days: u16,
    pub factors: RBREFactors,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct GenerateRemediationPlanRequest {
    pub device_ids: Vec<Uuid>,
    pub name: String,
    pub description: Option<String>,
}

#[derive(Debug, Serialize, Deserialize, FromRow)]
pub struct RemediationPlan {
    pub id: Uuid,
    pub name: String,
    pub description: Option<String>,
    pub status: String,
    pub total_devices: i32,
    pub critical_count: i32,
    pub high_count: i32,
    pub medium_count: i32,
    pub low_count: i32,
    pub estimated_hours_total: f64,
    pub estimated_start_date: Option<chrono::NaiveDate>,
    pub estimated_completion_date: Option<chrono::NaiveDate>,
}

/// Calculate RPS for a specific vulnerability on a device
pub async fn calculate_rps(
    State(_): State<AppState>,
    Json(req): Json<CalculateRPSRequest>,
) -> Result<Json<CalculateRPSResponse>, (StatusCode, String)> {
    // Parse categorical fields
    let business_criticality = match req.business_criticality.as_str() {
        "mission_critical" => AssetCriticality::MissionCritical,
        "core_business" => AssetCriticality::CoreBusiness,
        "supporto" => AssetCriticality::Supporto,
        "lab_test" => AssetCriticality::LabTest,
        _ => AssetCriticality::Supporto,
    };

    let exposure_level = match req.exposure_level.as_str() {
        "internet_facing" => ExposureLevel::InternetFacing,
        "dmz" => ExposureLevel::DMZ,
        "internal" => ExposureLevel::Internal,
        "segmented" => ExposureLevel::Segmented,
        _ => ExposureLevel::Internal,
    };

    let threat_context = match req.threat_context.as_str() {
        "in_the_wild" => ThreatContext::InTheWild,
        "public_exploit" => ThreatContext::PublicExploit,
        "poc" => ThreatContext::PoC,
        "no_exploit" => ThreatContext::NoExploit,
        _ => ThreatContext::NoExploit,
    };

    // Calculate factors (normalized)
    let factors = RBREFactors {
        technical_severity: RBRECalculator::normalize_cvss(req.cvss_score),
        exploit_probability: req.epss_score.min(1.0).max(0.0),
        asset_criticality: business_criticality.score(),
        exposure_factor: exposure_level.score(),
        threat_context: threat_context.score(),
        time_factor: RBRECalculator::calculate_time_factor(req.days_open),
    };

    // Calculate RPS
    let rps_result = RBRECalculator::calculate_rps(&factors);

    Ok(Json(CalculateRPSResponse {
        rps: rps_result.rps,
        priority_tier: rps_result.priority_tier.label().to_string(),
        explanation: rps_result.explanation,
        sla_days: rps_result.priority_tier.sla_days(),
        factors,
    }))
}

/// Generate a remediation plan for selected devices
pub async fn generate_remediation_plan(
    State(state): State<AppState>,
    claims: crate::auth::Claims,
    Json(req): Json<GenerateRemediationPlanRequest>,
) -> Result<Json<RemediationPlan>, (StatusCode, String)> {
    let user_id = Uuid::parse_str(&claims.sub)
        .map_err(|_| (StatusCode::BAD_REQUEST, "Invalid user ID".to_string()))?;

    let mut tx = state.pool.begin().await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

    let plan_id = Uuid::new_v4();

    sqlx::query(
        r#"
        INSERT INTO remediation_plans (id, name, description, created_by, status, device_ids)
        VALUES ($1, $2, $3, $4, 'draft', $5)
        "#,
    )
    .bind(plan_id)
    .bind(&req.name)
    .bind(&req.description)
    .bind(user_id)
    .bind(&req.device_ids)
    .execute(&mut *tx)
    .await
    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, format!("Failed to create plan: {}", e)))?;

    let mut critical_count = 0;
    let mut high_count = 0;
    let mut medium_count = 0;
    let mut low_count = 0;
    let mut total_estimated_hours = 0.0;

    let severity_priority = vec![
        ("critical", 1),
        ("high", 2),
        ("medium", 3),
        ("low", 4),
    ];

    for (severity, phase_number) in severity_priority {
        let phase_id = Uuid::new_v4();

        let vuln_count: i32 = sqlx::query_scalar(
            r#"
            SELECT COUNT(DISTINCT v.id)::int
            FROM vulnerabilities v
            JOIN device_vulnerabilities dv ON v.id = dv.vulnerability_id
            WHERE dv.device_id = ANY($1)
            AND v.severity = $2::vulnerability_severity
            AND v.status != 'resolved'
            "#,
        )
        .bind(&req.device_ids)
        .bind(severity)
        .fetch_one(&mut *tx)
        .await
        .unwrap_or(0);

        if vuln_count > 0 {
            sqlx::query(
                r#"
                INSERT INTO remediation_plan_phases 
                (id, plan_id, phase_number, phase_name, target_severity, status, device_count, vulnerability_count)
                VALUES ($1, $2, $3, $4, $5, 'pending', $6, $7)
                "#,
            )
            .bind(phase_id)
            .bind(plan_id)
            .bind(phase_number)
            .bind(format!("{} Priority", severity.to_uppercase()))
            .bind(severity)
            .bind(req.device_ids.len() as i32)
            .bind(vuln_count)
            .execute(&mut *tx)
            .await
            .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, format!("Failed to create phase: {}", e)))?;

            let vulns: Vec<(Uuid, Uuid)> = sqlx::query_as(
                r#"
                SELECT DISTINCT v.id, dv.device_id
                FROM vulnerabilities v
                JOIN device_vulnerabilities dv ON v.id = dv.vulnerability_id
                WHERE dv.device_id = ANY($1)
                AND v.severity = $2::vulnerability_severity
                AND v.status != 'resolved'
                ORDER BY v.cvss_score DESC, v.epss_score DESC
                "#,
            )
            .bind(&req.device_ids)
            .bind(severity)
            .fetch_all(&mut *tx)
            .await
            .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, format!("Failed to fetch vulnerabilities: {}", e)))?;

            for (vuln_id, device_id) in vulns {
                let item_id = Uuid::new_v4();
                let estimated_hours: i16 = match severity {
                    "critical" => 4,
                    "high" => 2,
                    "medium" => 1,
                    "low" => 1,
                    _ => 1,
                };

                total_estimated_hours += estimated_hours as f64;

                sqlx::query(
                    r#"
                    INSERT INTO remediation_plan_items 
                    (id, plan_id, phase_id, device_id, vulnerability_id, rps_score, status, estimated_hours)
                    VALUES ($1, $2, $3, $4, $5, $6, 'pending', $7)
                    "#,
                )
                .bind(item_id)
                .bind(plan_id)
                .bind(phase_id)
                .bind(device_id)
                .bind(vuln_id)
                .bind((101 - (phase_number * 20)) as f64)
                .bind(estimated_hours)
                .execute(&mut *tx)
                .await
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, format!("Failed to create plan item: {}", e)))?;
            }

            match severity {
                "critical" => critical_count = vuln_count,
                "high" => high_count = vuln_count,
                "medium" => medium_count = vuln_count,
                "low" => low_count = vuln_count,
                _ => {}
            }
        }
    }

    let estimated_start_date = chrono::Local::now().date_naive();
    let estimated_completion_date = estimated_start_date + chrono::Duration::days((total_estimated_hours / 8.0).ceil() as i64);

    sqlx::query(
        r#"
        UPDATE remediation_plans
        SET total_devices = $2,
            critical_count = $3,
            high_count = $4,
            medium_count = $5,
            low_count = $6,
            estimated_hours_total = $7,
            estimated_start_date = $8,
            estimated_completion_date = $9
        WHERE id = $1
        "#,
    )
    .bind(plan_id)
    .bind(req.device_ids.len() as i32)
    .bind(critical_count)
    .bind(high_count)
    .bind(medium_count)
    .bind(low_count)
    .bind(total_estimated_hours)
    .bind(estimated_start_date)
    .bind(estimated_completion_date)
    .execute(&mut *tx)
    .await
    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

    tx.commit().await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

    let plan = RemediationPlan {
        id: plan_id,
        name: req.name,
        description: req.description,
        status: "draft".to_string(),
        total_devices: req.device_ids.len() as i32,
        critical_count,
        high_count,
        medium_count,
        low_count,
        estimated_hours_total: total_estimated_hours,
        estimated_start_date: Some(estimated_start_date),
        estimated_completion_date: Some(estimated_completion_date),
    };

    Ok(Json(plan))
}

/// Validate if device has required fields for RBRE calculation
#[derive(Debug, Serialize, Deserialize)]
pub struct ValidationResult {
    pub is_valid: bool,
    pub missing_fields: Vec<String>,
    pub warnings: Vec<String>,
}

pub async fn validate_device_for_rbre(
    State(state): State<AppState>,
    Path(device_id): Path<Uuid>,
) -> Result<Json<ValidationResult>, (StatusCode, String)> {
    let mut missing_fields = Vec::new();
    let mut warnings = Vec::new();

    // Query the device from database - check if device exists
    let device_exists = sqlx::query_scalar::<_, bool>("SELECT EXISTS(SELECT 1 FROM network_devices WHERE id = $1)")
        .bind(device_id)
        .fetch_one(state.pool.as_ref())
        .await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

    if !device_exists {
        return Err((StatusCode::NOT_FOUND, "Device not found".to_string()));
    }

    // Required fields for RBRE calculation
    missing_fields.push("business_criticality".to_string());
    missing_fields.push("exposure_level".to_string());
    missing_fields.push("device_use_case".to_string());
    missing_fields.push("patch_availability".to_string());
    missing_fields.push("remediation_difficulty".to_string());

    // Optional but recommended
    warnings.push("compensating_controls not documented".to_string());
    warnings.push("deployment_impact not documented".to_string());

    // Note: Once database schema is updated with RBRE fields, these validations
    // will be replaced with actual column checks

    Ok(Json(ValidationResult {
        is_valid: missing_fields.is_empty(),
        missing_fields,
        warnings,
    }))
}
