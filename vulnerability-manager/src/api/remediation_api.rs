// src/api/remediation_api.rs
// API endpoints for Risk-Based Remediation Engine

use axum::{
    extract::{Path, State},
    http::StatusCode,
    Json,
};
use serde::{Deserialize, Serialize};
use uuid::Uuid;
use chrono;

use crate::state::AppState;
use crate::remediation::{
    RBRECalculator, RBREFactors, AssetCriticality, ExposureLevel, ThreatContext,
};

#[derive(Debug, Serialize, Deserialize)]
pub struct CalculateRPSRequest {
    pub device_id: Uuid,
    pub vulnerability_id: Uuid,
    pub cvss_score: f64,
    pub epss_score: f64,
    pub business_criticality: String,
    pub exposure_level: String,
    pub threat_context: String,
    pub days_open: u32,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct CalculateRPSResponse {
    pub rps: f64,
    pub priority_tier: String,
    pub explanation: String,
    pub sla_days: u16,
    pub factors: RBREFactors,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct GenerateRemediationPlanRequest {
    pub device_ids: Vec<Uuid>,
    pub name: String,
    pub description: Option<String>,
    pub severity_filter: Option<Vec<String>>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct RemediationPlan {
    pub id: Uuid,
    pub name: String,
    pub description: Option<String>,
    pub status: String,
    pub total_devices: i32,
    pub critical_count: i32,
    pub high_count: i32,
    pub medium_count: i32,
    pub low_count: i32,
    pub estimated_hours_total: f64,
    pub estimated_start_date: Option<chrono::NaiveDate>,
    pub estimated_completion_date: Option<chrono::NaiveDate>,
}

/// Calculate RPS for a specific vulnerability on a device
pub async fn calculate_rps(
    State(_): State<AppState>,
    Json(req): Json<CalculateRPSRequest>,
) -> Result<Json<CalculateRPSResponse>, (StatusCode, String)> {
    // Parse categorical fields
    let business_criticality = match req.business_criticality.as_str() {
        "mission_critical" => AssetCriticality::MissionCritical,
        "core_business" => AssetCriticality::CoreBusiness,
        "supporto" => AssetCriticality::Supporto,
        "lab_test" => AssetCriticality::LabTest,
        _ => AssetCriticality::Supporto,
    };

    let exposure_level = match req.exposure_level.as_str() {
        "internet_facing" => ExposureLevel::InternetFacing,
        "dmz" => ExposureLevel::DMZ,
        "internal" => ExposureLevel::Internal,
        "segmented" => ExposureLevel::Segmented,
        _ => ExposureLevel::Internal,
    };

    let threat_context = match req.threat_context.as_str() {
        "in_the_wild" => ThreatContext::InTheWild,
        "public_exploit" => ThreatContext::PublicExploit,
        "poc" => ThreatContext::PoC,
        "no_exploit" => ThreatContext::NoExploit,
        _ => ThreatContext::NoExploit,
    };

    // Calculate factors (normalized)
    let factors = RBREFactors {
        technical_severity: RBRECalculator::normalize_cvss(req.cvss_score),
        exploit_probability: req.epss_score.min(1.0).max(0.0),
        asset_criticality: business_criticality.score(),
        exposure_factor: exposure_level.score(),
        threat_context: threat_context.score(),
        time_factor: RBRECalculator::calculate_time_factor(req.days_open),
    };

    // Calculate RPS
    let rps_result = RBRECalculator::calculate_rps(&factors);

    Ok(Json(CalculateRPSResponse {
        rps: rps_result.rps,
        priority_tier: rps_result.priority_tier.label().to_string(),
        explanation: rps_result.explanation,
        sla_days: rps_result.priority_tier.sla_days(),
        factors,
    }))
}

/// Generate a remediation plan for selected devices using RBRE
pub async fn generate_remediation_plan(
    State(state): State<AppState>,
    claims: crate::auth::Claims,
    Json(req): Json<GenerateRemediationPlanRequest>,
) -> Result<Json<RemediationPlan>, (StatusCode, String)> {
    let user_id = Uuid::parse_str(&claims.sub)
        .map_err(|_| (StatusCode::BAD_REQUEST, "Invalid user ID".to_string()))?;

    let mut tx = state.pool.begin().await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

    let plan_id = Uuid::new_v4();

    sqlx::query(
        r#"
        INSERT INTO remediation_plans (id, name, description, created_by, status, device_ids)
        VALUES ($1, $2, $3, $4, 'draft', $5)
        "#,
    )
    .bind(plan_id)
    .bind(&req.name)
    .bind(&req.description)
    .bind(user_id)
    .bind(&req.device_ids)
    .execute(&mut *tx)
    .await
    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, format!("Failed to create plan: {}", e)))?;

    // Fetch all vulnerabilities for selected devices with device context
    // Build WHERE clause based on severity filter
    let severity_condition = if let Some(ref severities) = req.severity_filter {
        if !severities.is_empty() {
            let severity_list: Vec<String> = severities.iter()
                .map(|s| format!("'{}'", s.to_lowercase()))
                .collect();
            format!("AND LOWER(v.severity::TEXT) IN ({})", severity_list.join(","))
        } else {
            String::new()
        }
    } else {
        String::new()
    };

    let query_str = format!(
        r#"
        SELECT
            v.id as vulnerability_id,
            dv.device_id,
            v.cve_id,
            v.title,
            v.cvss_score,
            v.epss_score,
            v.severity::TEXT as severity,
            dv.discovered_at,
            nd.business_criticality::TEXT as business_criticality,
            nd.exposure_level::TEXT as exposure_level,
            nd.remediation_difficulty::TEXT as remediation_difficulty
        FROM vulnerabilities v
        JOIN device_vulnerabilities dv ON v.id = dv.vulnerability_id
        JOIN network_devices nd ON dv.device_id = nd.id
        WHERE dv.device_id = ANY($1)
        AND v.status != 'resolved'
        {}
        ORDER BY v.cvss_score DESC, v.epss_score DESC
        "#,
        severity_condition
    );

    #[derive(sqlx::FromRow)]
    struct VulnData {
        vulnerability_id: Uuid,
        device_id: Uuid,
        cve_id: Option<String>,
        title: String,
        cvss_score: f32,
        epss_score: Option<f32>,
        severity: String,
        discovered_at: chrono::DateTime<chrono::Utc>,
        business_criticality: Option<String>,
        exposure_level: Option<String>,
        remediation_difficulty: Option<String>,
    }

    let vulns_data = sqlx::query_as::<_, VulnData>(&query_str)
        .bind(&req.device_ids)
        .fetch_all(&mut *tx)
        .await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, format!("Failed to fetch vulnerabilities: {}", e)))?;

    let mut critical_count = 0;
    let mut high_count = 0;
    let mut medium_count = 0;
    let mut low_count = 0;
    let mut total_estimated_hours = 0.0;

    // Group vulnerabilities by RPS tier (Critical, High, Medium, Low)
    let mut tier_phases: Vec<(String, i32, Vec<_>)> = vec![
        ("Critical Priority".to_string(), 1, Vec::new()),
        ("High Priority".to_string(), 2, Vec::new()),
        ("Medium Priority".to_string(), 3, Vec::new()),
        ("Low Priority".to_string(), 4, Vec::new()),
    ];

    // Calculate RPS for each vulnerability
    for vuln in vulns_data {
        // Parse business criticality
        let criticality = match vuln.business_criticality.as_deref().unwrap_or("supporto") {
            "mission_critical" => AssetCriticality::MissionCritical,
            "core_business" => AssetCriticality::CoreBusiness,
            "supporto" => AssetCriticality::Supporto,
            "lab_test" => AssetCriticality::LabTest,
            _ => AssetCriticality::Supporto,
        };

        let exposure = match vuln.exposure_level.as_deref().unwrap_or("internal") {
            "internet_facing" => ExposureLevel::InternetFacing,
            "dmz" => ExposureLevel::DMZ,
            "internal" => ExposureLevel::Internal,
            "segmented" => ExposureLevel::Segmented,
            _ => ExposureLevel::Internal,
        };

        // Assume public exploit availability based on EPSS
        let threat_context = if vuln.epss_score > Some(0.7) {
            ThreatContext::PublicExploit
        } else if vuln.epss_score > Some(0.5) {
            ThreatContext::PoC
        } else {
            ThreatContext::NoExploit
        };

        // Calculate days open
        let now = chrono::Utc::now();
        let duration = now.signed_duration_since(vuln.discovered_at);
        let days_open = (duration.num_seconds().max(0) / 86400) as u32;

        // Build RBRE factors
        let factors = RBREFactors {
            technical_severity: RBRECalculator::normalize_cvss(vuln.cvss_score as f64),
            exploit_probability: (vuln.epss_score.unwrap_or(0.3) as f64).min(1.0).max(0.0),
            asset_criticality: criticality.score(),
            exposure_factor: exposure.score(),
            threat_context: threat_context.score(),
            time_factor: RBRECalculator::calculate_time_factor(days_open),
        };

        // Calculate RPS
        let rps_result = RBRECalculator::calculate_rps(&factors);

        // Estimate remediation hours based on difficulty
        let est_hours = RBRECalculator::estimate_remediation_hours(
            &rps_result.priority_tier,
            "medium",  // Default difficulty
            false,
        );

        total_estimated_hours += est_hours as f64;

        // Determine tier and add to appropriate phase
        let tier_idx = match rps_result.priority_tier {
            crate::remediation::PriorityTier::Critical => { critical_count += 1; 0 },
            crate::remediation::PriorityTier::High => { high_count += 1; 1 },
            crate::remediation::PriorityTier::Medium => { medium_count += 1; 2 },
            crate::remediation::PriorityTier::Low => { low_count += 1; 3 },
        };

        tier_phases[tier_idx].2.push((
            vuln.vulnerability_id,
            vuln.device_id,
            rps_result.rps,
            factors,
            rps_result.explanation,
            est_hours as i16,
        ));
    }

    // Create phases and items
    for (phase_name, phase_number, vulns_in_tier) in tier_phases {
        if !vulns_in_tier.is_empty() {
            let phase_id = Uuid::new_v4();
            let vuln_count = vulns_in_tier.len() as i32;

            let target_severity = match phase_number {
                1 => "critical",
                2 => "high",
                3 => "medium",
                _ => "low",
            };

            sqlx::query(
                r#"
                INSERT INTO remediation_plan_phases 
                (id, plan_id, phase_number, phase_name, target_severity, status, device_count, vulnerability_count)
                VALUES ($1, $2, $3, $4, $5, 'pending', $6, $7)
                "#,
            )
            .bind(phase_id)
            .bind(plan_id)
            .bind(phase_number)
            .bind(&phase_name)
            .bind(target_severity)
            .bind(req.device_ids.len() as i32)
            .bind(vuln_count)
            .execute(&mut *tx)
            .await
            .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, format!("Failed to create phase: {}", e)))?;

            // Insert items with full RBRE factor breakdown
            for (vuln_id, device_id, rps_score, factors, explanation, est_hours) in vulns_in_tier {
                let item_id = Uuid::new_v4();

                sqlx::query(
                    r#"
                    INSERT INTO remediation_plan_items 
                    (id, plan_id, phase_id, device_id, vulnerability_id, 
                     rps_score, technical_severity, exploit_probability, asset_criticality_score,
                     exposure_factor, threat_context, time_factor, rps_explanation, 
                     estimated_hours, status)
                    VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, 'pending')
                    "#,
                )
                .bind(item_id)
                .bind(plan_id)
                .bind(phase_id)
                .bind(device_id)
                .bind(vuln_id)
                .bind(rps_score)
                .bind(factors.technical_severity)
                .bind(factors.exploit_probability)
                .bind(factors.asset_criticality)
                .bind(factors.exposure_factor)
                .bind(factors.threat_context)
                .bind(factors.time_factor)
                .bind(&explanation)
                .bind(est_hours)
                .execute(&mut *tx)
                .await
                .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, format!("Failed to create plan item: {}", e)))?;
            }
        }
    }

    let estimated_start_date = chrono::Local::now().date_naive();
    let estimated_completion_date = estimated_start_date + chrono::Duration::days((total_estimated_hours / 8.0).ceil() as i64);

    sqlx::query(
        r#"
        UPDATE remediation_plans
        SET total_devices = $2,
            critical_count = $3,
            high_count = $4,
            medium_count = $5,
            low_count = $6,
            estimated_hours_total = $7,
            estimated_start_date = $8,
            estimated_completion_date = $9
        WHERE id = $1
        "#,
    )
    .bind(plan_id)
    .bind(req.device_ids.len() as i32)
    .bind(critical_count)
    .bind(high_count)
    .bind(medium_count)
    .bind(low_count)
    .bind(total_estimated_hours)
    .bind(estimated_start_date)
    .bind(estimated_completion_date)
    .execute(&mut *tx)
    .await
    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

    tx.commit().await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

    let plan = RemediationPlan {
        id: plan_id,
        name: req.name,
        description: req.description,
        status: "draft".to_string(),
        total_devices: req.device_ids.len() as i32,
        critical_count,
        high_count,
        medium_count,
        low_count,
        estimated_hours_total: total_estimated_hours,
        estimated_start_date: Some(estimated_start_date),
        estimated_completion_date: Some(estimated_completion_date),
    };

    Ok(Json(plan))
}

/// Validate if device has required fields for RBRE calculation
#[derive(Debug, Serialize, Deserialize)]
pub struct ValidationResult {
    pub is_valid: bool,
    pub missing_fields: Vec<String>,
    pub warnings: Vec<String>,
}

pub async fn validate_device_for_rbre(
    State(state): State<AppState>,
    Path(device_id): Path<Uuid>,
) -> Result<Json<ValidationResult>, (StatusCode, String)> {
    let mut missing_fields = Vec::new();
    let mut warnings = Vec::new();

    // Query the device from database - check if device exists
    let device_exists = sqlx::query_scalar::<_, bool>("SELECT EXISTS(SELECT 1 FROM network_devices WHERE id = $1)")
        .bind(device_id)
        .fetch_one(state.pool.as_ref())
        .await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

    if !device_exists {
        return Err((StatusCode::NOT_FOUND, "Device not found".to_string()));
    }

    // Required fields for RBRE calculation
    missing_fields.push("business_criticality".to_string());
    missing_fields.push("exposure_level".to_string());
    missing_fields.push("device_use_case".to_string());
    missing_fields.push("patch_availability".to_string());
    missing_fields.push("remediation_difficulty".to_string());

    // Optional but recommended
    warnings.push("compensating_controls not documented".to_string());
    warnings.push("deployment_impact not documented".to_string());

    // Note: Once database schema is updated with RBRE fields, these validations
    // will be replaced with actual column checks

    Ok(Json(ValidationResult {
        is_valid: missing_fields.is_empty(),
        missing_fields,
        warnings,
    }))
}

/// Fetch plan details with phases and items
#[derive(Debug, Serialize, Deserialize)]
pub struct PlanItem {
    pub id: Uuid,
    pub vulnerability_id: Uuid,
    pub device_id: Uuid,
    pub rps_score: f64,
    pub technical_severity: f64,
    pub exploit_probability: f64,
    pub asset_criticality_score: f64,
    pub exposure_factor: f64,
    pub threat_context: f64,
    pub time_factor: f64,
    pub rps_explanation: Option<String>,
    pub estimated_hours: i16,
    pub status: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Phase {
    pub id: Uuid,
    pub phase_number: i32,
    pub phase_name: String,
    pub target_severity: Option<String>,
    pub status: String,
    pub vulnerability_count: i32,
    pub items: Vec<serde_json::Value>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct PlanDetails {
    pub id: Uuid,
    pub name: String,
    pub description: Option<String>,
    pub status: String,
    pub total_devices: i32,
    pub critical_count: i32,
    pub high_count: i32,
    pub medium_count: i32,
    pub low_count: i32,
    pub estimated_hours_total: Option<f64>,
    pub estimated_start_date: Option<chrono::NaiveDate>,
    pub estimated_completion_date: Option<chrono::NaiveDate>,
    pub phases: Vec<Phase>,
}

pub async fn get_remediation_plan_details(
    State(state): State<AppState>,
    _claims: crate::auth::Claims,
    Path(plan_id): Path<Uuid>,
) -> Result<Json<serde_json::Value>, (StatusCode, String)> {
    // Fetch plan
    let plan = sqlx::query!(
        r#"
        SELECT id, name, description, status, total_devices, critical_count, high_count, 
               medium_count, low_count, estimated_hours_total, estimated_start_date, estimated_completion_date
        FROM remediation_plans
        WHERE id = $1
        "#,
        plan_id
    )
    .fetch_optional(&*state.pool)
    .await
    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, format!("Database error: {}", e)))?
    .ok_or_else(|| (StatusCode::NOT_FOUND, "Plan not found".to_string()))?;

    // Fetch phases
    let phases = sqlx::query!(
        r#"
        SELECT id, phase_number, phase_name, target_severity, status, vulnerability_count
        FROM remediation_plan_phases
        WHERE plan_id = $1
        ORDER BY phase_number ASC
        "#,
        plan_id
    )
    .fetch_all(&*state.pool)
    .await
    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, format!("Database error: {}", e)))?;

    let mut phases_data = Vec::new();

    for phase in phases {
        // Fetch items for this phase
        let items = sqlx::query!(
            r#"
            SELECT rpi.id, rpi.vulnerability_id, rpi.device_id, rpi.rps_score, 
                   rpi.technical_severity, rpi.exploit_probability, rpi.asset_criticality_score,
                   rpi.exposure_factor, rpi.threat_context, rpi.time_factor, rpi.rps_explanation,
                   rpi.estimated_hours, rpi.status,
                   v.cve_id, v.title, v.cvss_score, v.severity::TEXT as severity,
                   nd.hostname, nd.ip_address
            FROM remediation_plan_items rpi
            JOIN vulnerabilities v ON rpi.vulnerability_id = v.id
            JOIN network_devices nd ON rpi.device_id = nd.id
            WHERE rpi.phase_id = $1
            ORDER BY rpi.rps_score DESC
            "#,
            phase.id
        )
        .fetch_all(&*state.pool)
        .await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, format!("Database error: {}", e)))?;

        let items_json = items.iter().map(|item| {
            serde_json::json!({
                "id": item.id,
                "vulnerability_id": item.vulnerability_id,
                "device_id": item.device_id,
                "rps_score": item.rps_score.to_string().parse::<f64>().unwrap_or(0.0),
                "technical_severity": item.technical_severity.to_string().parse::<f64>().unwrap_or(0.0),
                "exploit_probability": item.exploit_probability.to_string().parse::<f64>().unwrap_or(0.0),
                "asset_criticality_score": item.asset_criticality_score.to_string().parse::<f64>().unwrap_or(0.0),
                "exposure_factor": item.exposure_factor.to_string().parse::<f64>().unwrap_or(0.0),
                "threat_context": item.threat_context.to_string().parse::<f64>().unwrap_or(0.0),
                "time_factor": item.time_factor.to_string().parse::<f64>().unwrap_or(0.0),
                "rps_explanation": item.rps_explanation,
                "estimated_hours": item.estimated_hours,
                "status": item.status,
                "vulnerability": {
                    "cve_id": item.cve_id,
                    "title": item.title,
                    "cvss_score": item.cvss_score,
                    "severity": item.severity,
                },
                "device": {
                    "hostname": item.hostname,
                    "ip_address": item.ip_address,
                }
            })
        }).collect::<Vec<_>>();

        phases_data.push(serde_json::json!({
            "id": phase.id,
            "phase_number": phase.phase_number,
            "phase_name": phase.phase_name,
            "target_severity": phase.target_severity,
            "status": phase.status,
            "vulnerability_count": phase.vulnerability_count,
            "items": items_json,
        }));
    }

    let plan_details = serde_json::json!({
        "id": plan.id,
        "name": plan.name,
        "description": plan.description,
        "status": plan.status,
        "total_devices": plan.total_devices,
        "critical_count": plan.critical_count,
        "high_count": plan.high_count,
        "medium_count": plan.medium_count,
        "low_count": plan.low_count,
        "estimated_hours_total": plan.estimated_hours_total.map(|bd| bd.to_string().parse::<f64>().unwrap_or(0.0)).unwrap_or(0.0),
        "estimated_start_date": plan.estimated_start_date,
        "estimated_completion_date": plan.estimated_completion_date,
        "phases": phases_data,
    });

    Ok(Json(plan_details))
}

/// Execute a remediation plan
pub async fn execute_remediation_plan(
    State(state): State<AppState>,
    claims: crate::auth::Claims,
    Path(plan_id): Path<Uuid>,
) -> Result<Json<serde_json::Value>, (StatusCode, String)> {
    let user_id = Uuid::parse_str(&claims.sub)
        .map_err(|_| (StatusCode::BAD_REQUEST, "Invalid user ID".to_string()))?;

    // Update plan status to in_progress
    sqlx::query(
        r#"
        UPDATE remediation_plans
        SET status = 'in_progress', started_at = NOW()
        WHERE id = $1
        "#
    )
    .bind(plan_id)
    .execute(&*state.pool)
    .await
    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, format!("Failed to update plan: {}", e)))?;

    // Create remediation tasks for all items
    sqlx::query(
        r#"
        INSERT INTO remediation_tasks (id, device_id, vulnerability_id, task_type, status, created_by)
        SELECT uuid_generate_v4(), device_id, vulnerability_id, 'auto', 'pending', $2
        FROM remediation_plan_items
        WHERE plan_id = $1 AND status = 'pending'
        ON CONFLICT DO NOTHING
        "#
    )
    .bind(plan_id)
    .bind(user_id)
    .execute(&*state.pool)
    .await
    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, format!("Failed to create tasks: {}", e)))?;

    Ok(Json(serde_json::json!({
        "status": "success",
        "message": "Plan execution started",
        "plan_id": plan_id
    })))
}

/// Export a remediation plan
pub async fn export_remediation_plan(
    State(state): State<AppState>,
    _claims: crate::auth::Claims,
    Path(plan_id): Path<Uuid>,
) -> Result<Json<serde_json::Value>, (StatusCode, String)> {
    // Fetch plan details
    let plan = sqlx::query!(
        r#"
        SELECT id, name, description, status, total_devices, critical_count, high_count, 
               medium_count, low_count, estimated_hours_total, estimated_start_date, estimated_completion_date
        FROM remediation_plans
        WHERE id = $1
        "#,
        plan_id
    )
    .fetch_optional(&*state.pool)
    .await
    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, format!("Database error: {}", e)))?
    .ok_or_else(|| (StatusCode::NOT_FOUND, "Plan not found".to_string()))?;

    // Fetch all phases and items
    let phases = sqlx::query!(
        r#"
        SELECT id, phase_number, phase_name, target_severity, status, vulnerability_count
        FROM remediation_plan_phases
        WHERE plan_id = $1
        ORDER BY phase_number ASC
        "#,
        plan_id
    )
    .fetch_all(&*state.pool)
    .await
    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, format!("Database error: {}", e)))?;

    let mut phases_data = Vec::new();

    for phase in phases {
        let items = sqlx::query!(
            r#"
            SELECT rpi.id, rpi.rps_score, rpi.technical_severity, rpi.exploit_probability,
                   rpi.asset_criticality_score, rpi.exposure_factor, rpi.threat_context, rpi.time_factor,
                   rpi.rps_explanation, rpi.estimated_hours, rpi.status,
                   v.cve_id, v.title, v.cvss_score, v.severity::TEXT as severity,
                   nd.hostname, nd.ip_address
            FROM remediation_plan_items rpi
            JOIN vulnerabilities v ON rpi.vulnerability_id = v.id
            JOIN network_devices nd ON rpi.device_id = nd.id
            WHERE rpi.phase_id = $1
            ORDER BY rpi.rps_score DESC
            "#,
            phase.id
        )
        .fetch_all(&*state.pool)
        .await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, format!("Database error: {}", e)))?;

        let items_json = items.iter().map(|item| {
            let device_name = item.hostname.clone()
                .unwrap_or_else(|| item.ip_address.to_string());
            let ip_str = item.ip_address.to_string();
            
            serde_json::json!({
                "cve": item.cve_id,
                "title": item.title,
                "cvss": item.cvss_score,
                "severity": item.severity,
                "device": device_name,
                "ip": ip_str,
                "rps_score": item.rps_score.to_string().parse::<f64>().unwrap_or(0.0),
                "explanation": item.rps_explanation,
                "estimated_hours": item.estimated_hours,
                "status": item.status,
            })
        }).collect::<Vec<_>>();

        phases_data.push(serde_json::json!({
            "phase": phase.phase_number,
            "name": phase.phase_name,
            "severity": phase.target_severity,
            "status": phase.status,
            "vulnerability_count": phase.vulnerability_count,
            "items": items_json,
        }));
    }

    let export_data = serde_json::json!({
        "plan": {
            "id": plan.id,
            "name": plan.name,
            "description": plan.description,
            "status": plan.status,
            "created_at": chrono::Utc::now().to_rfc3339(),
        },
        "summary": {
            "total_devices": plan.total_devices,
            "critical": plan.critical_count,
            "high": plan.high_count,
            "medium": plan.medium_count,
            "low": plan.low_count,
            "estimated_hours": plan.estimated_hours_total.map(|bd| bd.to_string().parse::<f64>().unwrap_or(0.0)).unwrap_or(0.0),
            "start_date": plan.estimated_start_date,
            "completion_date": plan.estimated_completion_date,
        },
        "phases": phases_data,
    });

    Ok(Json(export_data))
}

/// Get devices with open/in-progress vulnerabilities for remediation planning
pub async fn get_devices_for_remediation(
    State(state): State<AppState>,
    _claims: crate::auth::Claims,
) -> Result<Json<Vec<serde_json::Value>>, (StatusCode, String)> {
    let devices = sqlx::query!(
        r#"
        SELECT 
            nd.id,
            nd.hostname,
            nd.ip_address,
            nd.device_type::text as device_type,
            COALESCE(COUNT(DISTINCT CASE WHEN v.status IN ('open', 'in_progress') THEN v.id END), 0) as vulnerability_count
        FROM network_devices nd
        LEFT JOIN device_vulnerabilities dv ON nd.id = dv.device_id
        LEFT JOIN vulnerabilities v ON dv.vulnerability_id = v.id AND v.status IN ('open', 'in_progress')
        GROUP BY nd.id, nd.hostname, nd.ip_address, nd.device_type
        ORDER BY vulnerability_count DESC, nd.hostname
        "#
    )
    .fetch_all(&*state.pool)
    .await
    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, format!("Failed to fetch devices: {}", e)))?;

    let result = devices.into_iter().map(|row| {
        serde_json::json!({
            "id": row.id,
            "hostname": row.hostname,
            "ip_address": row.ip_address,
            "device_type": row.device_type,
            "vulnerability_count": row.vulnerability_count.unwrap_or(0),
        })
    }).collect();

    Ok(Json(result))
}
