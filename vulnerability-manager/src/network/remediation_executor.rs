// src/network/remediation_executor.rs
// Remediation script execution engine

use sqlx::PgPool;
use std::time::Duration;
use tokio::time::sleep;
use uuid::Uuid;

#[derive(Clone)]
pub struct RemediationExecutor {
    pool: PgPool,
}

impl RemediationExecutor {
    pub fn new(pool: PgPool) -> Self {
        Self { pool }
    }

    /// Start the remediation executor worker
    pub async fn start_worker(self) {
        tracing::info!("Starting remediation executor worker");

        tokio::spawn(async move {
            loop {
                // Poll for pending tasks
                match self.process_pending_tasks().await {
                    Ok(tasks_processed) => {
                        if tasks_processed > 0 {
                            tracing::info!("Processed {} remediation tasks", tasks_processed);
                        }
                    }
                    Err(e) => {
                        tracing::error!("Error processing remediation tasks: {}", e);
                    }
                }

                // Sleep for 5 seconds before checking again
                sleep(Duration::from_secs(5)).await;
            }
        });
    }

    /// Process all pending remediation tasks
    async fn process_pending_tasks(&self) -> Result<usize, sqlx::Error> {
        // Fetch pending tasks
        let tasks = sqlx::query!(
            r#"
            SELECT id, device_id, vulnerability_id, task_type, script, created_by
            FROM remediation_tasks
            WHERE status = 'pending'
            ORDER BY created_at ASC
            LIMIT 10
            "#
        )
        .fetch_all(&self.pool)
        .await?;

        let count = tasks.len();

        for task in tasks {
            // Mark task as running
            sqlx::query!(
                "UPDATE remediation_tasks SET status = 'running', started_at = NOW() WHERE id = $1",
                task.id
            )
            .execute(&self.pool)
            .await
            .ok();

            // Execute the remediation
            let result = self.execute_task(
                task.id,
                task.device_id,
                task.vulnerability_id,
                &task.task_type,
                task.script.as_deref(),
            ).await;

            // Update task status based on result
            match result {
                Ok(output) => {
                    sqlx::query!(
                        r#"
                        UPDATE remediation_tasks
                        SET status = 'completed', completed_at = NOW(), output = $2
                        WHERE id = $1
                        "#,
                        task.id,
                        output
                    )
                    .execute(&self.pool)
                    .await
                    .ok();

                    // Update vulnerability status to resolved
                    sqlx::query!(
                        r#"
                        UPDATE device_vulnerabilities
                        SET remediation_status = 'remediated', remediated_at = NOW()
                        WHERE device_id = $1 AND vulnerability_id = $2
                        "#,
                        task.device_id,
                        task.vulnerability_id
                    )
                    .execute(&self.pool)
                    .await
                    .ok();

                    // Log audit event
                    sqlx::query!(
                        r#"
                        INSERT INTO audit_logs (user_id, action, entity_type, entity_id, old_values, new_values, ip_address)
                        VALUES ($1, $2, $3, $4, $5, $6, $7)
                        "#,
                        task.created_by,
                        "complete_remediation_task",
                        "remediation_task",
                        task.id,
                        serde_json::json!({"status": "running"}),
                        serde_json::json!({"status": "completed", "output": output}),
                        None as Option<String>
                    )
                    .execute(&self.pool)
                    .await
                    .ok();

                    tracing::info!("Remediation task {} completed successfully", task.id);
                }
                Err(error_msg) => {
                    sqlx::query!(
                        r#"
                        UPDATE remediation_tasks
                        SET status = 'failed', completed_at = NOW(), error_message = $2
                        WHERE id = $1
                        "#,
                        task.id,
                        error_msg
                    )
                    .execute(&self.pool)
                    .await
                    .ok();

                    // Log audit event
                    sqlx::query!(
                        r#"
                        INSERT INTO audit_logs (user_id, action, entity_type, entity_id, old_values, new_values, ip_address)
                        VALUES ($1, $2, $3, $4, $5, $6, $7)
                        "#,
                        task.created_by,
                        "fail_remediation_task",
                        "remediation_task",
                        task.id,
                        serde_json::json!({"status": "running"}),
                        serde_json::json!({"status": "failed", "error": error_msg}),
                        None as Option<String>
                    )
                    .execute(&self.pool)
                    .await
                    .ok();

                    tracing::error!("Remediation task {} failed: {}", task.id, error_msg);
                }
            }
        }

        Ok(count)
    }

    /// Execute a single remediation task
    async fn execute_task(
        &self,
        task_id: Uuid,
        device_id: Uuid,
        vulnerability_id: Uuid,
        task_type: &str,
        script: Option<&str>,
    ) -> Result<String, String> {
        tracing::info!(
            "Executing remediation task {} (type: {}) for device {} and vulnerability {}",
            task_id,
            task_type,
            device_id,
            vulnerability_id
        );

        match task_type {
            "auto" => self.execute_auto_remediation(device_id, vulnerability_id).await,
            "script" => self.execute_custom_script(device_id, script).await,
            _ => Err(format!("Unknown task type: {}", task_type)),
        }
    }

    /// Execute automatic remediation based on vulnerability type
    async fn execute_auto_remediation(
        &self,
        device_id: Uuid,
        vulnerability_id: Uuid,
    ) -> Result<String, String> {
        // Fetch device details
        let device = sqlx::query!(
            "SELECT ip_address::TEXT as ip_address, os_name FROM network_devices WHERE id = $1",
            device_id
        )
        .fetch_optional(&self.pool)
        .await
        .map_err(|e| format!("Database error: {}", e))?
        .ok_or_else(|| "Device not found".to_string())?;

        // Fetch vulnerability details
        let vulnerability = sqlx::query!(
            "SELECT cve_id, title, cvss_score FROM vulnerabilities WHERE id = $1",
            vulnerability_id
        )
        .fetch_optional(&self.pool)
        .await
        .map_err(|e| format!("Database error: {}", e))?
        .ok_or_else(|| "Vulnerability not found".to_string())?;

        // Generate automatic remediation script based on OS and vulnerability
        let os_name = device.os_name.as_deref().unwrap_or("unknown");
        let ip_address = device.ip_address.as_deref().unwrap_or("unknown");
        let script = self.generate_auto_script(os_name, &vulnerability.title);

        tracing::info!(
            "Generated auto-remediation script for {} ({}) - CVE: {:?}",
            ip_address,
            os_name,
            vulnerability.cve_id
        );

        // For safety, we don't execute auto scripts on real devices in this implementation
        // In production, you would use SSH/WinRM to connect and execute
        let output = format!(
            "AUTO REMEDIATION SIMULATED\nDevice: {} ({})\nVulnerability: {}\nCVSS Score: {}\n\nGenerated script:\n{}\n\nStatus: Would execute on real device",
            ip_address,
            os_name,
            vulnerability.title,
            vulnerability.cvss_score,
            script
        );

        Ok(output)
    }

    /// Execute custom script
    async fn execute_custom_script(&self, device_id: Uuid, script: Option<&str>) -> Result<String, String> {
        let script = script.ok_or_else(|| "No script provided".to_string())?;

        // Fetch device details
        let device = sqlx::query!(
            "SELECT ip_address::TEXT as ip_address FROM network_devices WHERE id = $1",
            device_id
        )
        .fetch_optional(&self.pool)
        .await
        .map_err(|e| format!("Database error: {}", e))?
        .ok_or_else(|| "Device not found".to_string())?;

        let ip_address = device.ip_address.as_deref().unwrap_or("unknown");

        tracing::info!("Executing custom script for device: {}", ip_address);

        // For safety, validate script doesn't contain dangerous commands
        if Self::is_dangerous_script(script) {
            return Err("Script contains potentially dangerous commands".to_string());
        }

        // In production, execute script via SSH/WinRM
        // For now, simulate execution
        let output = format!(
            "CUSTOM SCRIPT SIMULATED\nDevice: {}\n\nScript:\n{}\n\nStatus: Would execute on real device\n\nNOTE: In production, this would connect via SSH/WinRM and execute the script securely.",
            ip_address,
            script
        );

        Ok(output)
    }

    /// Generate automatic remediation script based on OS and vulnerability
    fn generate_auto_script(&self, os_name: &str, vulnerability_title: &str) -> String {
        let title_lower = vulnerability_title.to_lowercase();

        if os_name.to_lowercase().contains("linux") || os_name.to_lowercase().contains("ubuntu") || os_name.to_lowercase().contains("debian") {
            if title_lower.contains("apache") || title_lower.contains("httpd") {
                return r#"#!/bin/bash
# Auto-remediation script for Apache vulnerability
apt-get update
apt-get upgrade apache2 -y
systemctl restart apache2
echo "Apache upgraded and restarted successfully"
"#.to_string();
            } else if title_lower.contains("openssh") || title_lower.contains("ssh") {
                return r#"#!/bin/bash
# Auto-remediation script for OpenSSH vulnerability
apt-get update
apt-get upgrade openssh-server -y
systemctl restart ssh
echo "OpenSSH upgraded and restarted successfully"
"#.to_string();
            } else {
                return r#"#!/bin/bash
# Generic Linux security update
apt-get update
apt-get upgrade -y
apt-get dist-upgrade -y
echo "System packages upgraded successfully"
"#.to_string();
            }
        } else if os_name.to_lowercase().contains("windows") {
            return r#"# PowerShell script for Windows updates
Install-Module PSWindowsUpdate -Force -Scope CurrentUser
Import-Module PSWindowsUpdate
Get-WindowsUpdate -AcceptAll -Install -AutoReboot
Write-Host "Windows updates installed successfully"
"#.to_string();
        }

        // Generic script
        r#"#!/bin/bash
# Generic remediation script
echo "Checking for updates..."
# Add appropriate update commands for your environment
echo "Remediation completed"
"#.to_string()
    }

    /// Check if script contains dangerous commands
    fn is_dangerous_script(script: &str) -> bool {
        let dangerous_commands = [
            "rm -rf /",
            "dd if=/dev/zero",
            "mkfs",
            "format c:",
            "> /dev/sda",
            "fork bomb",
            ":(){ :|:& };:",
        ];

        for cmd in &dangerous_commands {
            if script.contains(cmd) {
                return true;
            }
        }

        false
    }
}
