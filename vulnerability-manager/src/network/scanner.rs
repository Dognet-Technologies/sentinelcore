// src/network/scanner.rs
// Network scanning implementation using arp-scan, nmap, traceroute

use super::models::*;
use anyhow::Result;
use std::process::Command;
use tracing::{info, warn};
use uuid::Uuid;
use chrono::Utc;
use std::net::IpAddr;
use std::str::FromStr;

pub struct NetworkScanner {
    pub scan_id: Uuid,
}

impl NetworkScanner {
    pub fn new() -> Self {
        Self {
            scan_id: Uuid::new_v4(),
        }
    }

    /// Esegue ARP scan per scoprire devices nella rete locale
    pub async fn arp_scan(&self, target_range: &str) -> Result<Vec<NetworkDevice>> {
        info!("Starting ARP scan on range: {}", target_range);

        let output = tokio::task::spawn_blocking({
            let target_range = target_range.to_string();
            move || {
                Command::new("arp-scan")
                    .arg("--interface=eth0")
                    .arg(&target_range)
                    .arg("--retry=3")
                    .arg("--timeout=500")
                    .output()
            }
        })
        .await??;

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            warn!("ARP scan failed: {}", stderr);
            // Fallback to nmap ping scan
            return self.nmap_ping_scan(target_range).await;
        }

        let stdout = String::from_utf8_lossy(&output.stdout);
        let devices = self.parse_arp_scan_output(&stdout)?;

        info!("ARP scan completed: {} devices found", devices.len());
        Ok(devices)
    }

    /// Fallback: usa nmap per ping scan
    async fn nmap_ping_scan(&self, target_range: &str) -> Result<Vec<NetworkDevice>> {
        info!("Fallback to nmap ping scan on range: {}", target_range);

        let output = tokio::task::spawn_blocking({
            let target_range = target_range.to_string();
            move || {
                Command::new("nmap")
                    .arg("-sn") // Ping scan only
                    .arg("-PR") // ARP ping
                    .arg(&target_range)
                    .arg("-oX")
                    .arg("-") // Output XML to stdout
                    .output()
            }
        })
        .await??;

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            return Err(anyhow::anyhow!("Nmap ping scan failed: {}", stderr));
        }

        let stdout = String::from_utf8_lossy(&output.stdout);
        let devices = self.parse_nmap_xml(&stdout)?;

        Ok(devices)
    }

    /// Esegue nmap port scan e OS detection
    pub async fn nmap_scan(
        &self,
        ip_address: &str,
        include_os_detection: bool,
    ) -> Result<NetworkDevice> {
        info!("Starting nmap scan on: {}", ip_address);

        let mut args = vec![
            "-sV".to_string(),           // Version detection
            "-sC".to_string(),           // Default scripts
            "--max-retries=2".to_string(),
            ip_address.to_string(),
            "-oX".to_string(),
            "-".to_string(),             // Output XML to stdout
        ];

        if include_os_detection {
            args.insert(0, "-O".to_string()); // OS detection (requires root)
        }

        let output = tokio::task::spawn_blocking(move || {
            let mut cmd = Command::new("nmap");
            for arg in &args {
                cmd.arg(arg);
            }
            cmd.output()
        })
        .await??;

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            return Err(anyhow::anyhow!("Nmap scan failed: {}", stderr));
        }

        let stdout = String::from_utf8_lossy(&output.stdout);
        let devices = self.parse_nmap_xml(&stdout)?;

        if let Some(device) = devices.first() {
            Ok(device.clone())
        } else {
            Err(anyhow::anyhow!("No device information found"))
        }
    }

    /// Esegue traceroute per scoprire il percorso di rete
    pub async fn traceroute(&self, target_ip: &str) -> Result<Vec<NetworkLink>> {
        info!("Starting traceroute to: {}", target_ip);

        let output = tokio::task::spawn_blocking({
            let target_ip = target_ip.to_string();
            move || {
                Command::new("traceroute")
                    .arg("-n") // No DNS resolution
                    .arg("-m")
                    .arg("30") // Max hops
                    .arg(&target_ip)
                    .output()
            }
        })
        .await??;

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            return Err(anyhow::anyhow!("Traceroute failed: {}", stderr));
        }

        let stdout = String::from_utf8_lossy(&output.stdout);
        let links = self.parse_traceroute_output(&stdout)?;

        info!("Traceroute completed: {} hops found", links.len());
        Ok(links)
    }

    // Parsing functions
    fn parse_arp_scan_output(&self, output: &str) -> Result<Vec<NetworkDevice>> {
        let mut devices = Vec::new();
        let now = Utc::now();

        for line in output.lines() {
            // Skip headers and empty lines
            if line.is_empty() || line.starts_with("Interface:") || line.starts_with("Starting") {
                continue;
            }

            let parts: Vec<&str> = line.split_whitespace().collect();
            if parts.len() >= 3 {
                let ip = parts[0];
                let mac = parts[1];
                let vendor = if parts.len() > 2 {
                    Some(parts[2..].join(" "))
                } else {
                    None
                };

                devices.push(NetworkDevice {
                    id: Uuid::new_v4(),
                    ip_address: ip.to_string(),
                    mac_address: Some(mac.to_string()),
                    hostname: None,
                    device_type: DeviceType::Unknown,
                    device_status: DeviceStatus::Online,
                    vendor,
                    os_name: None,
                    os_version: None,
                    open_ports: None,
                    services: None,
                    first_seen: now,
                    last_seen: now,
                    created_at: now,
                    updated_at: now,
                });
            }
        }

        Ok(devices)
    }

    fn parse_nmap_xml(&self, _xml: &str) -> Result<Vec<NetworkDevice>> {
        // TODO: Implement proper XML parsing with quick-xml
        // For now, return empty vector
        Ok(Vec::new())
    }

    fn parse_traceroute_output(&self, output: &str) -> Result<Vec<NetworkLink>> {
        let mut links = Vec::new();
        let mut previous_ip: Option<String> = None;

        for (hop_num, line) in output.lines().enumerate() {
            let parts: Vec<&str> = line.split_whitespace().collect();

            // Find IP address in the line
            for part in &parts {
                if let Ok(_) = IpAddr::from_str(part) {
                    if previous_ip.is_some() {
                        // Create link from previous hop to current
                        links.push(NetworkLink {
                            id: Uuid::new_v4(),
                            source_device_id: Uuid::new_v4(), // TODO: lookup from database
                            target_device_id: Uuid::new_v4(), // TODO: lookup from database
                            link_type: "route".to_string(),
                            latency_ms: None,
                            hop_count: Some(hop_num as i32),
                            created_at: Utc::now(),
                        });
                    }
                    previous_ip = Some(part.to_string());
                    break;
                }
            }
        }

        Ok(links)
    }
}
