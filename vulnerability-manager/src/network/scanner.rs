// src/network/scanner.rs
// Network scanning implementation using arp-scan, nmap, traceroute

use super::models::*;
use anyhow::Result;
use std::process::Command;
use tracing::{info, warn};
use uuid::Uuid;
use chrono::Utc;
use std::net::IpAddr;
use std::str::FromStr;

pub struct NetworkScanner {
    pub scan_id: Uuid,
}

impl NetworkScanner {
    pub fn new() -> Self {
        Self {
            scan_id: Uuid::new_v4(),
        }
    }

    /// Esegue ARP scan per scoprire devices nella rete locale
    pub async fn arp_scan(&self, target_range: &str) -> Result<Vec<NetworkDevice>> {
        info!("Starting ARP scan on range: {}", target_range);

        let output = tokio::task::spawn_blocking({
            let target_range = target_range.to_string();
            move || {
                Command::new("arp-scan")
                    .arg("--interface=eth0")
                    .arg(&target_range)
                    .arg("--retry=3")
                    .arg("--timeout=500")
                    .output()
            }
        })
        .await??;

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            warn!("ARP scan failed: {}", stderr);
            // Fallback to nmap ping scan
            return self.nmap_ping_scan(target_range).await;
        }

        let stdout = String::from_utf8_lossy(&output.stdout);
        let devices = self.parse_arp_scan_output(&stdout)?;

        info!("ARP scan completed: {} devices found", devices.len());
        Ok(devices)
    }

    /// Fallback: usa nmap per ping scan
    async fn nmap_ping_scan(&self, target_range: &str) -> Result<Vec<NetworkDevice>> {
        info!("Fallback to nmap ping scan on range: {}", target_range);

        let output = tokio::task::spawn_blocking({
            let target_range = target_range.to_string();
            move || {
                Command::new("nmap")
                    .arg("-sn") // Ping scan only
                    .arg("-PR") // ARP ping
                    .arg(&target_range)
                    .arg("-oX")
                    .arg("-") // Output XML to stdout
                    .output()
            }
        })
        .await??;

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            return Err(anyhow::anyhow!("Nmap ping scan failed: {}", stderr));
        }

        let stdout = String::from_utf8_lossy(&output.stdout);
        let devices = self.parse_nmap_xml(&stdout)?;

        Ok(devices)
    }

    /// Esegue nmap port scan e OS detection
    pub async fn nmap_scan(
        &self,
        ip_address: &str,
        include_os_detection: bool,
    ) -> Result<NetworkDevice> {
        info!("Starting nmap scan on: {}", ip_address);

        let mut args = vec![
            "-sV".to_string(),           // Version detection
            "-sC".to_string(),           // Default scripts
            "--max-retries=2".to_string(),
            ip_address.to_string(),
            "-oX".to_string(),
            "-".to_string(),             // Output XML to stdout
        ];

        if include_os_detection {
            args.insert(0, "-O".to_string()); // OS detection (requires root)
        }

        let output = tokio::task::spawn_blocking(move || {
            let mut cmd = Command::new("nmap");
            for arg in &args {
                cmd.arg(arg);
            }
            cmd.output()
        })
        .await??;

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            return Err(anyhow::anyhow!("Nmap scan failed: {}", stderr));
        }

        let stdout = String::from_utf8_lossy(&output.stdout);
        let devices = self.parse_nmap_xml(&stdout)?;

        if let Some(device) = devices.first() {
            Ok(device.clone())
        } else {
            Err(anyhow::anyhow!("No device information found"))
        }
    }

    /// Esegue traceroute per scoprire il percorso di rete
    pub async fn traceroute(&self, target_ip: &str) -> Result<Vec<NetworkLink>> {
        info!("Starting traceroute to: {}", target_ip);

        let output = tokio::task::spawn_blocking({
            let target_ip = target_ip.to_string();
            move || {
                Command::new("traceroute")
                    .arg("-n") // No DNS resolution
                    .arg("-m")
                    .arg("30") // Max hops
                    .arg(&target_ip)
                    .output()
            }
        })
        .await??;

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            return Err(anyhow::anyhow!("Traceroute failed: {}", stderr));
        }

        let stdout = String::from_utf8_lossy(&output.stdout);
        let links = self.parse_traceroute_output(&stdout)?;

        info!("Traceroute completed: {} hops found", links.len());
        Ok(links)
    }

    /// Discover network links automatically using ARP table and subnet analysis
    pub async fn discover_links(&self, devices: &[NetworkDevice]) -> Result<Vec<NetworkLink>> {
        info!("Discovering network links between {} devices", devices.len());

        let mut links = Vec::new();

        // Get default gateway from routing table
        let gateway_ip = self.get_default_gateway().await.ok();

        // Find gateway device in our list
        let gateway_device = if let Some(ref gw_ip) = gateway_ip {
            devices.iter().find(|d| d.ip_address == *gw_ip)
        } else {
            None
        };

        // If we found a gateway, connect all devices to it (star topology assumption)
        if let Some(gateway) = gateway_device {
            for device in devices {
                if device.id != gateway.id {
                    links.push(NetworkLink {
                        id: Uuid::new_v4(),
                        source_device_id: gateway.id,
                        target_device_id: device.id,
                        link_type: "gateway".to_string(),
                        latency_ms: None,
                        hop_count: Some(1),
                        created_at: Utc::now(),
                    });
                }
            }
        } else {
            // No gateway found, try to infer links from same subnet
            // Group devices by /24 subnet
            for i in 0..devices.len() {
                for j in (i + 1)..devices.len() {
                    let dev1 = &devices[i];
                    let dev2 = &devices[j];

                    // Check if devices are in the same /24 subnet
                    if self.same_subnet(&dev1.ip_address, &dev2.ip_address, 24) {
                        // Create bidirectional link for same subnet
                        links.push(NetworkLink {
                            id: Uuid::new_v4(),
                            source_device_id: dev1.id,
                            target_device_id: dev2.id,
                            link_type: "subnet".to_string(),
                            latency_ms: None,
                            hop_count: Some(1),
                            created_at: Utc::now(),
                        });
                    }
                }
            }
        }

        info!("Discovered {} network links", links.len());
        Ok(links)
    }

    /// Get default gateway IP from routing table
    async fn get_default_gateway(&self) -> Result<String> {
        let output = tokio::task::spawn_blocking(|| {
            Command::new("ip")
                .arg("route")
                .arg("show")
                .arg("default")
                .output()
        })
        .await??;

        if !output.status.success() {
            return Err(anyhow::anyhow!("Failed to get default gateway"));
        }

        let stdout = String::from_utf8_lossy(&output.stdout);

        // Parse "default via 192.168.1.1 dev eth0"
        for line in stdout.lines() {
            let parts: Vec<&str> = line.split_whitespace().collect();
            if parts.len() >= 3 && parts[0] == "default" && parts[1] == "via" {
                return Ok(parts[2].to_string());
            }
        }

        Err(anyhow::anyhow!("No default gateway found"))
    }

    /// Check if two IP addresses are in the same subnet
    fn same_subnet(&self, ip1: &str, ip2: &str, prefix_len: u8) -> bool {
        use std::net::Ipv4Addr;

        let ip1_parsed = ip1.parse::<Ipv4Addr>().ok();
        let ip2_parsed = ip2.parse::<Ipv4Addr>().ok();

        if let (Some(ip1_addr), Some(ip2_addr)) = (ip1_parsed, ip2_parsed) {
            let mask = !(0xFFFFFFFFu32 >> prefix_len);
            let ip1_num = u32::from(ip1_addr);
            let ip2_num = u32::from(ip2_addr);

            (ip1_num & mask) == (ip2_num & mask)
        } else {
            false
        }
    }

    // Parsing functions
    fn parse_arp_scan_output(&self, output: &str) -> Result<Vec<NetworkDevice>> {
        let mut devices = Vec::new();
        let now = Utc::now();

        for line in output.lines() {
            // Skip headers and empty lines
            if line.is_empty() || line.starts_with("Interface:") || line.starts_with("Starting") {
                continue;
            }

            let parts: Vec<&str> = line.split_whitespace().collect();
            if parts.len() >= 3 {
                let ip = parts[0];
                let mac = parts[1];
                let vendor = if parts.len() > 2 {
                    Some(parts[2..].join(" "))
                } else {
                    None
                };

                devices.push(NetworkDevice {
                    id: Uuid::new_v4(),
                    ip_address: ip.to_string(),
                    mac_address: Some(mac.to_string()),
                    hostname: None,
                    device_type: DeviceType::Unknown,
                    device_status: DeviceStatus::Online,
                    vendor,
                    os_name: None,
                    os_version: None,
                    open_ports: None,
                    services: None,
                    first_seen: now,
                    last_seen: now,
                    created_at: now,
                    updated_at: now,
                });
            }
        }

        Ok(devices)
    }

    fn parse_nmap_xml(&self, xml: &str) -> Result<Vec<NetworkDevice>> {
        use quick_xml::Reader;
        use quick_xml::events::Event;

        let mut reader = Reader::from_str(xml);
        reader.trim_text(true);

        let mut devices = Vec::new();
        let mut current_device: Option<NetworkDevice> = None;
        let mut current_port: Option<i32> = None;
        let mut current_service_name: Option<String> = None;
        let mut current_service_version: Option<String> = None;
        let mut current_os_name: Option<String> = None;
        let mut open_ports: Vec<i32> = Vec::new();
        let mut services: serde_json::Map<String, serde_json::Value> = serde_json::Map::new();

        let now = Utc::now();
        let mut buf = Vec::new();

        loop {
            match reader.read_event_into(&mut buf) {
                Ok(Event::Start(ref e)) | Ok(Event::Empty(ref e)) => {
                    match e.name().as_ref() {
                        b"host" => {
                            current_device = Some(NetworkDevice {
                                id: Uuid::new_v4(),
                                ip_address: String::new(),
                                mac_address: None,
                                hostname: None,
                                device_type: DeviceType::Unknown,
                                device_status: DeviceStatus::Online,
                                vendor: None,
                                os_name: None,
                                os_version: None,
                                open_ports: None,
                                services: None,
                                first_seen: now,
                                last_seen: now,
                                created_at: now,
                                updated_at: now,
                            });
                            open_ports.clear();
                            services.clear();
                        },
                        b"address" => {
                            if let Some(ref mut device) = current_device {
                                let mut addr_type = String::new();
                                let mut addr = String::new();
                                let mut vendor = None;

                                for attr in e.attributes() {
                                    if let Ok(attr) = attr {
                                        match attr.key.as_ref() {
                                            b"addrtype" => addr_type = String::from_utf8_lossy(&attr.value).to_string(),
                                            b"addr" => addr = String::from_utf8_lossy(&attr.value).to_string(),
                                            b"vendor" => vendor = Some(String::from_utf8_lossy(&attr.value).to_string()),
                                            _ => {}
                                        }
                                    }
                                }

                                if addr_type == "ipv4" || addr_type == "ipv6" {
                                    device.ip_address = addr;
                                } else if addr_type == "mac" {
                                    device.mac_address = Some(addr);
                                    device.vendor = vendor;
                                }
                            }
                        },
                        b"hostname" => {
                            if let Some(ref mut device) = current_device {
                                for attr in e.attributes() {
                                    if let Ok(attr) = attr {
                                        if attr.key.as_ref() == b"name" {
                                            device.hostname = Some(String::from_utf8_lossy(&attr.value).to_string());
                                        }
                                    }
                                }
                            }
                        },
                        b"port" => {
                            current_port = None;
                            for attr in e.attributes() {
                                if let Ok(attr) = attr {
                                    if attr.key.as_ref() == b"portid" {
                                        if let Ok(port) = String::from_utf8_lossy(&attr.value).parse::<i32>() {
                                            current_port = Some(port);
                                        }
                                    }
                                }
                            }
                        },
                        b"state" => {
                            if let Some(port) = current_port {
                                for attr in e.attributes() {
                                    if let Ok(attr) = attr {
                                        if attr.key.as_ref() == b"state" {
                                            let state = String::from_utf8_lossy(&attr.value);
                                            if state == "open" {
                                                open_ports.push(port);
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        b"service" => {
                            current_service_name = None;
                            current_service_version = None;

                            for attr in e.attributes() {
                                if let Ok(attr) = attr {
                                    match attr.key.as_ref() {
                                        b"name" => current_service_name = Some(String::from_utf8_lossy(&attr.value).to_string()),
                                        b"product" => {
                                            let product = String::from_utf8_lossy(&attr.value).to_string();
                                            current_service_version = Some(product);
                                        },
                                        b"version" => {
                                            if let Some(ref mut ver) = current_service_version {
                                                ver.push(' ');
                                                ver.push_str(&String::from_utf8_lossy(&attr.value));
                                            }
                                        },
                                        _ => {}
                                    }
                                }
                            }

                            if let (Some(port), Some(name)) = (current_port, current_service_name.clone()) {
                                let mut service_info = serde_json::Map::new();
                                service_info.insert("name".to_string(), serde_json::Value::String(name));
                                if let Some(version) = current_service_version.clone() {
                                    service_info.insert("version".to_string(), serde_json::Value::String(version));
                                }
                                services.insert(port.to_string(), serde_json::Value::Object(service_info));
                            }
                        },
                        b"osmatch" => {
                            // Parse OS detection results (take first match with highest accuracy)
                            if current_os_name.is_none() {
                                for attr in e.attributes() {
                                    if let Ok(attr) = attr {
                                        if attr.key.as_ref() == b"name" {
                                            current_os_name = Some(String::from_utf8_lossy(&attr.value).to_string());
                                        }
                                    }
                                }
                            }
                        },
                        _ => {}
                    }
                },
                Ok(Event::End(ref e)) => {
                    if e.name().as_ref() == b"host" {
                        if let Some(mut device) = current_device.take() {
                            if !device.ip_address.is_empty() {
                                device.open_ports = Some(open_ports.clone());
                                device.services = Some(serde_json::Value::Object(services.clone()));
                                device.os_name = current_os_name.clone();

                                // Infer device type from open ports and services
                                device.device_type = Self::infer_device_type(&open_ports, &services);

                                devices.push(device);
                            }
                        }
                        current_os_name = None;
                    }
                },
                Ok(Event::Eof) => break,
                Err(e) => {
                    warn!("Error parsing nmap XML at position {}: {}", reader.buffer_position(), e);
                    break;
                },
                _ => {}
            }
            buf.clear();
        }

        Ok(devices)
    }

    /// Infer device type from open ports and services
    fn infer_device_type(open_ports: &[i32], services: &serde_json::Map<String, serde_json::Value>) -> DeviceType {
        // Check for router indicators
        if open_ports.contains(&23) || open_ports.contains(&8080) || open_ports.contains(&8443) {
            return DeviceType::Router;
        }

        // Check for printer indicators
        if open_ports.contains(&9100) || open_ports.contains(&515) || open_ports.contains(&631) {
            return DeviceType::Printer;
        }

        // Check for server indicators (HTTP, HTTPS, SSH, database ports)
        let server_ports = [22, 80, 443, 3306, 5432, 6379, 27017, 9200];
        if server_ports.iter().any(|p| open_ports.contains(p)) {
            return DeviceType::Server;
        }

        // Check for firewall/security device indicators
        if open_ports.contains(&10443) || open_ports.contains(&4443) {
            return DeviceType::Firewall;
        }

        // Check service names for more clues
        for (_port, service_val) in services {
            if let Some(service_obj) = service_val.as_object() {
                if let Some(name) = service_obj.get("name").and_then(|n| n.as_str()) {
                    let name_lower = name.to_lowercase();
                    if name_lower.contains("http") || name_lower.contains("ssh") {
                        return DeviceType::Server;
                    }
                    if name_lower.contains("printer") {
                        return DeviceType::Printer;
                    }
                }
            }
        }

        // Default to workstation if has some common ports open
        if !open_ports.is_empty() {
            return DeviceType::Workstation;
        }

        DeviceType::Unknown
    }

    fn parse_traceroute_output(&self, output: &str) -> Result<Vec<NetworkLink>> {
        let mut links = Vec::new();
        let mut previous_ip: Option<String> = None;

        for (hop_num, line) in output.lines().enumerate() {
            let parts: Vec<&str> = line.split_whitespace().collect();

            // Find IP address in the line
            for part in &parts {
                if let Ok(_) = IpAddr::from_str(part) {
                    if previous_ip.is_some() {
                        // Create link from previous hop to current
                        links.push(NetworkLink {
                            id: Uuid::new_v4(),
                            source_device_id: Uuid::new_v4(), // TODO: lookup from database
                            target_device_id: Uuid::new_v4(), // TODO: lookup from database
                            link_type: "route".to_string(),
                            latency_ms: None,
                            hop_count: Some(hop_num as i32),
                            created_at: Utc::now(),
                        });
                    }
                    previous_ip = Some(part.to_string());
                    break;
                }
            }
        }

        Ok(links)
    }
}
