// src/network/handler.rs
// API handlers for network scanning and topology

use axum::{
    extract::{Path, State},
    http::StatusCode,
    Json,
};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use crate::state::AppState;
use crate::auth::Claims;
use super::models::*;
use super::scanner::NetworkScanner;

#[derive(Debug, Serialize)]
pub struct ErrorResponse {
    pub error: String,
}

/// Avvia un nuovo network scan
pub async fn start_network_scan(
    State(app_state): State<AppState>,
    claims: Claims,
    Json(request): Json<StartScanRequest>,
) -> Result<Json<ScanProgress>, (StatusCode, Json<ErrorResponse>)> {
    let scanner = NetworkScanner::new();
    let scan_id = scanner.scan_id;
    let pool = app_state.pool.clone();
    let user_id = claims.sub;

    // Create scan record in database
    sqlx::query!(
        "INSERT INTO network_scans (id, scan_name, scan_type, target_range, status, devices_found, created_by, created_at)
         VALUES ($1, $2, $3, $4, $5, $6, $7, NOW())",
        scan_id,
        request.scan_name,
        request.scan_type,
        request.target_range,
        "running",
        0,
        user_id
    )
    .execute(&*pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to create scan record: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to create scan record".to_string(),
            }),
        )
    })?;

    // Spawn async task to perform scan
    tokio::spawn(async move {
        let started_at = chrono::Utc::now();

        // Update scan status to started
        let _ = sqlx::query!(
            "UPDATE network_scans SET started_at = $1 WHERE id = $2",
            started_at,
            scan_id
        )
        .execute(&*pool)
        .await;

        // Perform ARP scan
        match scanner.arp_scan(&request.target_range).await {
            Ok(devices) => {
                tracing::info!("Scan completed: {} devices found", devices.len());

                // Save devices to database
                for device in &devices {
                    let result = sqlx::query!(
                        "INSERT INTO network_devices
                         (id, ip_address, mac_address, hostname, device_type, device_status,
                          vendor, os_name, os_version, open_ports, services, first_seen, last_seen, created_at, updated_at)
                         VALUES ($1, $2, $3, $4, $5::device_type, $6::device_status, $7, $8, $9, $10, $11, $12, $13, NOW(), NOW())
                         ON CONFLICT (ip_address)
                         DO UPDATE SET
                            mac_address = COALESCE(EXCLUDED.mac_address, network_devices.mac_address),
                            hostname = COALESCE(EXCLUDED.hostname, network_devices.hostname),
                            device_status = EXCLUDED.device_status,
                            last_seen = EXCLUDED.last_seen,
                            updated_at = NOW()",
                        device.id,
                        device.ip_address,
                        device.mac_address,
                        device.hostname,
                        format!("{:?}", device.device_type).to_lowercase() as _,
                        format!("{:?}", device.device_status).to_lowercase() as _,
                        device.vendor,
                        device.os_name,
                        device.os_version,
                        device.open_ports.as_ref().map(|ports| ports.as_slice()),
                        device.services.as_ref(),
                        device.first_seen,
                        device.last_seen
                    )
                    .execute(&*pool)
                    .await;

                    if let Err(e) = result {
                        tracing::error!("Failed to save device {}: {}", device.ip_address, e);
                    }
                }

                // Update scan status to completed
                let _ = sqlx::query!(
                    "UPDATE network_scans SET status = $1, devices_found = $2, completed_at = NOW() WHERE id = $3",
                    "completed",
                    devices.len() as i32,
                    scan_id
                )
                .execute(&*pool)
                .await;

                tracing::info!("Scan {} completed successfully", scan_id);
            }
            Err(e) => {
                tracing::error!("Scan {} failed: {}", scan_id, e);

                // Update scan status to failed
                let _ = sqlx::query!(
                    "UPDATE network_scans SET status = $1, completed_at = NOW() WHERE id = $2",
                    "failed",
                    scan_id
                )
                .execute(&*pool)
                .await;
            }
        }
    });

    Ok(Json(ScanProgress {
        scan_id,
        status: "running".to_string(),
        progress_percent: 0.0,
        devices_found: 0,
        message: Some("Scan started successfully".to_string()),
    }))
}

/// Ottieni lo stato di un scan in corso
pub async fn get_scan_status(
    State(app_state): State<AppState>,
    Path(scan_id): Path<Uuid>,
) -> Result<Json<ScanProgress>, (StatusCode, Json<ErrorResponse>)> {
    let pool = &*app_state.pool;

    let scan = sqlx::query!(
        "SELECT status, devices_found FROM network_scans WHERE id = $1",
        scan_id
    )
    .fetch_optional(pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch scan status: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to fetch scan status".to_string(),
            }),
        )
    })?;

    match scan {
        Some(scan) => {
            let progress_percent = match scan.status.as_str() {
                "completed" => 100.0,
                "failed" => 100.0,
                "running" => 50.0,
                _ => 0.0,
            };

            Ok(Json(ScanProgress {
                scan_id,
                status: scan.status,
                progress_percent,
                devices_found: scan.devices_found,
                message: None,
            }))
        }
        None => Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Scan not found".to_string(),
            }),
        )),
    }
}

/// Ottieni la topologia di rete completa
pub async fn get_network_topology(
    State(app_state): State<AppState>,
) -> Result<Json<NetworkTopology>, (StatusCode, Json<ErrorResponse>)> {
    let pool = &*app_state.pool;

    // Fetch all devices
    let devices_rows = sqlx::query!(
        "SELECT id, ip_address, mac_address, hostname, device_type, device_status,
                vendor, os_name, os_version, open_ports, services, first_seen, last_seen,
                created_at, updated_at
         FROM network_devices
         ORDER BY last_seen DESC"
    )
    .fetch_all(pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch devices: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to fetch network devices".to_string(),
            }),
        )
    })?;

    let devices: Vec<NetworkDevice> = devices_rows
        .into_iter()
        .map(|row| {
            let device_type = match row.device_type.to_lowercase().as_str() {
                "router" => DeviceType::Router,
                "switch" => DeviceType::Switch,
                "firewall" => DeviceType::Firewall,
                "server" => DeviceType::Server,
                "workstation" => DeviceType::Workstation,
                "iot" => DeviceType::IoT,
                "printer" => DeviceType::Printer,
                _ => DeviceType::Unknown,
            };

            let device_status = match row.device_status.to_lowercase().as_str() {
                "online" => DeviceStatus::Online,
                "offline" => DeviceStatus::Offline,
                _ => DeviceStatus::Unknown,
            };

            NetworkDevice {
                id: row.id,
                ip_address: row.ip_address,
                mac_address: row.mac_address,
                hostname: row.hostname,
                device_type,
                device_status,
                vendor: row.vendor,
                os_name: row.os_name,
                os_version: row.os_version,
                open_ports: row.open_ports.map(|arr| arr.into_iter().map(|p| p as i32).collect()),
                services: row.services,
                first_seen: row.first_seen,
                last_seen: row.last_seen,
                created_at: row.created_at,
                updated_at: row.updated_at,
            }
        })
        .collect();

    // Fetch all links
    let links_rows = sqlx::query!(
        "SELECT id, source_device_id, target_device_id, link_type, latency_ms, hop_count, created_at
         FROM network_links"
    )
    .fetch_all(pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch links: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to fetch network links".to_string(),
            }),
        )
    })?;

    let links: Vec<NetworkLink> = links_rows
        .into_iter()
        .map(|row| NetworkLink {
            id: row.id,
            source_device_id: row.source_device_id,
            target_device_id: row.target_device_id,
            link_type: row.link_type,
            latency_ms: row.latency_ms,
            hop_count: row.hop_count,
            created_at: row.created_at,
        })
        .collect();

    // Fetch latest scan info
    let latest_scan = sqlx::query!(
        "SELECT id, scan_name, scan_type, target_range, status, devices_found,
                started_at, completed_at, created_by, created_at
         FROM network_scans
         ORDER BY created_at DESC
         LIMIT 1"
    )
    .fetch_optional(pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch latest scan: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to fetch latest scan info".to_string(),
            }),
        )
    })?;

    let scan_info = latest_scan.map(|row| NetworkScan {
        id: row.id,
        scan_name: row.scan_name,
        scan_type: row.scan_type,
        target_range: row.target_range,
        status: row.status,
        devices_found: row.devices_found,
        started_at: row.started_at,
        completed_at: row.completed_at,
        created_by: row.created_by,
        created_at: row.created_at,
    });

    let topology = NetworkTopology {
        devices,
        links,
        scan_info,
    };

    Ok(Json(topology))
}

/// Ottieni dettagli di un device specifico con vulnerabilit√† associate
pub async fn get_device_details(
    State(_app_state): State<AppState>,
    Path(_device_id): Path<Uuid>,
) -> Result<Json<DeviceDetails>, (StatusCode, Json<ErrorResponse>)> {
    // TODO: Query database for device and related vulnerabilities

    let details = DeviceDetails {
        device: None,
        vulnerabilities: Vec::new(),
        remediation_suggestions: Vec::new(),
    };

    Ok(Json(details))
}

/// Esegui remediation su un device
pub async fn execute_remediation(
    State(_app_state): State<AppState>,
    _claims: Claims,
    Path(_device_id): Path<Uuid>,
    Json(_request): Json<RemediationRequest>,
) -> Result<Json<RemediationResponse>, (StatusCode, Json<ErrorResponse>)> {
    // TODO: Implement remediation logic

    Ok(Json(RemediationResponse {
        success: true,
        message: "Remediation queued for execution".to_string(),
        task_id: Some(Uuid::new_v4()),
    }))
}

// Additional DTOs
#[derive(Debug, Serialize)]
pub struct DeviceDetails {
    pub device: Option<NetworkDevice>,
    pub vulnerabilities: Vec<serde_json::Value>,
    pub remediation_suggestions: Vec<String>,
}

#[derive(Debug, Deserialize)]
pub struct RemediationRequest {
    pub vulnerability_id: Uuid,
    pub remediation_type: String, // auto, manual, script
    pub script: Option<String>,
}

#[derive(Debug, Serialize)]
pub struct RemediationResponse {
    pub success: bool,
    pub message: String,
    pub task_id: Option<Uuid>,
}
