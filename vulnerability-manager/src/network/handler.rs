// src/network/handler.rs
// API handlers for network scanning and topology

use axum::{
    extract::{Path, State},
    http::StatusCode,
    Json,
};
use serde::{Deserialize, Serialize};
use uuid::Uuid;
use ipnetwork::IpNetwork;

use crate::state::AppState;
use crate::auth::Claims;
use super::models::*;
use super::scanner::NetworkScanner;
use std::str::FromStr;

#[derive(Debug, Serialize)]
pub struct ErrorResponse {
    pub error: String,
}

/// Avvia un nuovo network scan
pub async fn start_network_scan(
    State(app_state): State<AppState>,
    claims: Claims,
    Json(request): Json<StartScanRequest>,
) -> Result<Json<ScanProgress>, (StatusCode, Json<ErrorResponse>)> {
    let scanner = NetworkScanner::new();
    let scan_id = scanner.scan_id;
    let pool = app_state.pool.clone();

    // Parse user_id from claims.sub (String) to Uuid
    let user_id = claims.sub.parse::<Uuid>().map_err(|e| {
        tracing::error!("Failed to parse user_id: {}", e);
        (
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: "Invalid user ID".to_string(),
            }),
        )
    })?;

    // Create scan record in database
    sqlx::query!(
        "INSERT INTO network_scans (id, scan_name, scan_type, target_range, status, devices_found, created_by, created_at)
         VALUES ($1, $2, $3, $4, $5, $6, $7, NOW())",
        scan_id,
        request.scan_name,
        request.scan_type,
        request.target_range,
        "running",
        0,
        user_id
    )
    .execute(&*pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to create scan record: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to create scan record".to_string(),
            }),
        )
    })?;

    // Parse user ID from claims
    let user_id = Uuid::parse_str(&claims.sub).map_err(|e| {
        tracing::error!("Invalid user ID in claims: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Invalid user ID".to_string(),
            }),
        )
    })?;

    // Create scan record in database
    sqlx::query!(
        r#"
        INSERT INTO network_scans (id, scan_name, scan_type, target_range, status, created_by)
        VALUES ($1, $2, $3, $4, $5, $6)
        "#,
        scan_id,
        request.scan_name,
        request.scan_type,
        request.target_range,
        "running",
        user_id
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to create scan record: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Database error: {}", e),
            }),
        )
    })?;

    // Clone pool for background task
    let pool = app_state.pool.clone();
    let target_range = request.target_range.clone();

    // Spawn async task to perform scan
    tokio::spawn(async move {
<<<<<<< HEAD
        // Update scan status to running with start time
        sqlx::query!(
            "UPDATE network_scans SET started_at = NOW() WHERE id = $1",
            scan_id
        )
        .execute(&*pool)
        .await
        .ok();
=======
        let started_at = chrono::Utc::now();

        // Update scan status to started
        let _ = sqlx::query!(
            "UPDATE network_scans SET started_at = $1 WHERE id = $2",
            started_at,
            scan_id
        )
        .execute(&*pool)
        .await;
>>>>>>> 54070529ca4023dda12368a2460afbc4608bd835

        // Perform ARP scan
        match scanner.arp_scan(&target_range).await {
            Ok(devices) => {
                tracing::info!("Scan completed: {} devices found", devices.len());

<<<<<<< HEAD
                // Save discovered devices to database
                for device in &devices {
                    // Parse IP address to IpNetwork
                    let ip_network = match sqlx::types::ipnetwork::IpNetwork::from_str(&device.ip_address) {
=======
                // Save devices to database
                for device in &devices {
                    // Parse IP address string to IpNetwork for database storage
                    let ip_network = match device.ip_address.parse::<IpNetwork>() {
>>>>>>> 54070529ca4023dda12368a2460afbc4608bd835
                        Ok(ip) => ip,
                        Err(e) => {
                            tracing::error!("Failed to parse IP address {}: {}", device.ip_address, e);
                            continue;
                        }
                    };

                    let result = sqlx::query!(
<<<<<<< HEAD
                        r#"
                        INSERT INTO network_devices (
                            ip_address, mac_address, hostname, device_type,
                            device_status, vendor, first_seen, last_seen
                        )
                        VALUES ($1, $2, $3, $4, $5, $6, NOW(), NOW())
                        ON CONFLICT (ip_address) DO UPDATE SET
                            mac_address = EXCLUDED.mac_address,
                            hostname = EXCLUDED.hostname,
                            device_status = EXCLUDED.device_status,
                            vendor = EXCLUDED.vendor,
                            last_seen = NOW(),
                            updated_at = NOW()
                        "#,
                        ip_network,
                        device.mac_address,
                        device.hostname,
                        device.device_type as _,
                        device.device_status as _,
                        device.vendor
=======
                        "INSERT INTO network_devices
                         (id, ip_address, mac_address, hostname, device_type, device_status,
                          vendor, os_name, os_version, open_ports, services, first_seen, last_seen, created_at, updated_at)
                         VALUES ($1, $2, $3, $4, $5::device_type, $6::device_status, $7, $8, $9, $10, $11, $12, $13, NOW(), NOW())
                         ON CONFLICT (ip_address)
                         DO UPDATE SET
                            mac_address = COALESCE(EXCLUDED.mac_address, network_devices.mac_address),
                            hostname = COALESCE(EXCLUDED.hostname, network_devices.hostname),
                            device_status = EXCLUDED.device_status,
                            last_seen = EXCLUDED.last_seen,
                            updated_at = NOW()",
                        device.id,
                        ip_network,
                        device.mac_address,
                        device.hostname,
                        format!("{:?}", device.device_type).to_lowercase() as _,
                        format!("{:?}", device.device_status).to_lowercase() as _,
                        device.vendor,
                        device.os_name,
                        device.os_version,
                        device.open_ports.as_ref().map(|ports| ports.as_slice()),
                        device.services.as_ref(),
                        device.first_seen,
                        device.last_seen
>>>>>>> 54070529ca4023dda12368a2460afbc4608bd835
                    )
                    .execute(&*pool)
                    .await;

                    if let Err(e) = result {
                        tracing::error!("Failed to save device {}: {}", device.ip_address, e);
                    }
                }

                // Update scan status to completed
<<<<<<< HEAD
                sqlx::query!(
                    r#"
                    UPDATE network_scans
                    SET status = 'completed', devices_found = $1, completed_at = NOW()
                    WHERE id = $2
                    "#,
=======
                let _ = sqlx::query!(
                    "UPDATE network_scans SET status = $1, devices_found = $2, completed_at = NOW() WHERE id = $3",
                    "completed",
>>>>>>> 54070529ca4023dda12368a2460afbc4608bd835
                    devices.len() as i32,
                    scan_id
                )
                .execute(&*pool)
<<<<<<< HEAD
                .await
                .ok();
            }
            Err(e) => {
                tracing::error!("Scan failed: {}", e);
                // Update scan status to failed
                sqlx::query!(
                    "UPDATE network_scans SET status = 'failed', completed_at = NOW() WHERE id = $1",
                    scan_id
                )
                .execute(&*pool)
                .await
                .ok();
=======
                .await;

                tracing::info!("Scan {} completed successfully", scan_id);
            }
            Err(e) => {
                tracing::error!("Scan {} failed: {}", scan_id, e);

                // Update scan status to failed
                let _ = sqlx::query!(
                    "UPDATE network_scans SET status = $1, completed_at = NOW() WHERE id = $2",
                    "failed",
                    scan_id
                )
                .execute(&*pool)
                .await;
>>>>>>> 54070529ca4023dda12368a2460afbc4608bd835
            }
        }
    });

    Ok(Json(ScanProgress {
        scan_id,
        status: "running".to_string(),
        progress_percent: 0.0,
        devices_found: 0,
        message: Some("Scan started successfully".to_string()),
    }))
}

/// Ottieni lo stato di un scan in corso
pub async fn get_scan_status(
    State(app_state): State<AppState>,
    Path(scan_id): Path<Uuid>,
) -> Result<Json<ScanProgress>, (StatusCode, Json<ErrorResponse>)> {
    let pool = &*app_state.pool;

    let scan = sqlx::query!(
        "SELECT status, devices_found FROM network_scans WHERE id = $1",
        scan_id
    )
    .fetch_optional(pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch scan status: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to fetch scan status".to_string(),
            }),
        )
    })?;

    match scan {
        Some(scan) => {
            let progress_percent = match scan.status.as_str() {
                "completed" => 100.0,
                "failed" => 100.0,
                "running" => 50.0,
                _ => 0.0,
            };

            Ok(Json(ScanProgress {
                scan_id,
                status: scan.status,
                progress_percent,
                devices_found: scan.devices_found.unwrap_or(0),
                message: None,
            }))
        }
        None => Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Scan not found".to_string(),
            }),
        )),
    }
}

/// Ottieni la topologia di rete completa
pub async fn get_network_topology(
    State(app_state): State<AppState>,
) -> Result<Json<NetworkTopology>, (StatusCode, Json<ErrorResponse>)> {
<<<<<<< HEAD
    // Query all network devices
    let devices = sqlx::query_as!(
        NetworkDevice,
        r#"
        SELECT
            id,
            ip_address::TEXT as "ip_address!",
            mac_address,
            hostname,
            device_type as "device_type!: DeviceType",
            device_status as "device_status!: DeviceStatus",
            vendor,
            os_name,
            os_version,
            open_ports,
            services,
            first_seen,
            last_seen,
            created_at,
            updated_at
        FROM network_devices
        ORDER BY last_seen DESC
        "#
    )
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch network devices: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Database error: {}", e),
=======
    let pool = &*app_state.pool;

    // Fetch all devices - cast enums to text for sqlx compatibility
    let devices_rows = sqlx::query!(
        "SELECT id, ip_address, mac_address, hostname,
                device_type::text as device_type,
                device_status::text as device_status,
                vendor, os_name, os_version, open_ports, services, first_seen, last_seen,
                created_at, updated_at
         FROM network_devices
         ORDER BY last_seen DESC"
    )
    .fetch_all(pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch devices: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to fetch network devices".to_string(),
>>>>>>> 54070529ca4023dda12368a2460afbc4608bd835
            }),
        )
    })?;

<<<<<<< HEAD
    // Query all network links
    let links = sqlx::query_as!(
        NetworkLink,
        r#"
        SELECT
            id,
            source_device_id,
            target_device_id,
            link_type,
            latency_ms,
            hop_count,
            created_at
        FROM network_links
        "#
    )
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch network links: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Database error: {}", e),
=======
    let devices: Vec<NetworkDevice> = devices_rows
        .into_iter()
        .map(|row| {
            let device_type = match row.device_type.as_deref().unwrap_or("unknown") {
                "router" => DeviceType::Router,
                "switch" => DeviceType::Switch,
                "firewall" => DeviceType::Firewall,
                "server" => DeviceType::Server,
                "workstation" => DeviceType::Workstation,
                "iot" => DeviceType::IoT,
                "printer" => DeviceType::Printer,
                _ => DeviceType::Unknown,
            };

            let device_status = match row.device_status.as_deref().unwrap_or("unknown") {
                "online" => DeviceStatus::Online,
                "offline" => DeviceStatus::Offline,
                _ => DeviceStatus::Unknown,
            };

            NetworkDevice {
                id: row.id,
                ip_address: row.ip_address.to_string(),
                mac_address: row.mac_address,
                hostname: row.hostname,
                device_type,
                device_status,
                vendor: row.vendor,
                os_name: row.os_name,
                os_version: row.os_version,
                open_ports: row.open_ports.map(|arr| arr.into_iter().map(|p| p as i32).collect()),
                services: row.services,
                first_seen: row.first_seen,
                last_seen: row.last_seen,
                created_at: row.created_at,
                updated_at: row.updated_at,
            }
        })
        .collect();

    // Fetch all links
    let links_rows = sqlx::query!(
        "SELECT id, source_device_id, target_device_id, link_type, latency_ms, hop_count, created_at
         FROM network_links"
    )
    .fetch_all(pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch links: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to fetch network links".to_string(),
>>>>>>> 54070529ca4023dda12368a2460afbc4608bd835
            }),
        )
    })?;

<<<<<<< HEAD
    // Get latest scan info
    let scan_info = sqlx::query_as!(
        NetworkScan,
        r#"
        SELECT
            id,
            scan_name as "scan_name!",
            scan_type as "scan_type!",
            target_range as "target_range!",
            status as "status!",
            devices_found as "devices_found!",
            started_at,
            completed_at,
            created_by,
            created_at
        FROM network_scans
        ORDER BY created_at DESC
        LIMIT 1
        "#
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch latest scan info: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Database error: {}", e),
            }),
        )
    })?;
=======
    let links: Vec<NetworkLink> = links_rows
        .into_iter()
        .map(|row| NetworkLink {
            id: row.id,
            source_device_id: row.source_device_id,
            target_device_id: row.target_device_id,
            link_type: row.link_type,
            latency_ms: row.latency_ms,
            hop_count: row.hop_count,
            created_at: row.created_at,
        })
        .collect();

    // Fetch latest scan info
    let latest_scan = sqlx::query!(
        "SELECT id, scan_name, scan_type, target_range, status, devices_found,
                started_at, completed_at, created_by, created_at
         FROM network_scans
         ORDER BY created_at DESC
         LIMIT 1"
    )
    .fetch_optional(pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch latest scan: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to fetch latest scan info".to_string(),
            }),
        )
    })?;

    let scan_info = latest_scan.map(|row| NetworkScan {
        id: row.id,
        scan_name: row.scan_name,
        scan_type: row.scan_type,
        target_range: row.target_range,
        status: row.status,
        devices_found: row.devices_found.unwrap_or(0),
        started_at: row.started_at,
        completed_at: row.completed_at,
        created_by: row.created_by,
        created_at: row.created_at,
    });
>>>>>>> 54070529ca4023dda12368a2460afbc4608bd835

    let topology = NetworkTopology {
        devices,
        links,
        scan_info,
    };

    Ok(Json(topology))
}

/// Ottieni dettagli di un device specifico con vulnerabilit√† associate
pub async fn get_device_details(
    State(app_state): State<AppState>,
    Path(device_id): Path<Uuid>,
) -> Result<Json<DeviceDetails>, (StatusCode, Json<ErrorResponse>)> {
    // Query device details
    let device = sqlx::query_as!(
        NetworkDevice,
        r#"
        SELECT
            id,
            ip_address::TEXT as "ip_address!",
            mac_address,
            hostname,
            device_type as "device_type!: DeviceType",
            device_status as "device_status!: DeviceStatus",
            vendor,
            os_name,
            os_version,
            open_ports,
            services,
            first_seen,
            last_seen,
            created_at,
            updated_at
        FROM network_devices
        WHERE id = $1
        "#,
        device_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch device details: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Database error: {}", e),
            }),
        )
    })?;

    // Query associated vulnerabilities
    let vulnerabilities = sqlx::query!(
        r#"
        SELECT
            v.id,
            v.cve_id,
            v.title,
            v.description,
            v.severity::TEXT as severity,
            v.cvss_score,
            v.status::TEXT as status,
            dv.discovered_at
        FROM vulnerabilities v
        INNER JOIN device_vulnerabilities dv ON v.id = dv.vulnerability_id
        WHERE dv.device_id = $1
        ORDER BY v.cvss_score DESC
        "#,
        device_id
    )
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch device vulnerabilities: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Database error: {}", e),
            }),
        )
    })?
    .into_iter()
    .map(|row| {
        serde_json::json!({
            "id": row.id,
            "cve_id": row.cve_id,
            "title": row.title,
            "description": row.description,
            "severity": row.severity,
            "cvss_score": row.cvss_score,
            "status": row.status,
            "discovered_at": row.discovered_at
        })
    })
    .collect();

    // Generate remediation suggestions based on vulnerabilities
    let remediation_suggestions = vec![
        "Apply latest security patches".to_string(),
        "Update operating system and software".to_string(),
        "Review and close unnecessary open ports".to_string(),
        "Enable firewall rules".to_string(),
    ];

    let details = DeviceDetails {
        device,
        vulnerabilities,
        remediation_suggestions,
    };

    Ok(Json(details))
}

/// Esegui remediation su un device
pub async fn execute_remediation(
    State(app_state): State<AppState>,
    claims: Claims,
    Path(device_id): Path<Uuid>,
    Json(request): Json<RemediationRequest>,
) -> Result<Json<RemediationResponse>, (StatusCode, Json<ErrorResponse>)> {
    // Verify device exists
    let device_exists = sqlx::query_scalar!(
        "SELECT EXISTS(SELECT 1 FROM network_devices WHERE id = $1)",
        device_id
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to check device existence: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Database error: {}", e),
            }),
        )
    })?
    .unwrap_or(false);

    if !device_exists {
        return Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Device not found".to_string(),
            }),
        ));
    }

    // Verify vulnerability exists
    let vuln_exists = sqlx::query_scalar!(
        "SELECT EXISTS(SELECT 1 FROM vulnerabilities WHERE id = $1)",
        request.vulnerability_id
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to check vulnerability existence: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Database error: {}", e),
            }),
        )
    })?
    .unwrap_or(false);

    if !vuln_exists {
        return Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Vulnerability not found".to_string(),
            }),
        ));
    }

    // Parse user ID from claims
    let user_id = Uuid::parse_str(&claims.sub).map_err(|e| {
        tracing::error!("Invalid user ID in claims: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Invalid user ID".to_string(),
            }),
        )
    })?;

    // Create remediation task
    let task_id = Uuid::new_v4();
    sqlx::query!(
        r#"
        INSERT INTO remediation_tasks (
            id, device_id, vulnerability_id, task_type, script, status, created_by
        ) VALUES ($1, $2, $3, $4, $5, $6, $7)
        "#,
        task_id,
        device_id,
        request.vulnerability_id,
        request.remediation_type,
        request.script,
        "pending",
        user_id
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to create remediation task: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Database error: {}", e),
            }),
        )
    })?;

    // Log the audit event
    sqlx::query!(
        r#"
        INSERT INTO audit_logs (user_id, action, entity_type, entity_id, old_values, new_values, ip_address)
        VALUES ($1, $2, $3, $4, $5, $6, $7)
        "#,
        user_id,
        "create_remediation_task",
        "remediation_task",
        task_id,
        None as Option<serde_json::Value>,
        serde_json::json!({
            "device_id": device_id,
            "vulnerability_id": request.vulnerability_id,
            "task_type": request.remediation_type
        }),
        None as Option<String>
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::warn!("Failed to create audit log: {}", e);
    })
    .ok();

    // TODO: Spawn async task to execute remediation script
    // For now, just queue it
    tracing::info!(
        "Remediation task {} created for device {} and vulnerability {}",
        task_id,
        device_id,
        request.vulnerability_id
    );

    Ok(Json(RemediationResponse {
        success: true,
        message: format!("Remediation task {} queued for execution", task_id),
        task_id: Some(task_id),
    }))
}

// Alias functions for API routes compatibility
pub use start_network_scan as trigger_scan;
pub use execute_remediation as remediate_device;

// Additional DTOs
#[derive(Debug, Serialize)]
pub struct DeviceDetails {
    pub device: Option<NetworkDevice>,
    pub vulnerabilities: Vec<serde_json::Value>,
    pub remediation_suggestions: Vec<String>,
}

#[derive(Debug, Deserialize)]
pub struct RemediationRequest {
    pub vulnerability_id: Uuid,
    pub remediation_type: String, // auto, manual, script
    pub script: Option<String>,
}

#[derive(Debug, Serialize)]
pub struct RemediationResponse {
    pub success: bool,
    pub message: String,
    pub task_id: Option<Uuid>,
}
