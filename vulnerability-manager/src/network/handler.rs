// src/network/handler.rs
// API handlers for network scanning and topology

use axum::{
    extract::{Path, State},
    http::StatusCode,
    Json,
};
use serde::{Deserialize, Serialize};
use uuid::Uuid;
use ipnetwork::IpNetwork;

use crate::state::AppState;
use crate::auth::Claims;
use super::models::*;
use super::scanner::NetworkScanner;

#[derive(Debug, Serialize)]
pub struct ErrorResponse {
    pub error: String,
}

/// Avvia un nuovo network scan
pub async fn start_network_scan(
    State(app_state): State<AppState>,
    claims: Claims,
    Json(request): Json<StartScanRequest>,
) -> Result<Json<ScanProgress>, (StatusCode, Json<ErrorResponse>)> {
    let network_interface = Some(app_state.config.network.interface.clone());
    let scanner = NetworkScanner::new(network_interface);
    let scan_id = scanner.scan_id;
    let pool = app_state.pool.clone();

    // Parse user_id from claims.sub (String) to Uuid
    let user_id = claims.sub.parse::<Uuid>().map_err(|e| {
        tracing::error!("Failed to parse user_id: {}", e);
        (
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: "Invalid user ID".to_string(),
            }),
        )
    })?;

    // Create scan record in database
    sqlx::query!(
        "INSERT INTO network_scans (id, scan_name, scan_type, target_range, status, devices_found, created_by, created_at)
         VALUES ($1, $2, $3, $4, $5, $6, $7, NOW())",
        scan_id,
        request.scan_name,
        request.scan_type,
        request.target_range,
        "running",
        0,
        user_id
    )
    .execute(&*pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to create scan record: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to create scan record".to_string(),
            }),
        )
    })?;

    // Spawn async task to perform scan
    tokio::spawn(async move {
        let started_at = chrono::Utc::now();

        // Update scan status to started
        let _ = sqlx::query!(
            "UPDATE network_scans SET started_at = $1 WHERE id = $2",
            started_at,
            scan_id
        )
        .execute(&*pool)
        .await;

        // Perform ARP scan
        match scanner.arp_scan(&request.target_range).await {
            Ok(devices) => {
                tracing::info!("Scan completed: {} devices found", devices.len());

                // Discover network links automatically
                let links = scanner.discover_links(&devices).await.unwrap_or_default();
                tracing::info!("Discovered {} network links", links.len());

                // Save devices to database and build ID mapping
                let mut device_id_map = std::collections::HashMap::new();

                for device in &devices {
                    // Parse IP address string to IpNetwork for database storage
                    let ip_network = match device.ip_address.parse::<IpNetwork>() {
                        Ok(ip) => ip,
                        Err(e) => {
                            tracing::error!("Failed to parse IP address {}: {}", device.ip_address, e);
                            continue;
                        }
                    };

                    let result = sqlx::query!(
                        "INSERT INTO network_devices
                         (id, ip_address, mac_address, hostname, device_type, device_status,
                          vendor, os_name, os_version, open_ports, services, first_seen, last_seen, created_at, updated_at)
                         VALUES ($1, $2, $3, $4, $5::device_type, $6::device_status, $7, $8, $9, $10, $11, $12, $13, NOW(), NOW())
                         ON CONFLICT (ip_address)
                         DO UPDATE SET
                            mac_address = COALESCE(EXCLUDED.mac_address, network_devices.mac_address),
                            hostname = COALESCE(EXCLUDED.hostname, network_devices.hostname),
                            device_status = EXCLUDED.device_status,
                            last_seen = EXCLUDED.last_seen,
                            updated_at = NOW()
                         RETURNING id",
                        device.id,
                        ip_network,
                        device.mac_address,
                        device.hostname,
                        format!("{:?}", device.device_type).to_lowercase() as _,
                        format!("{:?}", device.device_status).to_lowercase() as _,
                        device.vendor,
                        device.os_name,
                        device.os_version,
                        device.open_ports.as_ref().map(|ports| ports.as_slice()),
                        device.services.as_ref(),
                        device.first_seen,
                        device.last_seen
                    )
                    .fetch_one(&*pool)
                    .await;

                    match result {
                        Ok(record) => {
                            // Map the original device ID to the actual DB ID
                            device_id_map.insert(device.id, record.id);
                        }
                        Err(e) => {
                            tracing::error!("Failed to save device {}: {}", device.ip_address, e);
                        }
                    }
                }

                // Save network links to database using mapped IDs
                for link in &links {
                    // Translate source and target IDs using the mapping
                    let source_id = device_id_map.get(&link.source_device_id);
                    let target_id = device_id_map.get(&link.target_device_id);

                    // Skip link if either device ID wasn't found in the database
                    if source_id.is_none() || target_id.is_none() {
                        tracing::warn!(
                            "Skipping link {}: source or target device not found in database",
                            link.id
                        );
                        continue;
                    }

                    let result = sqlx::query!(
                        "INSERT INTO network_links
                         (id, source_device_id, target_device_id, link_type, latency_ms, hop_count, created_at)
                         VALUES ($1, $2, $3, $4, $5, $6, $7)
                         ON CONFLICT (source_device_id, target_device_id) DO UPDATE SET
                            link_type = EXCLUDED.link_type,
                            latency_ms = EXCLUDED.latency_ms,
                            hop_count = EXCLUDED.hop_count",
                        link.id,
                        source_id.unwrap(),
                        target_id.unwrap(),
                        link.link_type,
                        link.latency_ms,
                        link.hop_count,
                        link.created_at
                    )
                    .execute(&*pool)
                    .await;

                    if let Err(e) = result {
                        tracing::error!("Failed to save network link {}: {}", link.id, e);
                    }
                }

                // Update scan status to completed
                let _ = sqlx::query!(
                    "UPDATE network_scans SET status = $1, devices_found = $2, completed_at = NOW() WHERE id = $3",
                    "completed",
                    devices.len() as i32,
                    scan_id
                )
                .execute(&*pool)
                .await;

                tracing::info!("Scan {} completed successfully", scan_id);
            }
            Err(e) => {
                tracing::error!("Scan {} failed: {}", scan_id, e);

                // Update scan status to failed
                let _ = sqlx::query!(
                    "UPDATE network_scans SET status = $1, completed_at = NOW() WHERE id = $2",
                    "failed",
                    scan_id
                )
                .execute(&*pool)
                .await;
            }
        }
    });

    Ok(Json(ScanProgress {
        scan_id,
        status: "running".to_string(),
        progress_percent: 0.0,
        devices_found: 0,
        message: Some("Scan started successfully".to_string()),
    }))
}

/// Ottieni lo stato di un scan in corso
pub async fn get_scan_status(
    State(app_state): State<AppState>,
    Path(scan_id): Path<Uuid>,
) -> Result<Json<ScanProgress>, (StatusCode, Json<ErrorResponse>)> {
    let pool = &*app_state.pool;

    let scan = sqlx::query!(
        "SELECT status, devices_found FROM network_scans WHERE id = $1",
        scan_id
    )
    .fetch_optional(pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch scan status: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to fetch scan status".to_string(),
            }),
        )
    })?;

    match scan {
        Some(scan) => {
            let progress_percent = match scan.status.as_str() {
                "completed" => 100.0,
                "failed" => 100.0,
                "running" => 50.0,
                _ => 0.0,
            };

            Ok(Json(ScanProgress {
                scan_id,
                status: scan.status,
                progress_percent,
                devices_found: scan.devices_found.unwrap_or(0),
                message: None,
            }))
        }
        None => Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Scan not found".to_string(),
            }),
        )),
    }
}

/// Ottieni la topologia di rete completa
pub async fn get_network_topology(
    State(app_state): State<AppState>,
) -> Result<Json<NetworkTopology>, (StatusCode, Json<ErrorResponse>)> {
    let pool = &*app_state.pool;

    // Fetch all devices - cast enums to text for sqlx compatibility
    let devices_rows = sqlx::query!(
        "SELECT id, ip_address, mac_address, hostname,
                device_type::text as device_type,
                device_status::text as device_status,
                vendor, os_name, os_version, open_ports, services, first_seen, last_seen,
                created_at, updated_at
         FROM network_devices
         ORDER BY last_seen DESC"
    )
    .fetch_all(pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch devices: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to fetch network devices".to_string(),
            }),
        )
    })?;

    let devices: Vec<NetworkDevice> = devices_rows
        .into_iter()
        .map(|row| {
            let device_type = match row.device_type.as_deref().unwrap_or("unknown") {
                "router" => DeviceType::Router,
                "switch" => DeviceType::Switch,
                "firewall" => DeviceType::Firewall,
                "server" => DeviceType::Server,
                "workstation" => DeviceType::Workstation,
                "iot" => DeviceType::IoT,
                "printer" => DeviceType::Printer,
                _ => DeviceType::Unknown,
            };

            let device_status = match row.device_status.as_deref().unwrap_or("unknown") {
                "online" => DeviceStatus::Online,
                "offline" => DeviceStatus::Offline,
                _ => DeviceStatus::Unknown,
            };

            NetworkDevice {
                id: row.id,
                ip_address: row.ip_address.to_string(),
                mac_address: row.mac_address,
                hostname: row.hostname,
                device_type,
                device_status,
                vendor: row.vendor,
                os_name: row.os_name,
                os_version: row.os_version,
                open_ports: row.open_ports.map(|arr| arr.into_iter().map(|p| p as i32).collect()),
                services: row.services,
                first_seen: row.first_seen,
                last_seen: row.last_seen,
                created_at: row.created_at,
                updated_at: row.updated_at,
            }
        })
        .collect();

    // Fetch all links
    let links_rows = sqlx::query!(
        "SELECT id, source_device_id, target_device_id, link_type, latency_ms, hop_count, created_at
         FROM network_links"
    )
    .fetch_all(pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch links: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to fetch network links".to_string(),
            }),
        )
    })?;

    let links: Vec<NetworkLink> = links_rows
        .into_iter()
        .map(|row| NetworkLink {
            id: row.id,
            source_device_id: row.source_device_id,
            target_device_id: row.target_device_id,
            link_type: row.link_type,
            latency_ms: row.latency_ms,
            hop_count: row.hop_count,
            created_at: row.created_at,
        })
        .collect();

    // Fetch latest scan info
    let latest_scan = sqlx::query!(
        "SELECT id, scan_name, scan_type, target_range, status, devices_found,
                started_at, completed_at, created_by, created_at
         FROM network_scans
         ORDER BY created_at DESC
         LIMIT 1"
    )
    .fetch_optional(pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch latest scan: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to fetch latest scan info".to_string(),
            }),
        )
    })?;

    let scan_info = latest_scan.map(|row| NetworkScan {
        id: row.id,
        scan_name: row.scan_name,
        scan_type: row.scan_type,
        target_range: row.target_range,
        status: row.status,
        devices_found: Some(row.devices_found.unwrap_or(0)),
        started_at: row.started_at,
        completed_at: row.completed_at,
        created_by: row.created_by,
        created_at: row.created_at,
    });

    let topology = NetworkTopology {
        devices,
        links,
        scan_info,
    };

    Ok(Json(topology))
}

/// Ottieni dettagli di un device specifico con vulnerabilit√† associate
pub async fn get_device_details(
    State(_app_state): State<AppState>,
    Path(_device_id): Path<Uuid>,
) -> Result<Json<DeviceDetails>, (StatusCode, Json<ErrorResponse>)> {
    // TODO: Query database for device and related vulnerabilities

    let details = DeviceDetails {
        device: None,
        vulnerabilities: Vec::new(),
        remediation_suggestions: Vec::new(),
    };

    Ok(Json(details))
}

/// Esegui remediation su un device
pub async fn execute_remediation(
    State(_app_state): State<AppState>,
    _claims: Claims,
    Path(_device_id): Path<Uuid>,
    Json(_request): Json<RemediationRequest>,
) -> Result<Json<RemediationResponse>, (StatusCode, Json<ErrorResponse>)> {
    // TODO: Implement remediation logic

    Ok(Json(RemediationResponse {
        success: true,
        message: "Remediation queued for execution".to_string(),
        task_id: Some(Uuid::new_v4()),
    }))
}

/// Get network topology with vulnerability data (Priority 1)
pub async fn get_topology_with_vulnerabilities(
    State(app_state): State<AppState>,
) -> Result<Json<super::models::NetworkTopologyWithVulnerabilities>, (StatusCode, Json<ErrorResponse>)> {
    use super::models::{NetworkDeviceWithVulnerabilities, VulnerabilitySummary};
    

    let pool = &*app_state.pool;

    // Fetch all devices with assignment data
    let devices_data = sqlx::query!(
        r#"
        SELECT
            id, ip_address, mac_address, hostname,
            device_type as "device_type: DeviceType",
            device_status as "device_status: DeviceStatus",
            vendor, os_name, os_version, open_ports, services,
            first_seen, last_seen, created_at, updated_at,
            assigned_user_id, assigned_team_id, owner, location,
            criticality, tags, notes, is_internet_facing, has_public_ip
        FROM network_devices
        ORDER BY last_seen DESC
        "#
    )
    .fetch_all(pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch devices: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to fetch devices".to_string(),
            }),
        )
    })?;

    let mut devices = Vec::new();

    for device_row in devices_data {
        // Get vulnerability summary for this device
        let vuln_summary = sqlx::query!(
            r#"
            SELECT
                COUNT(*) as total,
                COUNT(*) FILTER (WHERE v.severity = 'critical') as critical,
                COUNT(*) FILTER (WHERE v.severity = 'high') as high,
                COUNT(*) FILTER (WHERE v.severity = 'medium') as medium,
                COUNT(*) FILTER (WHERE v.severity = 'low') as low,
                COUNT(*) FILTER (WHERE v.severity = 'info') as info,
                AVG(v.epss_score) as epss_avg,
                MAX(v.epss_score) as epss_max,
                AVG(v.cvss_score) as cvss_avg,
                MAX(v.cvss_score) as cvss_max,
                SUM(v.risk_score) as risk_score_sum,
                MAX(v.risk_score) as risk_score_max,
                AVG(v.risk_score) as risk_score_avg
            FROM device_vulnerabilities dv
            JOIN vulnerabilities v ON v.id = dv.vulnerability_id
            WHERE dv.device_id = $1
            AND v.status != 'resolved'
            "#,
            device_row.id
        )
        .fetch_one(pool)
        .await
        .map_err(|e| {
            tracing::error!("Failed to fetch vulnerability summary: {}", e);
            (
                StatusCode::INTERNAL_SERVER_ERROR,
                Json(ErrorResponse {
                    error: "Failed to fetch vulnerability summary".to_string(),
                }),
            )
        })?;

        let vulnerabilities = VulnerabilitySummary {
            total: vuln_summary.total.unwrap_or(0),
            critical: vuln_summary.critical.unwrap_or(0),
            high: vuln_summary.high.unwrap_or(0),
            medium: vuln_summary.medium.unwrap_or(0),
            low: vuln_summary.low.unwrap_or(0),
            info: vuln_summary.info.unwrap_or(0),
            epss_average: vuln_summary.epss_avg.map(|v| v as f64),
            epss_max: vuln_summary.epss_max.map(|v| v as f64),
            cvss_average: vuln_summary.cvss_avg.map(|v| v as f64),
            cvss_max: vuln_summary.cvss_max.map(|v| v as f64),
            risk_score_sum: vuln_summary.risk_score_sum,
            risk_score_max: vuln_summary.risk_score_max,
            risk_score_avg: vuln_summary.risk_score_avg.and_then(|v| v.to_string().parse::<f64>().ok()),
        };

        devices.push(NetworkDeviceWithVulnerabilities {
            id: device_row.id,
            ip_address: device_row.ip_address.to_string(),
            mac_address: device_row.mac_address,
            hostname: device_row.hostname,
            device_type: device_row.device_type,
            device_status: device_row.device_status,
            vendor: device_row.vendor,
            os_name: device_row.os_name,
            os_version: device_row.os_version,
            open_ports: device_row.open_ports,
            services: device_row.services,
            first_seen: device_row.first_seen,
            last_seen: device_row.last_seen,
            created_at: device_row.created_at,
            updated_at: device_row.updated_at,
            assigned_user_id: device_row.assigned_user_id,
            assigned_team_id: device_row.assigned_team_id,
            owner: device_row.owner,
            location: device_row.location,
            criticality: device_row.criticality,
            tags: device_row.tags,
            notes: device_row.notes,
            is_internet_facing: device_row.is_internet_facing,
            has_public_ip: device_row.has_public_ip,
            vulnerabilities,
        });
    }

    // Also fetch all assets (vulnerability management assets) and add them to the topology
    let assets_data = sqlx::query!(
        r#"
        SELECT
            id, name, asset_type::TEXT as asset_type, ip_address, hostname, mac_address,
            operating_system, owner, location,
            tags as "tags!: Vec<String>",
            criticality,
            created_at, updated_at
        FROM assets
        WHERE deleted_at IS NULL
        ORDER BY name
        "#
    )
    .fetch_all(pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch assets: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to fetch assets".to_string(),
            }),
        )
    })?;

    for asset_row in assets_data {
        // Get vulnerability summary for this asset
        let vuln_summary = sqlx::query!(
            r#"
            SELECT
                COUNT(*) as total,
                COUNT(*) FILTER (WHERE severity = 'critical') as critical,
                COUNT(*) FILTER (WHERE severity = 'high') as high,
                COUNT(*) FILTER (WHERE severity = 'medium') as medium,
                COUNT(*) FILTER (WHERE severity = 'low') as low,
                COUNT(*) FILTER (WHERE severity = 'info') as info,
                AVG(epss_score) as epss_avg,
                MAX(epss_score) as epss_max,
                AVG(cvss_score) as cvss_avg,
                MAX(cvss_score) as cvss_max,
                SUM(risk_score) as risk_score_sum,
                MAX(risk_score) as risk_score_max,
                AVG(risk_score) as risk_score_avg
            FROM vulnerabilities
            WHERE asset_id = $1
            AND status != 'resolved'
            "#,
            asset_row.id
        )
        .fetch_one(pool)
        .await
        .map_err(|e| {
            tracing::error!("Failed to fetch asset vulnerability summary: {}", e);
            (
                StatusCode::INTERNAL_SERVER_ERROR,
                Json(ErrorResponse {
                    error: "Failed to fetch asset vulnerability summary".to_string(),
                }),
            )
        })?;

        let vulnerabilities = VulnerabilitySummary {
            total: vuln_summary.total.unwrap_or(0),
            critical: vuln_summary.critical.unwrap_or(0),
            high: vuln_summary.high.unwrap_or(0),
            medium: vuln_summary.medium.unwrap_or(0),
            low: vuln_summary.low.unwrap_or(0),
            info: vuln_summary.info.unwrap_or(0),
            epss_average: vuln_summary.epss_avg.map(|v| v as f64),
            epss_max: vuln_summary.epss_max.map(|v| v as f64),
            cvss_average: vuln_summary.cvss_avg.map(|v| v as f64),
            cvss_max: vuln_summary.cvss_max.map(|v| v as f64),
            risk_score_sum: vuln_summary.risk_score_sum,
            risk_score_max: vuln_summary.risk_score_max,
            risk_score_avg: vuln_summary.risk_score_avg.and_then(|v| v.to_string().parse::<f64>().ok()),
        };

        // Map asset to NetworkDeviceWithVulnerabilities format
        // Use asset_type to determine device_type
        let device_type = match asset_row.asset_type.as_deref() {
            Some("server") => DeviceType::Server,
            Some("workstation") => DeviceType::Workstation,
            Some("network_device") => DeviceType::Router,
            Some("iot") => DeviceType::IoT,
            Some("printer") => DeviceType::Printer,
            _ => DeviceType::Unknown,
        };

        devices.push(NetworkDeviceWithVulnerabilities {
            id: asset_row.id,
            ip_address: asset_row.ip_address.map(|ip| ip.to_string()).unwrap_or_else(|| "N/A".to_string()),
            mac_address: asset_row.mac_address,
            hostname: asset_row.hostname.or(Some(asset_row.name.clone())),
            device_type,
            device_status: DeviceStatus::Unknown, // Assets don't have live status
            vendor: None,
            os_name: asset_row.operating_system,
            os_version: None,
            open_ports: None,
            services: None,
            first_seen: asset_row.created_at,
            last_seen: asset_row.updated_at,
            created_at: asset_row.created_at,
            updated_at: asset_row.updated_at,
            assigned_user_id: None, // Assets don't have direct user assignment
            assigned_team_id: None, // Assets don't have direct team assignment
            owner: Some(asset_row.owner.unwrap_or_else(|| "Unknown".to_string())),
            location: asset_row.location,
            criticality: asset_row.criticality,
            tags: Some(asset_row.tags),
            notes: None,
            is_internet_facing: None,
            has_public_ip: None,
            vulnerabilities,
        });
    }

    // Fetch links
    let links_data = sqlx::query_as!(
        super::models::NetworkLink,
        "SELECT id, source_device_id, target_device_id, link_type, latency_ms, hop_count, created_at
         FROM network_links"
    )
    .fetch_all(pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch links: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to fetch links".to_string(),
            }),
        )
    })?;

    // Get latest scan info
    let scan_info = sqlx::query_as!(
        NetworkScan,
        "SELECT id, scan_name, scan_type, target_range, status, devices_found,
                started_at, completed_at, created_by, created_at
         FROM network_scans
         ORDER BY created_at DESC
         LIMIT 1"
    )
    .fetch_optional(pool)
    .await
    .ok()
    .flatten();

    Ok(Json(super::models::NetworkTopologyWithVulnerabilities {
        devices,
        links: links_data,
        scan_info,
    }))
}

/// Update device information (Priority 2)
pub async fn update_device(
    State(app_state): State<AppState>,
    _claims: Claims,
    Path(device_id): Path<Uuid>,
    Json(update_data): Json<super::models::UpdateDeviceRequest>,
) -> Result<Json<NetworkDevice>, (StatusCode, Json<ErrorResponse>)> {
    

    let pool = &*app_state.pool;

    // Build UPDATE query dynamically based on provided fields
    let device = sqlx::query!(
        r#"
        UPDATE network_devices
        SET
            hostname = COALESCE($2, hostname),
            device_type = COALESCE($3::device_type, device_type),
            vendor = COALESCE($4, vendor),
            os_name = COALESCE($5, os_name),
            os_version = COALESCE($6, os_version),
            owner = COALESCE($7, owner),
            location = COALESCE($8, location),
            criticality = COALESCE($9, criticality),
            tags = COALESCE($10, tags),
            notes = COALESCE($11, notes),
            is_internet_facing = COALESCE($12, is_internet_facing),
            has_public_ip = COALESCE($13, has_public_ip),
            assigned_user_id = COALESCE($14, assigned_user_id),
            assigned_team_id = COALESCE($15, assigned_team_id),
            updated_at = NOW()
        WHERE id = $1
        RETURNING
            id, ip_address, mac_address, hostname,
            device_type as "device_type: DeviceType",
            device_status as "device_status: DeviceStatus",
            vendor, os_name, os_version, open_ports, services,
            first_seen, last_seen, created_at, updated_at
        "#,
        device_id,
        update_data.hostname,
        update_data.device_type.map(|dt| format!("{:?}", dt).to_lowercase()) as _,
        update_data.vendor,
        update_data.os_name,
        update_data.os_version,
        update_data.owner,
        update_data.location,
        update_data.criticality,
        update_data.tags.as_deref(),
        update_data.notes,
        update_data.is_internet_facing,
        update_data.has_public_ip,
        update_data.assigned_user_id,
        update_data.assigned_team_id,
    )
    .fetch_optional(pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to update device: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Failed to update device: {}", e),
            }),
        )
    })?
    .ok_or_else(|| {
        (
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Device not found".to_string(),
            }),
        )
    })?;

    Ok(Json(NetworkDevice {
        id: device.id,
        ip_address: device.ip_address.to_string(),
        mac_address: device.mac_address,
        hostname: device.hostname,
        device_type: device.device_type,
        device_status: device.device_status,
        vendor: device.vendor,
        os_name: device.os_name,
        os_version: device.os_version,
        open_ports: device.open_ports,
        services: device.services,
        first_seen: device.first_seen,
        last_seen: device.last_seen,
        created_at: device.created_at,
        updated_at: device.updated_at,
    }))
}

/// Bulk assign devices to user/team (Priority 3)
pub async fn bulk_assign_devices(
    State(app_state): State<AppState>,
    _claims: Claims,
    Json(assign_data): Json<super::models::BulkAssignRequest>,
) -> Result<Json<serde_json::Value>, (StatusCode, Json<ErrorResponse>)> {
    let pool = &*app_state.pool;

    let updated_count = sqlx::query!(
        "UPDATE network_devices
         SET
            assigned_user_id = COALESCE($1, assigned_user_id),
            assigned_team_id = COALESCE($2, assigned_team_id),
            updated_at = NOW()
         WHERE id = ANY($3)",
        assign_data.user_id,
        assign_data.team_id,
        &assign_data.device_ids
    )
    .execute(pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to bulk assign devices: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Failed to bulk assign devices: {}", e),
            }),
        )
    })?
    .rows_affected();

    Ok(Json(serde_json::json!({
        "success": true,
        "updated_count": updated_count,
        "message": format!("Successfully assigned {} devices", updated_count)
    })))
}

/// Get vulnerabilities for specific device (Priority 1)
pub async fn get_device_vulnerabilities(
    State(app_state): State<AppState>,
    Path(device_id): Path<Uuid>,
) -> Result<Json<serde_json::Value>, (StatusCode, Json<ErrorResponse>)> {
    let pool = &*app_state.pool;

    // Get device info
    let device = sqlx::query!(
        r#"
        SELECT id, ip_address, hostname,
               device_type as "device_type: DeviceType"
        FROM network_devices
        WHERE id = $1
        "#,
        device_id
    )
    .fetch_optional(pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch device: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to fetch device".to_string(),
            }),
        )
    })?
    .ok_or_else(|| {
        (
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Device not found".to_string(),
            }),
        )
    })?;

    // Get all vulnerabilities for this device
    let vulnerabilities = sqlx::query!(
        r#"
        SELECT
            v.id, v.title, v.description, v.cvss_score, v.epss_score,
            v.severity as "severity: crate::models::vulnerability::VulnerabilitySeverity",
            v.status as "status: crate::models::vulnerability::VulnerabilityStatus",
            v.cve_id, v.cwe_id, v.remediation, v.discovered_at,
            v.assigned_user_id, v.assigned_team_id
        FROM device_vulnerabilities dv
        JOIN vulnerabilities v ON v.id = dv.vulnerability_id
        WHERE dv.device_id = $1
        ORDER BY v.cvss_score DESC, v.epss_score DESC
        "#,
        device_id
    )
    .fetch_all(pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch vulnerabilities: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to fetch vulnerabilities".to_string(),
            }),
        )
    })?;

    Ok(Json(serde_json::json!({
        "device": {
            "id": device.id,
            "ip_address": device.ip_address.to_string(),
            "hostname": device.hostname,
            "device_type": format!("{:?}", device.device_type),
        },
        "vulnerabilities": vulnerabilities.iter().map(|v| {
            serde_json::json!({
                "id": v.id,
                "title": v.title,
                "description": v.description,
                "cvss_score": v.cvss_score,
                "epss_score": v.epss_score,
                "severity": format!("{:?}", v.severity),
                "status": format!("{:?}", v.status),
                "cve_id": v.cve_id,
                "cwe_id": v.cwe_id,
                "remediation": v.remediation,
                "discovered_at": v.discovered_at,
                "assigned_user_id": v.assigned_user_id,
                "assigned_team_id": v.assigned_team_id,
            })
        }).collect::<Vec<_>>(),
        "summary": {
            "total": vulnerabilities.len(),
            "critical": vulnerabilities.iter().filter(|v| format!("{:?}", v.severity) == "Critical").count(),
            "high": vulnerabilities.iter().filter(|v| format!("{:?}", v.severity) == "High").count(),
            "medium": vulnerabilities.iter().filter(|v| format!("{:?}", v.severity) == "Medium").count(),
            "low": vulnerabilities.iter().filter(|v| format!("{:?}", v.severity) == "Low").count(),
        }
    })))
}

// Additional DTOs
#[derive(Debug, Serialize)]
pub struct DeviceDetails {
    pub device: Option<NetworkDevice>,
    pub vulnerabilities: Vec<serde_json::Value>,
    pub remediation_suggestions: Vec<String>,
}

#[derive(Debug, Deserialize)]
pub struct RemediationRequest {
    pub vulnerability_id: Uuid,
    pub remediation_type: String, // auto, manual, script
    pub script: Option<String>,
}

#[derive(Debug, Serialize)]
pub struct RemediationResponse {
    pub success: bool,
    pub message: String,
    pub task_id: Option<Uuid>,
}

/// Get devices with incomplete RBRE data
#[derive(Debug, Serialize)]
pub struct IncompleteDeviceInfo {
    pub id: Uuid,
    pub ip_address: String,
    pub hostname: Option<String>,
    pub missing_fields: Vec<String>,
}

pub async fn get_incomplete_devices(
    State(app_state): State<AppState>,
    _claims: Claims,
) -> Result<Json<Vec<IncompleteDeviceInfo>>, (StatusCode, Json<ErrorResponse>)> {
    let devices = sqlx::query!(
        r#"
        SELECT
            id,
            ip_address,
            hostname,
            business_criticality::TEXT as business_criticality,
            exposure_level::TEXT as exposure_level
        FROM network_devices
        WHERE
            business_criticality IS NULL
            OR business_criticality::TEXT = 'supporto'
            OR exposure_level IS NULL
            OR exposure_level::TEXT = 'internal'
        ORDER BY hostname, ip_address
        "#
    )
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch incomplete devices: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Failed to fetch incomplete devices: {}", e),
            }),
        )
    })?;

    let mut incomplete_devices = Vec::new();

    for device in devices {
        let mut missing_fields = Vec::new();

        if device.business_criticality.is_none()
            || device.business_criticality.as_deref() == Some("supporto") {
            missing_fields.push("Business Criticality".to_string());
        }

        if device.exposure_level.is_none()
            || device.exposure_level.as_deref() == Some("internal") {
            missing_fields.push("Exposure Level".to_string());
        }

        if !missing_fields.is_empty() {
            incomplete_devices.push(IncompleteDeviceInfo {
                id: device.id,
                ip_address: device.ip_address.to_string(),
                hostname: device.hostname,
                missing_fields,
            });
        }
    }

    Ok(Json(incomplete_devices))
}

// Network Ranges Management

#[derive(Debug, Serialize, Deserialize)]
pub struct NetworkRange {
    pub id: Uuid,
    pub network_range: Option<String>,  // CIDR format as text
    pub description: Option<String>,
    pub is_local_network: Option<bool>,
    pub enabled: Option<bool>,
    pub last_scan_at: Option<chrono::DateTime<chrono::Utc>>,
    pub last_ping_scan_at: Option<chrono::DateTime<chrono::Utc>>,
    pub last_deep_scan_at: Option<chrono::DateTime<chrono::Utc>>,
    pub hosts_found: Option<i32>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}

#[derive(Debug, Deserialize)]
pub struct CreateNetworkRangeRequest {
    pub network_range: String,
    pub description: Option<String>,
    pub is_local_network: Option<bool>,
    pub enabled: Option<bool>,
}

#[derive(Debug, Deserialize)]
pub struct UpdateNetworkRangeRequest {
    pub description: Option<String>,
    pub enabled: Option<bool>,
}

/// List all configured network ranges
pub async fn list_network_ranges(
    State(app_state): State<AppState>,
) -> Result<Json<Vec<NetworkRange>>, (StatusCode, Json<ErrorResponse>)> {
    let ranges = sqlx::query_as!(
        NetworkRange,
        "SELECT id, network_range::text as network_range, description, is_local_network, enabled,
                last_scan_at, last_ping_scan_at, last_deep_scan_at, hosts_found,
                created_at, updated_at
         FROM network_ranges
         ORDER BY is_local_network DESC, created_at DESC"
    )
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch network ranges: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to fetch network ranges".to_string(),
            }),
        )
    })?;

    Ok(Json(ranges))
}

/// Create a new network range
pub async fn create_network_range(
    State(app_state): State<AppState>,
    Json(request): Json<CreateNetworkRangeRequest>,
) -> Result<Json<NetworkRange>, (StatusCode, Json<ErrorResponse>)> {
    // Validate CIDR format by parsing
    let parsed_cidr: IpNetwork = request.network_range.parse().map_err(|_| {
        (
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: "Invalid CIDR format. Use format like 192.168.1.0/24".to_string(),
            }),
        )
    })?;

    let row = sqlx::query!(
        "INSERT INTO network_ranges (network_range, description, is_local_network, enabled)
         VALUES ($1, $2, $3, $4)
         RETURNING id, network_range::text as \"network_range!\", description, is_local_network, enabled,
                   last_scan_at, last_ping_scan_at, last_deep_scan_at, hosts_found,
                   created_at, updated_at",
        parsed_cidr,
        request.description,
        request.is_local_network.unwrap_or(false),
        request.enabled.unwrap_or(true)
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to create network range: {}", e);

        if e.to_string().contains("duplicate key") {
            (
                StatusCode::CONFLICT,
                Json(ErrorResponse {
                    error: "Network range already exists".to_string(),
                }),
            )
        } else {
            (
                StatusCode::INTERNAL_SERVER_ERROR,
                Json(ErrorResponse {
                    error: "Failed to create network range".to_string(),
                }),
            )
        }
    })?;

    let range = NetworkRange {
        id: row.id,
        network_range: Some(row.network_range),
        description: row.description,
        is_local_network: row.is_local_network,
        enabled: row.enabled,
        last_scan_at: row.last_scan_at,
        last_ping_scan_at: row.last_ping_scan_at,
        last_deep_scan_at: row.last_deep_scan_at,
        hosts_found: row.hosts_found,
        created_at: Some(row.created_at),
        updated_at: Some(row.updated_at),
    };

    Ok(Json(range))
}

/// Update a network range
pub async fn update_network_range(
    State(app_state): State<AppState>,
    Path(range_id): Path<Uuid>,
    Json(request): Json<UpdateNetworkRangeRequest>,
) -> Result<Json<NetworkRange>, (StatusCode, Json<ErrorResponse>)> {
    let row = sqlx::query!(
        "UPDATE network_ranges
         SET description = COALESCE($2, description),
             enabled = COALESCE($3, enabled)
         WHERE id = $1
         RETURNING id, network_range::text as \"network_range!\", description, is_local_network, enabled,
                   last_scan_at, last_ping_scan_at, last_deep_scan_at, hosts_found,
                   created_at, updated_at",
        range_id,
        request.description,
        request.enabled
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to update network range: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to update network range".to_string(),
            }),
        )
    })?;

    match row {
        Some(row) => {
            let range = NetworkRange {
                id: row.id,
                network_range: Some(row.network_range),
                description: row.description,
                is_local_network: row.is_local_network,
                enabled: row.enabled,
                last_scan_at: row.last_scan_at,
                last_ping_scan_at: row.last_ping_scan_at,
                last_deep_scan_at: row.last_deep_scan_at,
                hosts_found: row.hosts_found,
                created_at: Some(row.created_at),
                updated_at: Some(row.updated_at),
            };
            Ok(Json(range))
        },
        None => Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Network range not found".to_string(),
            }),
        )),
    }
}

/// Delete a network range
pub async fn delete_network_range(
    State(app_state): State<AppState>,
    Path(range_id): Path<Uuid>,
) -> Result<StatusCode, (StatusCode, Json<ErrorResponse>)> {
    let result = sqlx::query!("DELETE FROM network_ranges WHERE id = $1", range_id)
        .execute(&*app_state.pool)
        .await
        .map_err(|e| {
            tracing::error!("Failed to delete network range: {}", e);
            (
                StatusCode::INTERNAL_SERVER_ERROR,
                Json(ErrorResponse {
                    error: "Failed to delete network range".to_string(),
                }),
            )
        })?;

    if result.rows_affected() == 0 {
        Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Network range not found".to_string(),
            }),
        ))
    } else {
        Ok(StatusCode::NO_CONTENT)
    }
}

// Network Discovery Scanning

#[derive(Debug, Serialize)]
pub struct DiscoveryScanResponse {
    pub scan_id: Uuid,
    pub status: String,
    pub network_range: String,
    pub message: String,
}

/// Trigger discovery scan for a specific network range
pub async fn trigger_discovery_scan(
    State(app_state): State<AppState>,
    claims: Claims,
    Path(range_id): Path<Uuid>,
) -> Result<Json<DiscoveryScanResponse>, (StatusCode, Json<ErrorResponse>)> {
    let pool = app_state.pool.clone();

    // Fetch network range
    let range = sqlx::query!("SELECT network_range::text as network_range, enabled FROM network_ranges WHERE id = $1", range_id)
        .fetch_optional(&*pool)
        .await
        .map_err(|e| {
            tracing::error!("Failed to fetch network range: {}", e);
            (
                StatusCode::INTERNAL_SERVER_ERROR,
                Json(ErrorResponse { error: "Failed to fetch network range".to_string() }),
            )
        })?;

    let range = range.ok_or_else(|| {
        (
            StatusCode::NOT_FOUND,
            Json(ErrorResponse { error: "Network range not found".to_string() }),
        )
    })?;

    if !range.enabled.unwrap_or(false) {
        return Err((
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse { error: "Network range is disabled".to_string() }),
        ));
    }

    let network_range = range.network_range.unwrap();
    let network_range_clone = network_range.clone(); // Clone for later use
    let network_interface = Some(app_state.config.network.interface.clone());
    let scanner = NetworkScanner::new(network_interface);
    let scan_id = scanner.scan_id;

    // Update network_ranges with scan start
    let _ = sqlx::query!(
        "UPDATE network_ranges SET last_ping_scan_at = NOW(), last_scan_at = NOW() WHERE id = $1",
        range_id
    )
    .execute(&*pool)
    .await;

    // Spawn async task for discovery scan
    tokio::spawn(async move {
        tracing::info!("Starting discovery scan for range: {}", network_range_clone);

        match scanner.nmap_ping_scan(&network_range_clone).await {
            Ok(devices) => {
                tracing::info!("Discovery scan completed: {} hosts found", devices.len());

                // Update hosts_found count
                let _ = sqlx::query!(
                    "UPDATE network_ranges SET hosts_found = $1 WHERE id = $2",
                    devices.len() as i32,
                    range_id
                )
                .execute(&*pool)
                .await;

                // Save/update devices with smart deduplication (IP | hostname | MAC)
                for device in &devices {
                    let ip_network: IpNetwork = match device.ip_address.parse() {
                        Ok(ip) => ip,
                        Err(e) => {
                            tracing::error!("Failed to parse IP: {}: {}", device.ip_address, e);
                            continue;
                        }
                    };

                    // Smart deduplication: try IP, then MAC, then hostname
                    let mut existing_device: Option<(uuid::Uuid, String)> = None;

                    // 1. Try matching by IP address (primary)
                    if let Ok(Some(row)) = sqlx::query!(
                        "SELECT id, COALESCE(hostname, ip_address::text) as identifier FROM network_devices WHERE ip_address = $1",
                        ip_network
                    ).fetch_optional(&*pool).await {
                        existing_device = Some((row.id, row.identifier.unwrap_or_else(|| device.ip_address.clone())));
                        tracing::debug!("Matched device by IP: {}", device.ip_address);
                    }

                    // 2. If not found by IP, try MAC address
                    if existing_device.is_none() && device.mac_address.is_some() {
                        if let Ok(Some(row)) = sqlx::query!(
                            "SELECT id, COALESCE(hostname, ip_address::text) as identifier
                             FROM network_devices
                             WHERE mac_address = $1 AND mac_address IS NOT NULL",
                            device.mac_address
                        ).fetch_optional(&*pool).await {
                            existing_device = Some((row.id, row.identifier.unwrap_or_else(|| device.ip_address.clone())));
                            tracing::info!(
                                "Matched device by MAC {}, IP changed to {}",
                                device.mac_address.as_ref().unwrap(),
                                device.ip_address
                            );
                        }
                    }

                    // 3. If not found by IP/MAC, try hostname
                    if existing_device.is_none() && device.hostname.is_some() {
                        if let Ok(Some(row)) = sqlx::query!(
                            "SELECT id, COALESCE(hostname, ip_address::text) as identifier
                             FROM network_devices
                             WHERE hostname = $1 AND hostname IS NOT NULL",
                            device.hostname
                        ).fetch_optional(&*pool).await {
                            existing_device = Some((row.id, row.identifier.unwrap_or_else(|| device.ip_address.clone())));
                            tracing::info!(
                                "Matched device by hostname {}, IP changed to {}",
                                device.hostname.as_ref().unwrap(),
                                device.ip_address
                            );
                        }
                    }

                    if let Some((device_id, identifier)) = existing_device {
                        // Device exists - UPDATE
                        let _ = sqlx::query!(
                            "UPDATE network_devices
                             SET ip_address = $1,
                                 mac_address = COALESCE($2, mac_address),
                                 hostname = COALESCE($3, hostname),
                                 vendor = COALESCE($4, vendor),
                                 last_seen = NOW(),
                                 device_status = 'online'::device_status,
                                 updated_at = NOW()
                             WHERE id = $5",
                            ip_network,
                            device.mac_address,
                            device.hostname,
                            device.vendor,
                            device_id
                        )
                        .execute(&*pool)
                        .await;

                        tracing::info!("Updated device '{}' ({})", identifier, device.ip_address);
                    } else {
                        // New device - INSERT
                        let device_type_str = format!("{:?}", device.device_type).to_lowercase();
                        let _ = sqlx::query!(
                            "INSERT INTO network_devices (ip_address, mac_address, hostname, device_type, device_status, vendor, first_seen, last_seen)
                             VALUES ($1, $2, $3, $4::text::device_type, 'online'::device_status, $5, NOW(), NOW())",
                            ip_network,
                            device.mac_address,
                            device.hostname,
                            device_type_str,
                            device.vendor
                        )
                        .execute(&*pool)
                        .await;

                        tracing::info!("Created new device: {}", device.ip_address);
                    }
                }

                tracing::info!("Discovery scan data saved to database");
            }
            Err(e) => {
                tracing::error!("Discovery scan failed: {}", e);
            }
        }
    });

    Ok(Json(DiscoveryScanResponse {
        scan_id,
        status: "running".to_string(),
        network_range,
        message: "Discovery scan started successfully".to_string(),
    }))
}

/// Trigger deep scan for a specific host
pub async fn trigger_deep_scan(
    State(app_state): State<AppState>,
    Path(device_id): Path<Uuid>,
) -> Result<Json<DiscoveryScanResponse>, (StatusCode, Json<ErrorResponse>)> {
    let pool = app_state.pool.clone();

    // Fetch device IP
    let device = sqlx::query!(
        "SELECT ip_address::text as ip_address FROM network_devices WHERE id = $1",
        device_id
    )
    .fetch_optional(&*pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch device: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse { error: "Failed to fetch device".to_string() }),
        )
    })?;

    let device = device.ok_or_else(|| {
        (
            StatusCode::NOT_FOUND,
            Json(ErrorResponse { error: "Device not found".to_string() }),
        )
    })?;

    let ip_address = device.ip_address.unwrap();
    let ip_address_clone = ip_address.clone(); // Clone for later use
    let network_interface = Some(app_state.config.network.interface.clone());
    let scanner = NetworkScanner::new(network_interface);
    let scan_id = scanner.scan_id;

    // Spawn async task for deep scan
    tokio::spawn(async move {
        tracing::info!("Starting deep scan for IP: {}", ip_address_clone);

        match scanner.nmap_scan(&ip_address_clone, true).await {
            Ok(scanned_device) => {
                tracing::info!("Deep scan completed for {}", ip_address_clone);

                // Update device in database with detailed info
                let ip_network: IpNetwork = match scanned_device.ip_address.parse() {
                    Ok(ip) => ip,
                    Err(e) => {
                        tracing::error!("Failed to parse IP: {}", e);
                        return;
                    }
                };

                let device_type_str = format!("{:?}", scanned_device.device_type).to_lowercase();
                let _ = sqlx::query!(
                    "UPDATE network_devices
                     SET mac_address = COALESCE($2, mac_address),
                         hostname = COALESCE($3, hostname),
                         device_type = $4::text::device_type,
                         vendor = COALESCE($5, vendor),
                         os_name = $6,
                         os_version = $7,
                         open_ports = $8,
                         services = $9,
                         last_seen = NOW(),
                         device_status = 'online'::device_status,
                         updated_at = NOW()
                     WHERE ip_address = $1",
                    ip_network,
                    scanned_device.mac_address,
                    scanned_device.hostname,
                    device_type_str,
                    scanned_device.vendor,
                    scanned_device.os_name,
                    scanned_device.os_version,
                    scanned_device.open_ports.as_deref(),
                    scanned_device.services
                )
                .execute(&*pool)
                .await;

                tracing::info!("Deep scan data saved for {}", ip_address_clone);
            }
            Err(e) => {
                tracing::error!("Deep scan failed for {}: {}", ip_address_clone, e);
            }
        }
    });

    Ok(Json(DiscoveryScanResponse {
        scan_id,
        status: "running".to_string(),
        network_range: ip_address.clone(),
        message: format!("Deep scan started for {}", ip_address),
    }))
}

/// Trigger deep scan for all hosts in a network range
pub async fn trigger_range_deep_scan(
    State(app_state): State<AppState>,
    Path(range_id): Path<Uuid>,
) -> Result<Json<DiscoveryScanResponse>, (StatusCode, Json<ErrorResponse>)> {
    let pool = app_state.pool.clone();

    // Fetch network range
    let range = sqlx::query!("SELECT network_range::text as network_range FROM network_ranges WHERE id = $1", range_id)
        .fetch_optional(&*pool)
        .await
        .map_err(|e| {
            tracing::error!("Failed to fetch network range: {}", e);
            (
                StatusCode::INTERNAL_SERVER_ERROR,
                Json(ErrorResponse { error: "Failed to fetch network range".to_string() }),
            )
        })?;

    let range = range.ok_or_else(|| {
        (
            StatusCode::NOT_FOUND,
            Json(ErrorResponse { error: "Network range not found".to_string() }),
        )
    })?;

    let network_range_str = range.network_range.unwrap();
    let network_range: IpNetwork = network_range_str.parse().map_err(|e| {
        tracing::error!("Failed to parse network range: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse { error: "Invalid network range format".to_string() }),
        )
    })?;

    // Get all devices in this network range
    let devices = sqlx::query!(
        "SELECT id, ip_address::text as ip_address
         FROM network_devices
         WHERE ip_address << $1::cidr
         AND device_status = 'online'::device_status",
        network_range
    )
    .fetch_all(&*pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch devices: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse { error: "Failed to fetch devices".to_string() }),
        )
    })?;

    let scan_id = Uuid::new_v4();
    let device_count = devices.len();

    // Update network_ranges with deep scan start
    let _ = sqlx::query!(
        "UPDATE network_ranges SET last_deep_scan_at = NOW(), last_scan_at = NOW() WHERE id = $1",
        range_id
    )
    .execute(&*pool)
    .await;

    // Spawn async task for deep scan of all devices
    tokio::spawn(async move {
        tracing::info!("Starting deep scan for {} devices in range {}", device_count, network_range);

        let network_interface = Some(app_state.config.network.interface.clone());

        for device in devices {
            let scanner = NetworkScanner::new(network_interface.clone());
            let ip_address = device.ip_address.unwrap();
            let device_id = device.id;

            // Add small delay between scans to avoid overwhelming the network
            tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;

            match scanner.nmap_scan(&ip_address, true).await {
                Ok(scanned_device) => {
                    tracing::info!("Deep scan completed for {}", ip_address);

                    // Update device
                    let ip_network: IpNetwork = match scanned_device.ip_address.parse() {
                        Ok(ip) => ip,
                        Err(e) => {
                            tracing::error!("Failed to parse IP: {}", e);
                            continue;
                        }
                    };

                    let device_type_str = format!("{:?}", scanned_device.device_type).to_lowercase();
                    let _ = sqlx::query!(
                        "UPDATE network_devices
                         SET mac_address = COALESCE($1, mac_address),
                             hostname = COALESCE($2, hostname),
                             device_type = $3::text::device_type,
                             vendor = COALESCE($4, vendor),
                             os_name = $5,
                             os_version = $6,
                             open_ports = $7,
                             services = $8,
                             last_seen = NOW(),
                             device_status = 'online'::device_status,
                             updated_at = NOW()
                         WHERE id = $9",
                        scanned_device.mac_address,
                        scanned_device.hostname,
                        device_type_str,
                        scanned_device.vendor,
                        scanned_device.os_name,
                        scanned_device.os_version,
                        scanned_device.open_ports.as_deref(),
                        scanned_device.services,
                        device_id
                    )
                    .execute(&*pool)
                    .await;
                }
                Err(e) => {
                    tracing::error!("Deep scan failed for {}: {}", ip_address, e);
                }
            }
        }

        tracing::info!("Deep scan completed for all devices in range {}", network_range);
    });

    Ok(Json(DiscoveryScanResponse {
        scan_id,
        status: "running".to_string(),
        network_range: network_range.to_string(),
        message: format!("Deep scan started for {} devices", device_count),
    }))
}
