// src/network/handler.rs
// API handlers for network scanning and topology

use axum::{
    extract::{Path, State},
    http::StatusCode,
    Json,
};
use serde::{Deserialize, Serialize};
use uuid::Uuid;
use ipnetwork::IpNetwork;

use crate::state::AppState;
use crate::auth::Claims;
use super::models::*;
use super::scanner::NetworkScanner;

#[derive(Debug, Serialize)]
pub struct ErrorResponse {
    pub error: String,
}

/// Avvia un nuovo network scan
pub async fn start_network_scan(
    State(app_state): State<AppState>,
    claims: Claims,
    Json(request): Json<StartScanRequest>,
) -> Result<Json<ScanProgress>, (StatusCode, Json<ErrorResponse>)> {
    let network_interface = Some(app_state.config.network.interface.clone());
    let scanner = NetworkScanner::new(network_interface);
    let scan_id = scanner.scan_id;
    let pool = app_state.pool.clone();

    // Parse user_id from claims.sub (String) to Uuid
    let user_id = claims.sub.parse::<Uuid>().map_err(|e| {
        tracing::error!("Failed to parse user_id: {}", e);
        (
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: "Invalid user ID".to_string(),
            }),
        )
    })?;

    // Create scan record in database
    sqlx::query!(
        "INSERT INTO network_scans (id, scan_name, scan_type, target_range, status, devices_found, created_by, created_at)
         VALUES ($1, $2, $3, $4, $5, $6, $7, NOW())",
        scan_id,
        request.scan_name,
        request.scan_type,
        request.target_range,
        "running",
        0,
        user_id
    )
    .execute(&*pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to create scan record: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to create scan record".to_string(),
            }),
        )
    })?;

    // Spawn async task to perform scan
    tokio::spawn(async move {
        let started_at = chrono::Utc::now();

        // Update scan status to started
        let _ = sqlx::query!(
            "UPDATE network_scans SET started_at = $1 WHERE id = $2",
            started_at,
            scan_id
        )
        .execute(&*pool)
        .await;

        // Perform ARP scan
        match scanner.arp_scan(&request.target_range).await {
            Ok(devices) => {
                tracing::info!("Scan completed: {} devices found", devices.len());

                // Discover network links automatically
                let links = scanner.discover_links(&devices).await.unwrap_or_default();
                tracing::info!("Discovered {} network links", links.len());

                // Save devices to database and build ID mapping
                let mut device_id_map = std::collections::HashMap::new();

                for device in &devices {
                    // Parse IP address string to IpNetwork for database storage
                    let ip_network = match device.ip_address.parse::<IpNetwork>() {
                        Ok(ip) => ip,
                        Err(e) => {
                            tracing::error!("Failed to parse IP address {}: {}", device.ip_address, e);
                            continue;
                        }
                    };

                    let result = sqlx::query!(
                        "INSERT INTO network_devices
                         (id, ip_address, mac_address, hostname, device_type, device_status,
                          vendor, os_name, os_version, open_ports, services, first_seen, last_seen, created_at, updated_at)
                         VALUES ($1, $2, $3, $4, $5::device_type, $6::device_status, $7, $8, $9, $10, $11, $12, $13, NOW(), NOW())
                         ON CONFLICT (ip_address)
                         DO UPDATE SET
                            mac_address = COALESCE(EXCLUDED.mac_address, network_devices.mac_address),
                            hostname = COALESCE(EXCLUDED.hostname, network_devices.hostname),
                            device_status = EXCLUDED.device_status,
                            last_seen = EXCLUDED.last_seen,
                            updated_at = NOW()
                         RETURNING id",
                        device.id,
                        ip_network,
                        device.mac_address,
                        device.hostname,
                        format!("{:?}", device.device_type).to_lowercase() as _,
                        format!("{:?}", device.device_status).to_lowercase() as _,
                        device.vendor,
                        device.os_name,
                        device.os_version,
                        device.open_ports.as_ref().map(|ports| ports.as_slice()),
                        device.services.as_ref(),
                        device.first_seen,
                        device.last_seen
                    )
                    .fetch_one(&*pool)
                    .await;

                    match result {
                        Ok(record) => {
                            // Map the original device ID to the actual DB ID
                            device_id_map.insert(device.id, record.id);
                        }
                        Err(e) => {
                            tracing::error!("Failed to save device {}: {}", device.ip_address, e);
                        }
                    }
                }

                // Save network links to database using mapped IDs
                for link in &links {
                    // Translate source and target IDs using the mapping
                    let source_id = device_id_map.get(&link.source_device_id);
                    let target_id = device_id_map.get(&link.target_device_id);

                    // Skip link if either device ID wasn't found in the database
                    if source_id.is_none() || target_id.is_none() {
                        tracing::warn!(
                            "Skipping link {}: source or target device not found in database",
                            link.id
                        );
                        continue;
                    }

                    let result = sqlx::query!(
                        "INSERT INTO network_links
                         (id, source_device_id, target_device_id, link_type, latency_ms, hop_count, created_at)
                         VALUES ($1, $2, $3, $4, $5, $6, $7)
                         ON CONFLICT (source_device_id, target_device_id) DO UPDATE SET
                            link_type = EXCLUDED.link_type,
                            latency_ms = EXCLUDED.latency_ms,
                            hop_count = EXCLUDED.hop_count",
                        link.id,
                        source_id.unwrap(),
                        target_id.unwrap(),
                        link.link_type,
                        link.latency_ms,
                        link.hop_count,
                        link.created_at
                    )
                    .execute(&*pool)
                    .await;

                    if let Err(e) = result {
                        tracing::error!("Failed to save network link {}: {}", link.id, e);
                    }
                }

                // Update scan status to completed
                let _ = sqlx::query!(
                    "UPDATE network_scans SET status = $1, devices_found = $2, completed_at = NOW() WHERE id = $3",
                    "completed",
                    devices.len() as i32,
                    scan_id
                )
                .execute(&*pool)
                .await;

                tracing::info!("Scan {} completed successfully", scan_id);
            }
            Err(e) => {
                tracing::error!("Scan {} failed: {}", scan_id, e);

                // Update scan status to failed
                let _ = sqlx::query!(
                    "UPDATE network_scans SET status = $1, completed_at = NOW() WHERE id = $2",
                    "failed",
                    scan_id
                )
                .execute(&*pool)
                .await;
            }
        }
    });

    Ok(Json(ScanProgress {
        scan_id,
        status: "running".to_string(),
        progress_percent: 0.0,
        devices_found: 0,
        message: Some("Scan started successfully".to_string()),
    }))
}

/// Ottieni lo stato di un scan in corso
pub async fn get_scan_status(
    State(app_state): State<AppState>,
    Path(scan_id): Path<Uuid>,
) -> Result<Json<ScanProgress>, (StatusCode, Json<ErrorResponse>)> {
    let pool = &*app_state.pool;

    let scan = sqlx::query!(
        "SELECT status, devices_found FROM network_scans WHERE id = $1",
        scan_id
    )
    .fetch_optional(pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch scan status: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to fetch scan status".to_string(),
            }),
        )
    })?;

    match scan {
        Some(scan) => {
            let progress_percent = match scan.status.as_str() {
                "completed" => 100.0,
                "failed" => 100.0,
                "running" => 50.0,
                _ => 0.0,
            };

            Ok(Json(ScanProgress {
                scan_id,
                status: scan.status,
                progress_percent,
                devices_found: scan.devices_found.unwrap_or(0),
                message: None,
            }))
        }
        None => Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Scan not found".to_string(),
            }),
        )),
    }
}

/// Ottieni la topologia di rete completa
pub async fn get_network_topology(
    State(app_state): State<AppState>,
) -> Result<Json<NetworkTopology>, (StatusCode, Json<ErrorResponse>)> {
    let pool = &*app_state.pool;

    // Fetch all devices - cast enums to text for sqlx compatibility
    let devices_rows = sqlx::query!(
        "SELECT id, ip_address, mac_address, hostname,
                device_type::text as device_type,
                device_status::text as device_status,
                vendor, os_name, os_version, open_ports, services, first_seen, last_seen,
                created_at, updated_at
         FROM network_devices
         ORDER BY last_seen DESC"
    )
    .fetch_all(pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch devices: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to fetch network devices".to_string(),
            }),
        )
    })?;

    let devices: Vec<NetworkDevice> = devices_rows
        .into_iter()
        .map(|row| {
            let device_type = match row.device_type.as_deref().unwrap_or("unknown") {
                "router" => DeviceType::Router,
                "switch" => DeviceType::Switch,
                "firewall" => DeviceType::Firewall,
                "server" => DeviceType::Server,
                "workstation" => DeviceType::Workstation,
                "iot" => DeviceType::IoT,
                "printer" => DeviceType::Printer,
                _ => DeviceType::Unknown,
            };

            let device_status = match row.device_status.as_deref().unwrap_or("unknown") {
                "online" => DeviceStatus::Online,
                "offline" => DeviceStatus::Offline,
                _ => DeviceStatus::Unknown,
            };

            NetworkDevice {
                id: row.id,
                ip_address: row.ip_address.to_string(),
                mac_address: row.mac_address,
                hostname: row.hostname,
                device_type,
                device_status,
                vendor: row.vendor,
                os_name: row.os_name,
                os_version: row.os_version,
                open_ports: row.open_ports.map(|arr| arr.into_iter().map(|p| p as i32).collect()),
                services: row.services,
                first_seen: row.first_seen,
                last_seen: row.last_seen,
                created_at: row.created_at,
                updated_at: row.updated_at,
            }
        })
        .collect();

    // Fetch all links
    let links_rows = sqlx::query!(
        "SELECT id, source_device_id, target_device_id, link_type, latency_ms, hop_count, created_at
         FROM network_links"
    )
    .fetch_all(pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch links: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to fetch network links".to_string(),
            }),
        )
    })?;

    let links: Vec<NetworkLink> = links_rows
        .into_iter()
        .map(|row| NetworkLink {
            id: row.id,
            source_device_id: row.source_device_id,
            target_device_id: row.target_device_id,
            link_type: row.link_type,
            latency_ms: row.latency_ms,
            hop_count: row.hop_count,
            created_at: row.created_at,
        })
        .collect();

    // Fetch latest scan info
    let latest_scan = sqlx::query!(
        "SELECT id, scan_name, scan_type, target_range, status, devices_found,
                started_at, completed_at, created_by, created_at
         FROM network_scans
         ORDER BY created_at DESC
         LIMIT 1"
    )
    .fetch_optional(pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch latest scan: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to fetch latest scan info".to_string(),
            }),
        )
    })?;

    let scan_info = latest_scan.map(|row| NetworkScan {
        id: row.id,
        scan_name: row.scan_name,
        scan_type: row.scan_type,
        target_range: row.target_range,
        status: row.status,
        devices_found: Some(row.devices_found.unwrap_or(0)),
        started_at: row.started_at,
        completed_at: row.completed_at,
        created_by: row.created_by,
        created_at: row.created_at,
    });

    let topology = NetworkTopology {
        devices,
        links,
        scan_info,
    };

    Ok(Json(topology))
}

/// Ottieni dettagli di un device specifico con vulnerabilit√† associate
pub async fn get_device_details(
    State(_app_state): State<AppState>,
    Path(_device_id): Path<Uuid>,
) -> Result<Json<DeviceDetails>, (StatusCode, Json<ErrorResponse>)> {
    // TODO: Query database for device and related vulnerabilities

    let details = DeviceDetails {
        device: None,
        vulnerabilities: Vec::new(),
        remediation_suggestions: Vec::new(),
    };

    Ok(Json(details))
}

/// Esegui remediation su un device
pub async fn execute_remediation(
    State(_app_state): State<AppState>,
    _claims: Claims,
    Path(_device_id): Path<Uuid>,
    Json(_request): Json<RemediationRequest>,
) -> Result<Json<RemediationResponse>, (StatusCode, Json<ErrorResponse>)> {
    // TODO: Implement remediation logic

    Ok(Json(RemediationResponse {
        success: true,
        message: "Remediation queued for execution".to_string(),
        task_id: Some(Uuid::new_v4()),
    }))
}

/// Get network topology with vulnerability data (Priority 1)
pub async fn get_topology_with_vulnerabilities(
    State(app_state): State<AppState>,
) -> Result<Json<super::models::NetworkTopologyWithVulnerabilities>, (StatusCode, Json<ErrorResponse>)> {
    use super::models::{NetworkDeviceWithVulnerabilities, VulnerabilitySummary};
    

    let pool = &*app_state.pool;

    // Fetch all devices with assignment data
    let devices_data = sqlx::query!(
        r#"
        SELECT
            id, ip_address, mac_address, hostname,
            device_type as "device_type: DeviceType",
            device_status as "device_status: DeviceStatus",
            vendor, os_name, os_version, open_ports, services,
            first_seen, last_seen, created_at, updated_at,
            assigned_user_id, assigned_team_id, owner, location,
            criticality, tags, notes, is_internet_facing, has_public_ip
        FROM network_devices
        ORDER BY last_seen DESC
        "#
    )
    .fetch_all(pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch devices: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to fetch devices".to_string(),
            }),
        )
    })?;

    let mut devices = Vec::new();

    for device_row in devices_data {
        // Get vulnerability summary for this device
        let vuln_summary = sqlx::query!(
            r#"
            SELECT
                COUNT(*) as total,
                COUNT(*) FILTER (WHERE v.severity = 'critical') as critical,
                COUNT(*) FILTER (WHERE v.severity = 'high') as high,
                COUNT(*) FILTER (WHERE v.severity = 'medium') as medium,
                COUNT(*) FILTER (WHERE v.severity = 'low') as low,
                COUNT(*) FILTER (WHERE v.severity = 'info') as info,
                AVG(v.epss_score) as epss_avg,
                MAX(v.epss_score) as epss_max,
                AVG(v.cvss_score) as cvss_avg,
                MAX(v.cvss_score) as cvss_max
            FROM device_vulnerabilities dv
            JOIN vulnerabilities v ON v.id = dv.vulnerability_id
            WHERE dv.device_id = $1
            AND v.status IN ('open', 'in_progress')
            "#,
            device_row.id
        )
        .fetch_one(pool)
        .await
        .map_err(|e| {
            tracing::error!("Failed to fetch vulnerability summary: {}", e);
            (
                StatusCode::INTERNAL_SERVER_ERROR,
                Json(ErrorResponse {
                    error: "Failed to fetch vulnerability summary".to_string(),
                }),
            )
        })?;

        let vulnerabilities = VulnerabilitySummary {
            total: vuln_summary.total.unwrap_or(0),
            critical: vuln_summary.critical.unwrap_or(0),
            high: vuln_summary.high.unwrap_or(0),
            medium: vuln_summary.medium.unwrap_or(0),
            low: vuln_summary.low.unwrap_or(0),
            info: vuln_summary.info.unwrap_or(0),
            epss_average: vuln_summary.epss_avg.map(|v| v as f64),
            epss_max: vuln_summary.epss_max.map(|v| v as f64),
            cvss_average: vuln_summary.cvss_avg.map(|v| v as f64),
            cvss_max: vuln_summary.cvss_max.map(|v| v as f64),
        };

        devices.push(NetworkDeviceWithVulnerabilities {
            id: device_row.id,
            ip_address: device_row.ip_address.to_string(),
            mac_address: device_row.mac_address,
            hostname: device_row.hostname,
            device_type: device_row.device_type,
            device_status: device_row.device_status,
            vendor: device_row.vendor,
            os_name: device_row.os_name,
            os_version: device_row.os_version,
            open_ports: device_row.open_ports,
            services: device_row.services,
            first_seen: device_row.first_seen,
            last_seen: device_row.last_seen,
            created_at: device_row.created_at,
            updated_at: device_row.updated_at,
            assigned_user_id: device_row.assigned_user_id,
            assigned_team_id: device_row.assigned_team_id,
            owner: device_row.owner,
            location: device_row.location,
            criticality: device_row.criticality,
            tags: device_row.tags,
            notes: device_row.notes,
            is_internet_facing: device_row.is_internet_facing,
            has_public_ip: device_row.has_public_ip,
            vulnerabilities,
        });
    }

    // Fetch links
    let links_data = sqlx::query_as!(
        super::models::NetworkLink,
        "SELECT id, source_device_id, target_device_id, link_type, latency_ms, hop_count, created_at
         FROM network_links"
    )
    .fetch_all(pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch links: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to fetch links".to_string(),
            }),
        )
    })?;

    // Get latest scan info
    let scan_info = sqlx::query_as!(
        NetworkScan,
        "SELECT id, scan_name, scan_type, target_range, status, devices_found,
                started_at, completed_at, created_by, created_at
         FROM network_scans
         ORDER BY created_at DESC
         LIMIT 1"
    )
    .fetch_optional(pool)
    .await
    .ok()
    .flatten();

    Ok(Json(super::models::NetworkTopologyWithVulnerabilities {
        devices,
        links: links_data,
        scan_info,
    }))
}

/// Update device information (Priority 2)
pub async fn update_device(
    State(app_state): State<AppState>,
    _claims: Claims,
    Path(device_id): Path<Uuid>,
    Json(update_data): Json<super::models::UpdateDeviceRequest>,
) -> Result<Json<NetworkDevice>, (StatusCode, Json<ErrorResponse>)> {
    

    let pool = &*app_state.pool;

    // Build UPDATE query dynamically based on provided fields
    let device = sqlx::query!(
        r#"
        UPDATE network_devices
        SET
            hostname = COALESCE($2, hostname),
            device_type = COALESCE($3, device_type),
            owner = COALESCE($4, owner),
            location = COALESCE($5, location),
            criticality = COALESCE($6, criticality),
            tags = COALESCE($7, tags),
            notes = COALESCE($8, notes),
            is_internet_facing = COALESCE($9, is_internet_facing),
            has_public_ip = COALESCE($10, has_public_ip),
            assigned_user_id = COALESCE($11, assigned_user_id),
            assigned_team_id = COALESCE($12, assigned_team_id),
            updated_at = NOW()
        WHERE id = $1
        RETURNING
            id, ip_address, mac_address, hostname,
            device_type as "device_type: DeviceType",
            device_status as "device_status: DeviceStatus",
            vendor, os_name, os_version, open_ports, services,
            first_seen, last_seen, created_at, updated_at
        "#,
        device_id,
        update_data.hostname,
        update_data.device_type.map(|dt| format!("{:?}", dt).to_lowercase()) as _,
        update_data.owner,
        update_data.location,
        update_data.criticality,
        update_data.tags.as_deref(),
        update_data.notes,
        update_data.is_internet_facing,
        update_data.has_public_ip,
        update_data.assigned_user_id,
        update_data.assigned_team_id,
    )
    .fetch_optional(pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to update device: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Failed to update device: {}", e),
            }),
        )
    })?
    .ok_or_else(|| {
        (
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Device not found".to_string(),
            }),
        )
    })?;

    Ok(Json(NetworkDevice {
        id: device.id,
        ip_address: device.ip_address.to_string(),
        mac_address: device.mac_address,
        hostname: device.hostname,
        device_type: device.device_type,
        device_status: device.device_status,
        vendor: device.vendor,
        os_name: device.os_name,
        os_version: device.os_version,
        open_ports: device.open_ports,
        services: device.services,
        first_seen: device.first_seen,
        last_seen: device.last_seen,
        created_at: device.created_at,
        updated_at: device.updated_at,
    }))
}

/// Bulk assign devices to user/team (Priority 3)
pub async fn bulk_assign_devices(
    State(app_state): State<AppState>,
    _claims: Claims,
    Json(assign_data): Json<super::models::BulkAssignRequest>,
) -> Result<Json<serde_json::Value>, (StatusCode, Json<ErrorResponse>)> {
    let pool = &*app_state.pool;

    let updated_count = sqlx::query!(
        "UPDATE network_devices
         SET
            assigned_user_id = COALESCE($1, assigned_user_id),
            assigned_team_id = COALESCE($2, assigned_team_id),
            updated_at = NOW()
         WHERE id = ANY($3)",
        assign_data.user_id,
        assign_data.team_id,
        &assign_data.device_ids
    )
    .execute(pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to bulk assign devices: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Failed to bulk assign devices: {}", e),
            }),
        )
    })?
    .rows_affected();

    Ok(Json(serde_json::json!({
        "success": true,
        "updated_count": updated_count,
        "message": format!("Successfully assigned {} devices", updated_count)
    })))
}

/// Get vulnerabilities for specific device (Priority 1)
pub async fn get_device_vulnerabilities(
    State(app_state): State<AppState>,
    Path(device_id): Path<Uuid>,
) -> Result<Json<serde_json::Value>, (StatusCode, Json<ErrorResponse>)> {
    let pool = &*app_state.pool;

    // Get device info
    let device = sqlx::query!(
        r#"
        SELECT id, ip_address, hostname,
               device_type as "device_type: DeviceType"
        FROM network_devices
        WHERE id = $1
        "#,
        device_id
    )
    .fetch_optional(pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch device: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to fetch device".to_string(),
            }),
        )
    })?
    .ok_or_else(|| {
        (
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Device not found".to_string(),
            }),
        )
    })?;

    // Get all vulnerabilities for this device
    let vulnerabilities = sqlx::query!(
        r#"
        SELECT
            v.id, v.title, v.description, v.cvss_score, v.epss_score,
            v.severity as "severity: crate::models::vulnerability::VulnerabilitySeverity",
            v.status as "status: crate::models::vulnerability::VulnerabilityStatus",
            v.cve_id, v.cwe_id, v.remediation, v.discovered_at,
            v.assigned_user_id, v.assigned_team_id
        FROM device_vulnerabilities dv
        JOIN vulnerabilities v ON v.id = dv.vulnerability_id
        WHERE dv.device_id = $1
        ORDER BY v.cvss_score DESC, v.epss_score DESC
        "#,
        device_id
    )
    .fetch_all(pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch vulnerabilities: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Failed to fetch vulnerabilities".to_string(),
            }),
        )
    })?;

    Ok(Json(serde_json::json!({
        "device": {
            "id": device.id,
            "ip_address": device.ip_address.to_string(),
            "hostname": device.hostname,
            "device_type": format!("{:?}", device.device_type),
        },
        "vulnerabilities": vulnerabilities.iter().map(|v| {
            serde_json::json!({
                "id": v.id,
                "title": v.title,
                "description": v.description,
                "cvss_score": v.cvss_score,
                "epss_score": v.epss_score,
                "severity": format!("{:?}", v.severity),
                "status": format!("{:?}", v.status),
                "cve_id": v.cve_id,
                "cwe_id": v.cwe_id,
                "remediation": v.remediation,
                "discovered_at": v.discovered_at,
                "assigned_user_id": v.assigned_user_id,
                "assigned_team_id": v.assigned_team_id,
            })
        }).collect::<Vec<_>>(),
        "summary": {
            "total": vulnerabilities.len(),
            "critical": vulnerabilities.iter().filter(|v| format!("{:?}", v.severity) == "Critical").count(),
            "high": vulnerabilities.iter().filter(|v| format!("{:?}", v.severity) == "High").count(),
            "medium": vulnerabilities.iter().filter(|v| format!("{:?}", v.severity) == "Medium").count(),
            "low": vulnerabilities.iter().filter(|v| format!("{:?}", v.severity) == "Low").count(),
        }
    })))
}

// Additional DTOs
#[derive(Debug, Serialize)]
pub struct DeviceDetails {
    pub device: Option<NetworkDevice>,
    pub vulnerabilities: Vec<serde_json::Value>,
    pub remediation_suggestions: Vec<String>,
}

#[derive(Debug, Deserialize)]
pub struct RemediationRequest {
    pub vulnerability_id: Uuid,
    pub remediation_type: String, // auto, manual, script
    pub script: Option<String>,
}

#[derive(Debug, Serialize)]
pub struct RemediationResponse {
    pub success: bool,
    pub message: String,
    pub task_id: Option<Uuid>,
}
