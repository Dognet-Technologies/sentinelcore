// src/network/handler.rs
// API handlers for network scanning and topology

use axum::{
    extract::{Path, State},
    http::StatusCode,
    Json,
};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use crate::state::AppState;
use crate::auth::Claims;
use super::models::*;
use super::scanner::NetworkScanner;
use std::str::FromStr;

#[derive(Debug, Serialize)]
pub struct ErrorResponse {
    pub error: String,
}

/// Avvia un nuovo network scan
pub async fn start_network_scan(
    State(app_state): State<AppState>,
    claims: Claims,
    Json(request): Json<StartScanRequest>,
) -> Result<Json<ScanProgress>, (StatusCode, Json<ErrorResponse>)> {
    let scanner = NetworkScanner::new();
    let scan_id = scanner.scan_id;

    // Parse user ID from claims
    let user_id = Uuid::parse_str(&claims.sub).map_err(|e| {
        tracing::error!("Invalid user ID in claims: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Invalid user ID".to_string(),
            }),
        )
    })?;

    // Create scan record in database
    sqlx::query!(
        r#"
        INSERT INTO network_scans (id, scan_name, scan_type, target_range, status, created_by)
        VALUES ($1, $2, $3, $4, $5, $6)
        "#,
        scan_id,
        request.scan_name,
        request.scan_type,
        request.target_range,
        "running",
        user_id
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to create scan record: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Database error: {}", e),
            }),
        )
    })?;

    // Clone pool for background task
    let pool = app_state.pool.clone();
    let target_range = request.target_range.clone();

    // Spawn async task to perform scan
    tokio::spawn(async move {
        // Update scan status to running with start time
        sqlx::query!(
            "UPDATE network_scans SET started_at = NOW() WHERE id = $1",
            scan_id
        )
        .execute(&*pool)
        .await
        .ok();

        // Perform ARP scan
        match scanner.arp_scan(&target_range).await {
            Ok(devices) => {
                tracing::info!("Scan completed: {} devices found", devices.len());

                // Save discovered devices to database
                for device in &devices {
                    // Parse IP address to IpNetwork
                    let ip_network = match sqlx::types::ipnetwork::IpNetwork::from_str(&device.ip_address) {
                        Ok(ip) => ip,
                        Err(e) => {
                            tracing::error!("Failed to parse IP address {}: {}", device.ip_address, e);
                            continue;
                        }
                    };

                    let result = sqlx::query!(
                        r#"
                        INSERT INTO network_devices (
                            ip_address, mac_address, hostname, device_type,
                            device_status, vendor, first_seen, last_seen
                        )
                        VALUES ($1, $2, $3, $4, $5, $6, NOW(), NOW())
                        ON CONFLICT (ip_address) DO UPDATE SET
                            mac_address = EXCLUDED.mac_address,
                            hostname = EXCLUDED.hostname,
                            device_status = EXCLUDED.device_status,
                            vendor = EXCLUDED.vendor,
                            last_seen = NOW(),
                            updated_at = NOW()
                        "#,
                        ip_network,
                        device.mac_address,
                        device.hostname,
                        device.device_type as _,
                        device.device_status as _,
                        device.vendor
                    )
                    .execute(&*pool)
                    .await;

                    if let Err(e) = result {
                        tracing::error!("Failed to save device {}: {}", device.ip_address, e);
                    }
                }

                // Update scan status to completed
                sqlx::query!(
                    r#"
                    UPDATE network_scans
                    SET status = 'completed', devices_found = $1, completed_at = NOW()
                    WHERE id = $2
                    "#,
                    devices.len() as i32,
                    scan_id
                )
                .execute(&*pool)
                .await
                .ok();
            }
            Err(e) => {
                tracing::error!("Scan failed: {}", e);
                // Update scan status to failed
                sqlx::query!(
                    "UPDATE network_scans SET status = 'failed', completed_at = NOW() WHERE id = $1",
                    scan_id
                )
                .execute(&*pool)
                .await
                .ok();
            }
        }
    });

    Ok(Json(ScanProgress {
        scan_id,
        status: "running".to_string(),
        progress_percent: 0.0,
        devices_found: 0,
        message: Some("Scan started successfully".to_string()),
    }))
}

/// Ottieni lo stato di un scan in corso
pub async fn get_scan_status(
    State(_app_state): State<AppState>,
    Path(scan_id): Path<Uuid>,
) -> Result<Json<ScanProgress>, (StatusCode, Json<ErrorResponse>)> {
    // TODO: Query database for scan status

    Ok(Json(ScanProgress {
        scan_id,
        status: "completed".to_string(),
        progress_percent: 100.0,
        devices_found: 0,
        message: None,
    }))
}

/// Ottieni la topologia di rete completa
pub async fn get_network_topology(
    State(app_state): State<AppState>,
) -> Result<Json<NetworkTopology>, (StatusCode, Json<ErrorResponse>)> {
    // Query all network devices
    let devices = sqlx::query_as!(
        NetworkDevice,
        r#"
        SELECT
            id,
            ip_address::TEXT as "ip_address!",
            mac_address,
            hostname,
            device_type as "device_type!: DeviceType",
            device_status as "device_status!: DeviceStatus",
            vendor,
            os_name,
            os_version,
            open_ports,
            services,
            first_seen,
            last_seen,
            created_at,
            updated_at
        FROM network_devices
        ORDER BY last_seen DESC
        "#
    )
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch network devices: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Database error: {}", e),
            }),
        )
    })?;

    // Query all network links
    let links = sqlx::query_as!(
        NetworkLink,
        r#"
        SELECT
            id,
            source_device_id,
            target_device_id,
            link_type,
            latency_ms,
            hop_count,
            created_at
        FROM network_links
        "#
    )
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch network links: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Database error: {}", e),
            }),
        )
    })?;

    // Get latest scan info
    let scan_info = sqlx::query_as!(
        NetworkScan,
        r#"
        SELECT
            id,
            scan_name as "scan_name!",
            scan_type as "scan_type!",
            target_range as "target_range!",
            status as "status!",
            devices_found as "devices_found!",
            started_at,
            completed_at,
            created_by,
            created_at
        FROM network_scans
        ORDER BY created_at DESC
        LIMIT 1
        "#
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch latest scan info: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Database error: {}", e),
            }),
        )
    })?;

    let topology = NetworkTopology {
        devices,
        links,
        scan_info,
    };

    Ok(Json(topology))
}

/// Ottieni dettagli di un device specifico con vulnerabilit√† associate
pub async fn get_device_details(
    State(app_state): State<AppState>,
    Path(device_id): Path<Uuid>,
) -> Result<Json<DeviceDetails>, (StatusCode, Json<ErrorResponse>)> {
    // Query device details
    let device = sqlx::query_as!(
        NetworkDevice,
        r#"
        SELECT
            id,
            ip_address::TEXT as "ip_address!",
            mac_address,
            hostname,
            device_type as "device_type!: DeviceType",
            device_status as "device_status!: DeviceStatus",
            vendor,
            os_name,
            os_version,
            open_ports,
            services,
            first_seen,
            last_seen,
            created_at,
            updated_at
        FROM network_devices
        WHERE id = $1
        "#,
        device_id
    )
    .fetch_optional(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch device details: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Database error: {}", e),
            }),
        )
    })?;

    // Query associated vulnerabilities
    let vulnerabilities = sqlx::query!(
        r#"
        SELECT
            v.id,
            v.cve_id,
            v.title,
            v.description,
            v.severity::TEXT as severity,
            v.cvss_score,
            v.status::TEXT as status,
            dv.discovered_at
        FROM vulnerabilities v
        INNER JOIN device_vulnerabilities dv ON v.id = dv.vulnerability_id
        WHERE dv.device_id = $1
        ORDER BY v.cvss_score DESC
        "#,
        device_id
    )
    .fetch_all(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to fetch device vulnerabilities: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Database error: {}", e),
            }),
        )
    })?
    .into_iter()
    .map(|row| {
        serde_json::json!({
            "id": row.id,
            "cve_id": row.cve_id,
            "title": row.title,
            "description": row.description,
            "severity": row.severity,
            "cvss_score": row.cvss_score,
            "status": row.status,
            "discovered_at": row.discovered_at
        })
    })
    .collect();

    // Generate remediation suggestions based on vulnerabilities
    let remediation_suggestions = vec![
        "Apply latest security patches".to_string(),
        "Update operating system and software".to_string(),
        "Review and close unnecessary open ports".to_string(),
        "Enable firewall rules".to_string(),
    ];

    let details = DeviceDetails {
        device,
        vulnerabilities,
        remediation_suggestions,
    };

    Ok(Json(details))
}

/// Esegui remediation su un device
pub async fn execute_remediation(
    State(app_state): State<AppState>,
    claims: Claims,
    Path(device_id): Path<Uuid>,
    Json(request): Json<RemediationRequest>,
) -> Result<Json<RemediationResponse>, (StatusCode, Json<ErrorResponse>)> {
    // Verify device exists
    let device_exists = sqlx::query_scalar!(
        "SELECT EXISTS(SELECT 1 FROM network_devices WHERE id = $1)",
        device_id
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to check device existence: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Database error: {}", e),
            }),
        )
    })?
    .unwrap_or(false);

    if !device_exists {
        return Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Device not found".to_string(),
            }),
        ));
    }

    // Verify vulnerability exists
    let vuln_exists = sqlx::query_scalar!(
        "SELECT EXISTS(SELECT 1 FROM vulnerabilities WHERE id = $1)",
        request.vulnerability_id
    )
    .fetch_one(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to check vulnerability existence: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Database error: {}", e),
            }),
        )
    })?
    .unwrap_or(false);

    if !vuln_exists {
        return Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "Vulnerability not found".to_string(),
            }),
        ));
    }

    // Parse user ID from claims
    let user_id = Uuid::parse_str(&claims.sub).map_err(|e| {
        tracing::error!("Invalid user ID in claims: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: "Invalid user ID".to_string(),
            }),
        )
    })?;

    // Create remediation task
    let task_id = Uuid::new_v4();
    sqlx::query!(
        r#"
        INSERT INTO remediation_tasks (
            id, device_id, vulnerability_id, task_type, script, status, created_by
        ) VALUES ($1, $2, $3, $4, $5, $6, $7)
        "#,
        task_id,
        device_id,
        request.vulnerability_id,
        request.remediation_type,
        request.script,
        "pending",
        user_id
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::error!("Failed to create remediation task: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse {
                error: format!("Database error: {}", e),
            }),
        )
    })?;

    // Log the audit event
    sqlx::query!(
        r#"
        INSERT INTO audit_logs (user_id, action, entity_type, entity_id, old_values, new_values, ip_address)
        VALUES ($1, $2, $3, $4, $5, $6, $7)
        "#,
        user_id,
        "create_remediation_task",
        "remediation_task",
        task_id,
        None as Option<serde_json::Value>,
        serde_json::json!({
            "device_id": device_id,
            "vulnerability_id": request.vulnerability_id,
            "task_type": request.remediation_type
        }),
        None as Option<String>
    )
    .execute(&*app_state.pool)
    .await
    .map_err(|e| {
        tracing::warn!("Failed to create audit log: {}", e);
    })
    .ok();

    // TODO: Spawn async task to execute remediation script
    // For now, just queue it
    tracing::info!(
        "Remediation task {} created for device {} and vulnerability {}",
        task_id,
        device_id,
        request.vulnerability_id
    );

    Ok(Json(RemediationResponse {
        success: true,
        message: format!("Remediation task {} queued for execution", task_id),
        task_id: Some(task_id),
    }))
}

// Alias functions for API routes compatibility
pub use start_network_scan as trigger_scan;
pub use execute_remediation as remediate_device;

// Additional DTOs
#[derive(Debug, Serialize)]
pub struct DeviceDetails {
    pub device: Option<NetworkDevice>,
    pub vulnerabilities: Vec<serde_json::Value>,
    pub remediation_suggestions: Vec<String>,
}

#[derive(Debug, Deserialize)]
pub struct RemediationRequest {
    pub vulnerability_id: Uuid,
    pub remediation_type: String, // auto, manual, script
    pub script: Option<String>,
}

#[derive(Debug, Serialize)]
pub struct RemediationResponse {
    pub success: bool,
    pub message: String,
    pub task_id: Option<Uuid>,
}
