// src/validators.rs
// Input validation helpers for vulnerabilities and other entities

use crate::models::vulnerability::NewVulnerability;

#[derive(Debug)]
pub struct ValidationError {
    pub message: String,
}

impl ValidationError {
    pub fn new(message: impl Into<String>) -> Self {
        Self {
            message: message.into(),
        }
    }
}

impl std::fmt::Display for ValidationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.message)
    }
}

impl std::error::Error for ValidationError {}

/// Validate a CVSS score (must be 0-10)
pub fn validate_cvss_score(score: f32) -> Result<(), ValidationError> {
    if score < 0.0 || score > 10.0 {
        return Err(ValidationError::new("CVSS score must be between 0 and 10"));
    }
    Ok(())
}

/// Validate an EPSS score (must be 0-1)
pub fn validate_epss_score(score: f32) -> Result<(), ValidationError> {
    if score < 0.0 || score > 1.0 {
        return Err(ValidationError::new("EPSS score must be between 0 and 1"));
    }
    Ok(())
}

/// Validate a port number
pub fn validate_port(port: i32) -> Result<(), ValidationError> {
    if port < 1 || port > 65535 {
        return Err(ValidationError::new("Port must be between 1 and 65535"));
    }
    Ok(())
}

/// Validate CVE ID format (CVE-YYYY-XXXXX)
pub fn validate_cve_id(cve_id: &str) -> Result<(), ValidationError> {
    if !cve_id.starts_with("CVE-") {
        return Err(ValidationError::new("CVE ID must start with 'CVE-'"));
    }
    
    let parts: Vec<&str> = cve_id.split('-').collect();
    if parts.len() < 3 {
        return Err(ValidationError::new("Invalid CVE ID format. Expected CVE-YYYY-XXXXX"));
    }
    
    // Validate year is 4 digits
    if parts[1].len() != 4 || !parts[1].chars().all(|c| c.is_numeric()) {
        return Err(ValidationError::new("CVE year must be 4 digits"));
    }
    
    Ok(())
}

/// Validate that title is not empty
pub fn validate_title(title: &str) -> Result<(), ValidationError> {
    if title.is_empty() {
        return Err(ValidationError::new("Title cannot be empty"));
    }
    Ok(())
}

/// Validate that description is not empty
pub fn validate_description(description: &str) -> Result<(), ValidationError> {
    if description.is_empty() {
        return Err(ValidationError::new("Description cannot be empty"));
    }
    Ok(())
}

/// Validate email format (basic RFC 5322 check)
pub fn validate_email(email: &str) -> Result<(), ValidationError> {
    if email.is_empty() {
        return Err(ValidationError::new("Email cannot be empty"));
    }
    
    if !email.contains('@') {
        return Err(ValidationError::new("Email must contain @ symbol"));
    }
    
    let parts: Vec<&str> = email.split('@').collect();
    if parts.len() != 2 {
        return Err(ValidationError::new("Email must have exactly one @ symbol"));
    }
    
    if parts[0].is_empty() || parts[1].is_empty() {
        return Err(ValidationError::new("Email local part and domain cannot be empty"));
    }
    
    if !parts[1].contains('.') {
        return Err(ValidationError::new("Email domain must contain a dot"));
    }
    
    Ok(())
}

/// Validate IP address format (IPv4 or IPv6)
pub fn validate_ip_address(ip: &str) -> Result<(), ValidationError> {
    if ip.is_empty() {
        return Err(ValidationError::new("IP address cannot be empty"));
    }
    
    if ip.parse::<std::net::IpAddr>().is_ok() {
        return Ok(());
    }
    
    Err(ValidationError::new("Invalid IP address format (must be valid IPv4 or IPv6)"))
}

/// Validate that hostname is not empty and follows basic rules
pub fn validate_hostname(hostname: &str) -> Result<(), ValidationError> {
    if hostname.is_empty() {
        return Err(ValidationError::new("Hostname cannot be empty"));
    }
    
    if hostname.len() > 253 {
        return Err(ValidationError::new("Hostname must be 253 characters or less"));
    }
    
    if !hostname.chars().all(|c| c.is_alphanumeric() || c == '-' || c == '.' || c == '_') {
        return Err(ValidationError::new("Hostname contains invalid characters"));
    }
    
    Ok(())
}

/// Comprehensive validation for NewVulnerability
pub fn validate_new_vulnerability(vuln: &NewVulnerability) -> Result<(), Vec<ValidationError>> {
    let mut errors = Vec::new();

    // Validate CVSS score
    if let Err(e) = validate_cvss_score(vuln.cvss_score) {
        errors.push(e);
    }

    // Validate EPSS score if provided
    if let Some(epss) = vuln.epss_score {
        if let Err(e) = validate_epss_score(epss) {
            errors.push(e);
        }
    }

    // Validate port if provided
    if let Some(port) = vuln.port {
        if let Err(e) = validate_port(port) {
            errors.push(e);
        }
    }

    // Validate CVE ID if provided
    if let Some(cve_id) = &vuln.cve_id {
        if !cve_id.is_empty() {
            if let Err(e) = validate_cve_id(cve_id) {
                errors.push(e);
            }
        }
    }

    // Validate title
    if let Err(e) = validate_title(&vuln.title) {
        errors.push(e);
    }

    // Validate description
    if let Err(e) = validate_description(&vuln.description) {
        errors.push(e);
    }



    if errors.is_empty() {
        Ok(())
    } else {
        Err(errors)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_validate_cvss_score() {
        assert!(validate_cvss_score(5.5).is_ok());
        assert!(validate_cvss_score(0.0).is_ok());
        assert!(validate_cvss_score(10.0).is_ok());
        assert!(validate_cvss_score(-0.1).is_err());
        assert!(validate_cvss_score(10.1).is_err());
    }

    #[test]
    fn test_validate_epss_score() {
        assert!(validate_epss_score(0.5).is_ok());
        assert!(validate_epss_score(0.0).is_ok());
        assert!(validate_epss_score(1.0).is_ok());
        assert!(validate_epss_score(-0.1).is_err());
        assert!(validate_epss_score(1.1).is_err());
    }

    #[test]
    fn test_validate_port() {
        assert!(validate_port(80).is_ok());
        assert!(validate_port(443).is_ok());
        assert!(validate_port(1).is_ok());
        assert!(validate_port(65535).is_ok());
        assert!(validate_port(0).is_err());
        assert!(validate_port(65536).is_err());
    }

    #[test]
    fn test_validate_cve_id() {
        assert!(validate_cve_id("CVE-2021-12345").is_ok());
        assert!(validate_cve_id("CVE-2020-1").is_ok());
        assert!(validate_cve_id("CVE-2021").is_err());
        assert!(validate_cve_id("CVE-XXXX-12345").is_err());
        assert!(validate_cve_id("NVD-2021-12345").is_err());
    }

    #[test]
    fn test_validate_email() {
        assert!(validate_email("test@example.com").is_ok());
        assert!(validate_email("user.name@domain.co.uk").is_ok());
        assert!(validate_email("").is_err());
        assert!(validate_email("invalid.email").is_err());
        assert!(validate_email("@example.com").is_err());
        assert!(validate_email("user@").is_err());
        assert!(validate_email("user@@example.com").is_err());
        assert!(validate_email("user@localhost").is_err());
    }

    #[test]
    fn test_validate_ip_address() {
        assert!(validate_ip_address("192.168.1.1").is_ok());
        assert!(validate_ip_address("10.0.0.1").is_ok());
        assert!(validate_ip_address("2001:db8::1").is_ok());
        assert!(validate_ip_address("::1").is_ok());
        assert!(validate_ip_address("").is_err());
        assert!(validate_ip_address("256.256.256.256").is_err());
        assert!(validate_ip_address("not.an.ip.address").is_err());
        assert!(validate_ip_address("192.168.1").is_err());
    }

    #[test]
    fn test_validate_hostname() {
        assert!(validate_hostname("example.com").is_ok());
        assert!(validate_hostname("sub.example.com").is_ok());
        assert!(validate_hostname("example-host").is_ok());
        assert!(validate_hostname("host_name").is_ok());
        assert!(validate_hostname("192-168-1-1").is_ok());
        assert!(validate_hostname("").is_err());
        assert!(validate_hostname("invalid@hostname.com").is_err());
        assert!(validate_hostname("invalid hostname").is_err());
    }
}
