// src/remediation/rbre.rs
// Risk-Based Remediation Engine (RBRE)
// Calculates Remediation Priority Score (RPS) for vulnerabilities based on multiple factors

use serde::{Deserialize, Serialize};
use std::f64::consts::LN_2;

#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq)]
pub enum AssetCriticality {
    #[serde(rename = "mission_critical")]
    MissionCritical,
    #[serde(rename = "core_business")]
    CoreBusiness,
    #[serde(rename = "supporto")]
    Supporto,
    #[serde(rename = "lab_test")]
    LabTest,
}

impl AssetCriticality {
    pub fn score(&self) -> f64 {
        match self {
            AssetCriticality::MissionCritical => 1.0,
            AssetCriticality::CoreBusiness => 0.9,
            AssetCriticality::Supporto => 0.6,
            AssetCriticality::LabTest => 0.3,
        }
    }
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq)]
pub enum ExposureLevel {
    #[serde(rename = "internet_facing")]
    InternetFacing,
    #[serde(rename = "dmz")]
    DMZ,
    #[serde(rename = "internal")]
    Internal,
    #[serde(rename = "segmented")]
    Segmented,
}

impl ExposureLevel {
    pub fn score(&self) -> f64 {
        match self {
            ExposureLevel::InternetFacing => 1.0,
            ExposureLevel::DMZ => 0.8,
            ExposureLevel::Internal => 0.5,
            ExposureLevel::Segmented => 0.2,
        }
    }
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
pub enum ThreatContext {
    #[serde(rename = "in_the_wild")]
    InTheWild,
    #[serde(rename = "public_exploit")]
    PublicExploit,
    #[serde(rename = "poc")]
    PoC,
    #[serde(rename = "no_exploit")]
    NoExploit,
}

impl ThreatContext {
    pub fn score(&self) -> f64 {
        match self {
            ThreatContext::InTheWild => 1.0,
            ThreatContext::PublicExploit => 0.8,
            ThreatContext::PoC => 0.6,
            ThreatContext::NoExploit => 0.3,
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RBREFactors {
    // Input factors (normalized 0-1)
    pub technical_severity: f64,     // CVSS/10
    pub exploit_probability: f64,    // EPSS (0-1)
    pub asset_criticality: f64,      // Asset criticality score
    pub exposure_factor: f64,        // Network exposure
    pub threat_context: f64,         // Exploit availability
    pub time_factor: f64,            // Days open (logarithmic)
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RemediationPriorityScore {
    pub rps: f64,                    // 0-100 final score
    pub priority_tier: PriorityTier,
    pub factors: RBREFactors,
    pub explanation: String,
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq, PartialOrd, Ord)]
pub enum PriorityTier {
    Critical,   // RPS >= 70
    High,       // RPS 40-69
    Medium,     // RPS 20-39
    Low,        // RPS < 20
}

impl PriorityTier {
    pub fn label(&self) -> &'static str {
        match self {
            PriorityTier::Critical => "Critical",
            PriorityTier::High => "High",
            PriorityTier::Medium => "Medium",
            PriorityTier::Low => "Low",
        }
    }

    pub fn color(&self) -> &'static str {
        match self {
            PriorityTier::Critical => "#DC2626",
            PriorityTier::High => "#EA580C",
            PriorityTier::Medium => "#FBBF24",
            PriorityTier::Low => "#3B82F6",
        }
    }

    pub fn sla_days(&self) -> u16 {
        match self {
            PriorityTier::Critical => 1,
            PriorityTier::High => 7,
            PriorityTier::Medium => 30,
            PriorityTier::Low => 90,
        }
    }
}

pub struct RBRECalculator;

impl RBRECalculator {
    /// Normalizes CVSS score (0-10) to 0-1 scale
    pub fn normalize_cvss(cvss: f64) -> f64 {
        (cvss / 10.0).min(1.0).max(0.0)
    }

    /// Calculates time factor based on days open
    /// Formula: TF = min(1, ln(days_open + 1) / ln(180))
    /// - Day 1: ~0.13
    /// - Day 30: ~0.69
    /// - Day 90: ~0.85
    /// - Day 180+: 1.0
    pub fn calculate_time_factor(days_open: u32) -> f64 {
        let days_f64 = days_open as f64;
        let numerator = (days_f64 + 1.0).ln();
        let denominator = 180_f64.ln(); // ln(180) ≈ 5.193
        (numerator / denominator).min(1.0)
    }

    /// Calculates RPS using multiplicative model
    /// RPS = (TS × EP × AC × EX × TC × TF) × 100
    pub fn calculate_rps(factors: &RBREFactors) -> RemediationPriorityScore {
        let rps_raw = factors.technical_severity
            * factors.exploit_probability
            * factors.asset_criticality
            * factors.exposure_factor
            * factors.threat_context
            * factors.time_factor;

        let rps = (rps_raw * 100.0).round();
        let priority_tier = Self::get_priority_tier(rps);
        let explanation = Self::generate_explanation(factors, rps);

        RemediationPriorityScore {
            rps,
            priority_tier,
            factors: factors.clone(),
            explanation,
        }
    }

    /// Determines priority tier from RPS score
    fn get_priority_tier(rps: f64) -> PriorityTier {
        if rps >= 70.0 {
            PriorityTier::Critical
        } else if rps >= 40.0 {
            PriorityTier::High
        } else if rps >= 20.0 {
            PriorityTier::Medium
        } else {
            PriorityTier::Low
        }
    }

    /// Generates human-readable explanation of RPS
    fn generate_explanation(factors: &RBREFactors, rps: f64) -> String {
        let mut parts = Vec::new();

        if factors.exploit_probability > 0.7 {
            parts.push(format!(
                "Alta probabilità di exploit (EPSS {:.0}%)",
                factors.exploit_probability * 100.0
            ));
        }

        if factors.asset_criticality > 0.8 {
            parts.push("Asset critico per il business".to_string());
        }

        if factors.exposure_factor > 0.7 {
            parts.push("Esposto a Internet o in DMZ".to_string());
        }

        if factors.technical_severity > 0.7 {
            parts.push(format!(
                "Elevata severità tecnica (CVSS {:.1})",
                factors.technical_severity * 10.0
            ));
        }

        if factors.threat_context > 0.6 {
            parts.push("Exploit pubblico disponibile".to_string());
        }

        if factors.time_factor > 0.7 {
            parts.push("Vulnerabilità aperta da lungo tempo".to_string());
        }

        if parts.is_empty() {
            parts.push("Basso rischio complessivo".to_string());
        }

        let reason = parts.join(" • ");
        format!("RPS {:.0}/100 - {}", rps, reason)
    }

    /// Calculates remediation time estimate
    pub fn estimate_remediation_hours(
        priority_tier: &PriorityTier,
        remediation_difficulty: &str,
        requires_downtime: bool,
    ) -> u16 {
        let difficulty_hours = match remediation_difficulty {
            "trivial" => 2,
            "easy" => 6,
            "medium" => 24,
            "hard" => 80,
            "very_hard" => 200,
            _ => 24,
        };

        let priority_multiplier = match priority_tier {
            PriorityTier::Critical => 1.0,
            PriorityTier::High => 1.0,
            PriorityTier::Medium => 1.2,
            PriorityTier::Low => 1.5,
        };

        let downtime_hours = if requires_downtime { 4 } else { 0 };

        ((difficulty_hours as f64 * priority_multiplier + downtime_hours as f64)
            .round()) as u16
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_critical_vulnerability_rps() {
        // Web server internet-facing with critical CVSS and high EPSS
        let factors = RBREFactors {
            technical_severity: 0.91,      // CVSS 9.1
            exploit_probability: 0.74,     // EPSS 74%
            asset_criticality: 0.9,        // Core business
            exposure_factor: 1.0,          // Internet-facing
            threat_context: 0.8,           // Public exploit
            time_factor: 0.7,              // 45 days open
        };

        let rps = RBRECalculator::calculate_rps(&factors);
        println!("Critical vuln RPS: {}", rps.rps);
        assert!(rps.rps > 30.0 && rps.rps < 50.0);
        assert_eq!(rps.priority_tier, PriorityTier::High);
    }

    #[test]
    fn test_low_risk_vulnerability_rps() {
        let factors = RBREFactors {
            technical_severity: 0.5,       // CVSS 5.0
            exploit_probability: 0.1,      // EPSS 10%
            asset_criticality: 0.3,        // Lab/test
            exposure_factor: 0.2,          // Segmented
            threat_context: 0.3,           // No exploit known
            time_factor: 0.5,              // 20 days
        };

        let rps = RBRECalculator::calculate_rps(&factors);
        println!("Low risk vuln RPS: {}", rps.rps);
        assert!(rps.rps < 5.0);
        assert_eq!(rps.priority_tier, PriorityTier::Low);
    }

    #[test]
    fn test_time_factor_calculation() {
        assert!((RBRECalculator::calculate_time_factor(1) - 0.13).abs() < 0.01);
        assert!((RBRECalculator::calculate_time_factor(30) - 0.69).abs() < 0.01);
        assert!((RBRECalculator::calculate_time_factor(90) - 0.85).abs() < 0.01);
        assert_eq!(RBRECalculator::calculate_time_factor(180), 1.0);
    }

    #[test]
    fn test_remediation_hours_estimate() {
        let hours = RBRECalculator::estimate_remediation_hours(
            &PriorityTier::Critical,
            "easy",
            true,
        );
        assert_eq!(hours, 10); // 6 + 4 downtime
    }
}
