// src/notifications/telegram.rs
// Notifiche via Telegram Bot API

use super::NotificationPayload;
use reqwest::Client;
use serde_json::json;

// Configurare il BOT_TOKEN come variabile d'ambiente
const BOT_TOKEN_ENV: &str = "TELEGRAM_BOT_TOKEN";

pub async fn send_telegram_notification(
    chat_id: &str,
    payload: NotificationPayload,
) -> Result<(), Box<dyn std::error::Error>> {
    let bot_token = std::env::var(BOT_TOKEN_ENV)
        .unwrap_or_else(|_| "YOUR_BOT_TOKEN_HERE".to_string());

    let client = Client::new();

    let severity_emoji = match payload.severity.as_str() {
        "critical" => "ðŸ”´",
        "high" => "ðŸŸ ",
        "medium" => "ðŸŸ¡",
        "low" => "ðŸŸ¢",
        _ => "âšª",
    };

    let message = format!(
        "{} *{}* Vulnerability Detected\n\n\
        *Title:* {}\n\
        *Severity:* {}\n\
        *CVSS Score:* {:.1}\n\
        *IP Address:* {}\n\
        *Assigned Team:* {}\n\n\
        *Description:*\n{}\n\n\
        _Sentinel Core Vulnerability Manager_",
        severity_emoji,
        payload.severity.to_uppercase(),
        payload.title,
        payload.severity.to_uppercase(),
        payload.cvss_score,
        payload.ip_address,
        payload.team_name.unwrap_or_else(|| "Unassigned".to_string()),
        payload.description
    );

    let telegram_url = format!("https://api.telegram.org/bot{}/sendMessage", bot_token);

    let telegram_message = json!({
        "chat_id": chat_id,
        "text": message,
        "parse_mode": "Markdown"
    });

    client
        .post(&telegram_url)
        .json(&telegram_message)
        .send()
        .await?
        .error_for_status()?;

    Ok(())
}
