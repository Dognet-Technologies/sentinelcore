// src/pagination.rs
// Generic pagination support for all list endpoints

use serde::{Deserialize, Serialize};

/// Pagination query parameters
#[derive(Debug, Deserialize, Clone)]
pub struct PaginationParams {
    #[serde(default = "default_offset")]
    pub offset: i64,

    #[serde(default = "default_limit")]
    pub limit: i64,
}

fn default_offset() -> i64 {
    0
}

fn default_limit() -> i64 {
    50
}

impl Default for PaginationParams {
    fn default() -> Self {
        Self {
            offset: 0,
            limit: 50,
        }
    }
}

impl PaginationParams {
    /// Validates and clamps pagination parameters
    /// - offset: must be >= 0
    /// - limit: clamped between 1 and 1000
    pub fn validate(&mut self) {
        if self.offset < 0 {
            self.offset = 0;
        }
        if self.limit < 1 {
            self.limit = 1;
        }
        if self.limit > 1000 {
            self.limit = 1000;
        }
    }

    /// Returns validated offset and limit
    pub fn get_offset_limit(&self) -> (i64, i64) {
        let mut params = self.clone();
        params.validate();
        (params.offset, params.limit)
    }
}

/// Paginated response wrapper
#[derive(Debug, Serialize)]
pub struct PaginatedResponse<T> {
    pub items: Vec<T>,
    pub pagination: PaginationMetadata,
}

/// Pagination metadata included in responses
#[derive(Debug, Serialize)]
pub struct PaginationMetadata {
    pub offset: i64,
    pub limit: i64,
    pub total: i64,
    pub has_more: bool,
}

impl<T> PaginatedResponse<T> {
    pub fn new(items: Vec<T>, offset: i64, limit: i64, total: i64) -> Self {
        let has_more = (offset + items.len() as i64) < total;

        Self {
            items,
            pagination: PaginationMetadata {
                offset,
                limit,
                total,
                has_more,
            },
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_pagination_validation() {
        let mut params = PaginationParams {
            offset: -10,
            limit: 5000,
        };
        params.validate();
        assert_eq!(params.offset, 0);
        assert_eq!(params.limit, 1000);
    }

    #[test]
    fn test_default_pagination() {
        let params = PaginationParams::default();
        assert_eq!(params.offset, 0);
        assert_eq!(params.limit, 50);
    }

    #[test]
    fn test_paginated_response() {
        let items = vec![1, 2, 3];
        let response = PaginatedResponse::new(items, 0, 50, 100);
        assert_eq!(response.pagination.total, 100);
        assert!(response.pagination.has_more);
    }
}
