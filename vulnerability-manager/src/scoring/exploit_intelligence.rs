// src/scoring/exploit_intelligence.rs
// Exploit availability intelligence scoring

use serde::{Deserialize, Serialize};

/// Exploit availability score (0-5 punti)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExploitAvailability {
    pub status: ExploitStatus,
}

impl ExploitAvailability {
    pub fn new(status: ExploitStatus) -> Self {
        Self { status }
    }

    /// Calcola score (0-5 punti)
    pub fn score(&self) -> f32 {
        self.status.score()
    }
}

/// Status di disponibilità exploit
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub enum ExploitStatus {
    PublicExploitActiveCampaigns, // Exploit pubblico + campagne attive → 5 punti
    PublicExploit,                // Exploit pubblico (Metasploit, ExploitDB) → 4 punti
    PoCAvailable,                 // Proof of Concept disponibile → 3 punti
    TheoreticalExploit,           // Exploit teoricamente possibile → 1 punto
    NoExploit,                    // Nessuna info exploit → 0 punti
}

impl ExploitStatus {
    pub fn score(&self) -> f32 {
        match self {
            ExploitStatus::PublicExploitActiveCampaigns => 5.0,
            ExploitStatus::PublicExploit => 4.0,
            ExploitStatus::PoCAvailable => 3.0,
            ExploitStatus::TheoreticalExploit => 1.0,
            ExploitStatus::NoExploit => 0.0,
        }
    }

    pub fn label(&self) -> &'static str {
        match self {
            ExploitStatus::PublicExploitActiveCampaigns => "Public Exploit + Active Campaigns",
            ExploitStatus::PublicExploit => "Public Exploit Available",
            ExploitStatus::PoCAvailable => "PoC Available",
            ExploitStatus::TheoreticalExploit => "Theoretical Exploit",
            ExploitStatus::NoExploit => "No Exploit Info",
        }
    }

    pub fn color(&self) -> &'static str {
        match self {
            ExploitStatus::PublicExploitActiveCampaigns => "#DC2626", // Red
            ExploitStatus::PublicExploit => "#EA580C",                // Orange
            ExploitStatus::PoCAvailable => "#FBBF24",                 // Yellow
            ExploitStatus::TheoreticalExploit => "#3B82F6",           // Blue
            ExploitStatus::NoExploit => "#6B7280",                    // Gray
        }
    }

    /// Determina status da references e metadata
    pub fn from_references(
        references: &[String],
        has_metasploit: bool,
        has_exploit_db: bool,
        in_active_campaigns: bool,
    ) -> Self {
        if in_active_campaigns {
            return ExploitStatus::PublicExploitActiveCampaigns;
        }

        if has_metasploit || has_exploit_db {
            return ExploitStatus::PublicExploit;
        }

        // Check references per PoC keywords
        let ref_text = references.join(" ").to_lowercase();
        if ref_text.contains("poc") || ref_text.contains("proof of concept") || ref_text.contains("exploit") {
            return ExploitStatus::PoCAvailable;
        }

        // Se ci sono references ma nessun exploit
        if !references.is_empty() {
            ExploitStatus::TheoreticalExploit
        } else {
            ExploitStatus::NoExploit
        }
    }
}

/// Metadata exploit intelligence (per enrichment)
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct ExploitMetadata {
    pub metasploit_modules: Vec<String>,
    pub exploit_db_ids: Vec<String>,
    pub poc_urls: Vec<String>,
    pub active_campaigns: Vec<String>,  // Ransomware gangs, APT groups
    pub vendor_advisories: Vec<String>,
    pub cisa_kev: bool, // In CISA Known Exploited Vulnerabilities catalog
}

impl ExploitMetadata {
    pub fn new() -> Self {
        Self::default()
    }

    /// Determina ExploitStatus da metadata
    pub fn status(&self) -> ExploitStatus {
        if !self.active_campaigns.is_empty() || self.cisa_kev {
            ExploitStatus::PublicExploitActiveCampaigns
        } else if !self.metasploit_modules.is_empty() || !self.exploit_db_ids.is_empty() {
            ExploitStatus::PublicExploit
        } else if !self.poc_urls.is_empty() {
            ExploitStatus::PoCAvailable
        } else if !self.vendor_advisories.is_empty() {
            ExploitStatus::TheoreticalExploit
        } else {
            ExploitStatus::NoExploit
        }
    }

    /// Check se è un zero-day (no patch, ma exploit exists)
    pub fn is_zero_day(&self, patch_available: bool) -> bool {
        !patch_available && (
            !self.metasploit_modules.is_empty()
            || !self.exploit_db_ids.is_empty()
            || !self.active_campaigns.is_empty()
        )
    }

    /// Check se targeted da ransomware
    pub fn is_ransomware_targeted(&self) -> bool {
        self.active_campaigns.iter().any(|c| {
            let c_lower = c.to_lowercase();
            c_lower.contains("ransomware")
                || c_lower.contains("lockbit")
                || c_lower.contains("blackcat")
                || c_lower.contains("conti")
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_active_campaigns() {
        let exploit = ExploitAvailability::new(ExploitStatus::PublicExploitActiveCampaigns);
        assert_eq!(exploit.score(), 5.0);
    }

    #[test]
    fn test_public_exploit() {
        let exploit = ExploitAvailability::new(ExploitStatus::PublicExploit);
        assert_eq!(exploit.score(), 4.0);
    }

    #[test]
    fn test_from_references() {
        // Metasploit module
        let status = ExploitStatus::from_references(&[], true, false, false);
        assert_eq!(status, ExploitStatus::PublicExploit);

        // Active campaign
        let status = ExploitStatus::from_references(&[], false, false, true);
        assert_eq!(status, ExploitStatus::PublicExploitActiveCampaigns);

        // PoC in references
        let refs = vec!["https://github.com/user/poc".to_string()];
        let status = ExploitStatus::from_references(&refs, false, false, false);
        assert_eq!(status, ExploitStatus::PoCAvailable);
    }

    #[test]
    fn test_exploit_metadata() {
        let mut meta = ExploitMetadata::new();
        meta.metasploit_modules.push("exploit/windows/smb/ms17_010".to_string());
        meta.active_campaigns.push("WannaCry ransomware".to_string());

        assert_eq!(meta.status(), ExploitStatus::PublicExploitActiveCampaigns);
        assert!(meta.is_ransomware_targeted());
    }

    #[test]
    fn test_zero_day_detection() {
        let mut meta = ExploitMetadata::new();
        meta.metasploit_modules.push("module".to_string());

        // Zero-day: exploit exists, no patch
        assert!(meta.is_zero_day(false));

        // Not zero-day: patch available
        assert!(!meta.is_zero_day(true));
    }
}
