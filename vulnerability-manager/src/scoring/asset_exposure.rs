// src/scoring/asset_exposure.rs
// Asset exposure scoring (network position, attack surface)

use serde::{Deserialize, Serialize};

/// Asset exposure score (0-15 punti)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AssetExposure {
    pub level: ExposureLevel,
    pub critical_ports: Vec<String>, // e.g., ["rdp", "telnet", "smb"]
}

impl AssetExposure {
    pub fn new(level: ExposureLevel, critical_ports: Vec<String>) -> Self {
        Self {
            level,
            critical_ports,
        }
    }

    /// Calcola score (0-15 punti)
    pub fn score(&self) -> f32 {
        let mut score = self.level.base_score();

        // +3 punti se porta critica esposta
        if self.has_critical_ports() {
            score += 3.0;
        }

        score.min(15.0)
    }

    /// Verifica se espone porte critiche
    fn has_critical_ports(&self) -> bool {
        const CRITICAL: &[&str] = &["rdp", "telnet", "smb", "vnc", "ssh"];

        self.critical_ports.iter().any(|port| {
            let port_lower = port.to_lowercase();
            CRITICAL.iter().any(|c| port_lower.contains(c))
        })
    }
}

/// Livelli di esposizione network
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub enum ExposureLevel {
    InternetFacing,  // Esposto pubblicamente → 15 punti
    DMZ,             // DMZ (limited exposure) → 10 punti
    Internal,        // Rete interna → 5 punti
    Isolated,        // Air-gapped/isolato → 0 punti
}

impl ExposureLevel {
    pub fn base_score(&self) -> f32 {
        match self {
            ExposureLevel::InternetFacing => 12.0,
            ExposureLevel::DMZ => 10.0,
            ExposureLevel::Internal => 5.0,
            ExposureLevel::Isolated => 0.0,
        }
    }

    pub fn label(&self) -> &'static str {
        match self {
            ExposureLevel::InternetFacing => "Internet-Facing",
            ExposureLevel::DMZ => "DMZ (Limited Exposure)",
            ExposureLevel::Internal => "Internal Network",
            ExposureLevel::Isolated => "Isolated/Air-Gapped",
        }
    }

    /// Determina exposure level da IP e configurazione
    pub fn from_ip_and_config(
        ip: &str,
        is_public_ip: bool,
        network_zone: Option<&str>,
    ) -> Self {
        // Se IP pubblico → Internet-facing
        if is_public_ip {
            return ExposureLevel::InternetFacing;
        }

        // Se network zone specificato
        if let Some(zone) = network_zone {
            let zone_lower = zone.to_lowercase();
            if zone_lower.contains("dmz") {
                return ExposureLevel::DMZ;
            } else if zone_lower.contains("isolated") || zone_lower.contains("air-gap") {
                return ExposureLevel::Isolated;
            }
        }

        // Check RFC1918 private ranges
        if Self::is_private_ip(ip) {
            ExposureLevel::Internal
        } else {
            ExposureLevel::InternetFacing
        }
    }

    /// Verifica se IP è privato (RFC1918)
    fn is_private_ip(ip: &str) -> bool {
        ip.starts_with("10.")
            || ip.starts_with("192.168.")
            || (ip.starts_with("172.") && {
                // 172.16.0.0 - 172.31.255.255
                ip.split('.').nth(1).and_then(|s| s.parse::<u8>().ok())
                    .map(|octet| octet >= 16 && octet <= 31)
                    .unwrap_or(false)
            })
            || ip.starts_with("127.")  // Localhost
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_internet_facing_with_rdp() {
        let exposure = AssetExposure::new(
            ExposureLevel::InternetFacing,
            vec!["rdp".to_string(), "http".to_string()],
        );

        let score = exposure.score();
        assert_eq!(score, 15.0); // 12 + 3 (critical port)
    }

    #[test]
    fn test_internal_no_critical_ports() {
        let exposure = AssetExposure::new(
            ExposureLevel::Internal,
            vec!["http".to_string()],
        );

        let score = exposure.score();
        assert_eq!(score, 5.0); // Only base score
    }

    #[test]
    fn test_private_ip_detection() {
        assert!(ExposureLevel::is_private_ip("192.168.1.1"));
        assert!(ExposureLevel::is_private_ip("10.0.0.1"));
        assert!(ExposureLevel::is_private_ip("172.16.0.1"));
        assert!(ExposureLevel::is_private_ip("172.31.255.254"));
        assert!(!ExposureLevel::is_private_ip("8.8.8.8"));
        assert!(!ExposureLevel::is_private_ip("172.32.0.1")); // Outside range
    }

    #[test]
    fn test_exposure_from_config() {
        // Public IP
        let level = ExposureLevel::from_ip_and_config("8.8.8.8", true, None);
        assert_eq!(level, ExposureLevel::InternetFacing);

        // Private IP in DMZ
        let level = ExposureLevel::from_ip_and_config("192.168.1.1", false, Some("DMZ"));
        assert_eq!(level, ExposureLevel::DMZ);

        // Private IP internal
        let level = ExposureLevel::from_ip_and_config("10.0.0.1", false, None);
        assert_eq!(level, ExposureLevel::Internal);
    }
}
