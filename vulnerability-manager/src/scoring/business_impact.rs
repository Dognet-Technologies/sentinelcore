// src/scoring/business_impact.rs
// Business impact scoring per risk calculation

use serde::{Deserialize, Serialize};

/// Business impact score (0-25 punti)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BusinessImpact {
    pub criticality: AssetCriticality,
    pub has_sensitive_data: bool,  // PII/PCI/PHI
    pub revenue_impact_per_hour: f32, // €/hour downtime cost
}

impl BusinessImpact {
    pub fn new(
        criticality: AssetCriticality,
        has_sensitive_data: bool,
        revenue_impact_per_hour: f32,
    ) -> Self {
        Self {
            criticality,
            has_sensitive_data,
            revenue_impact_per_hour,
        }
    }

    /// Calcola score (0-25 punti)
    pub fn score(&self) -> f32 {
        let mut score = 0.0;

        // Asset criticality (base: 0-15 punti)
        score += self.criticality.base_score();

        // Data sensitivity (+5 punti se PII/PCI/PHI)
        if self.has_sensitive_data {
            score += 5.0;
        }

        // Revenue impact (+5 punti se >€10k/ora)
        if self.revenue_impact_per_hour > 10000.0 {
            score += 5.0;
        }

        score.min(25.0)
    }
}

/// Asset criticality levels
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub enum AssetCriticality {
    Critical,  // Payment processing, auth, core infra → 25 punti
    High,      // Production web/API, databases → 18 punti
    Medium,    // Internal tools, staging → 10 punti
    Low,       // Dev/test environments → 3 punti
}

impl AssetCriticality {
    pub fn base_score(&self) -> f32 {
        match self {
            AssetCriticality::Critical => 15.0,
            AssetCriticality::High => 11.0,
            AssetCriticality::Medium => 6.0,
            AssetCriticality::Low => 2.0,
        }
    }

    pub fn label(&self) -> &'static str {
        match self {
            AssetCriticality::Critical => "Critical (Payment/Auth/Core)",
            AssetCriticality::High => "High (Production Web/API)",
            AssetCriticality::Medium => "Medium (Internal Tools)",
            AssetCriticality::Low => "Low (Dev/Test)",
        }
    }

    /// Determina criticality da tags asset
    pub fn from_tags(tags: &[String]) -> Self {
        let tags_lower: Vec<String> = tags.iter().map(|t| t.to_lowercase()).collect();

        if tags_lower.iter().any(|t| t.contains("payment") || t.contains("auth") || t.contains("critical")) {
            AssetCriticality::Critical
        } else if tags_lower.iter().any(|t| t.contains("production") || t.contains("prod") || t.contains("api")) {
            AssetCriticality::High
        } else if tags_lower.iter().any(|t| t.contains("staging") || t.contains("internal")) {
            AssetCriticality::Medium
        } else {
            AssetCriticality::Low
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_critical_asset() {
        let impact = BusinessImpact::new(
            AssetCriticality::Critical,
            true,   // PII data
            15000.0 // €15k/hour
        );

        let score = impact.score();
        assert_eq!(score, 25.0); // Max score: 15 + 5 + 5
    }

    #[test]
    fn test_medium_asset() {
        let impact = BusinessImpact::new(
            AssetCriticality::Medium,
            false,
            2000.0
        );

        let score = impact.score();
        assert_eq!(score, 6.0); // Only criticality: 6 + 0 + 0
    }

    #[test]
    fn test_criticality_from_tags() {
        let tags = vec!["production".to_string(), "api".to_string()];
        let crit = AssetCriticality::from_tags(&tags);
        assert_eq!(crit, AssetCriticality::High);

        let tags = vec!["payment-gateway".to_string()];
        let crit = AssetCriticality::from_tags(&tags);
        assert_eq!(crit, AssetCriticality::Critical);
    }
}
