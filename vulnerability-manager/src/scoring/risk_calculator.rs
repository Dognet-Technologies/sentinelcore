// src/scoring/risk_calculator.rs
// Core risk calculation engine implementing intelligent prioritization

use serde::{Deserialize, Serialize};
use super::{BusinessImpact, AssetExposure, ExploitAvailability};

/// Final risk score (0-100)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RiskScore {
    pub total: u8,              // 0-100
    pub cvss_component: f32,    // 0-30
    pub epss_component: f32,    // 0-25
    pub business_component: f32, // 0-25
    pub exposure_component: f32, // 0-15
    pub exploit_component: f32,  // 0-5
    pub tier: RiskTier,
    pub sla_days: u16,          // SLA in giorni
}

/// Risk priority tiers con SLA automatici
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub enum RiskTier {
    Critical,   // 80-100: P1 - Remediate entro 24h (1 giorno)
    High,       // 60-79:  P2 - Remediate entro 7 giorni
    Medium,     // 40-59:  P3 - Remediate entro 30 giorni
    Low,        // 20-39:  P4 - Remediate entro 90 giorni
    Info,       // 0-19:   Monitor, no SLA
}

impl RiskTier {
    /// Determina tier basato su score
    pub fn from_score(score: u8) -> Self {
        match score {
            80..=100 => RiskTier::Critical,
            60..=79 => RiskTier::High,
            40..=59 => RiskTier::Medium,
            20..=39 => RiskTier::Low,
            _ => RiskTier::Info,
        }
    }

    /// SLA in giorni per questo tier
    pub fn sla_days(&self) -> u16 {
        match self {
            RiskTier::Critical => 1,    // 24 ore
            RiskTier::High => 7,        // 1 settimana
            RiskTier::Medium => 30,     // 1 mese
            RiskTier::Low => 90,        // 3 mesi
            RiskTier::Info => 0,        // Nessun SLA
        }
    }

    /// Label testuale per UI
    pub fn label(&self) -> &'static str {
        match self {
            RiskTier::Critical => "Critical",
            RiskTier::High => "High",
            RiskTier::Medium => "Medium",
            RiskTier::Low => "Low",
            RiskTier::Info => "Informational",
        }
    }

    /// Colore per UI (hex)
    pub fn color(&self) -> &'static str {
        match self {
            RiskTier::Critical => "#DC2626", // Red-600
            RiskTier::High => "#EA580C",     // Orange-600
            RiskTier::Medium => "#FBBF24",   // Yellow-400
            RiskTier::Low => "#3B82F6",      // Blue-500
            RiskTier::Info => "#6B7280",     // Gray-500
        }
    }
}

/// Main risk calculator
pub struct RiskCalculator;

impl RiskCalculator {
    /// Calcola risk score completo
    ///
    /// Formula: Risk Score (0-100) =
    ///   (CVSS Base × 0.30) +
    ///   (EPSS Score × 0.25) +
    ///   (Business Impact × 0.25) +
    ///   (Asset Exposure × 0.15) +
    ///   (Exploit Availability × 0.05)
    pub fn calculate(
        cvss_score: f32,                      // 0.0-10.0
        epss_score: f32,                      // 0.0-1.0 (0-100%)
        business_impact: BusinessImpact,
        asset_exposure: AssetExposure,
        exploit_availability: ExploitAvailability,
    ) -> RiskScore {
        // 1. CVSS Base Component (0-30 punti)
        let cvss_component = Self::calculate_cvss_component(cvss_score);

        // 2. EPSS Score Component (0-25 punti)
        let epss_component = Self::calculate_epss_component(epss_score);

        // 3. Business Impact Component (0-25 punti)
        let business_component = business_impact.score();

        // 4. Asset Exposure Component (0-15 punti)
        let exposure_component = asset_exposure.score();

        // 5. Exploit Availability Component (0-5 punti)
        let exploit_component = exploit_availability.score();

        // Total risk score
        let total = (cvss_component + epss_component + business_component
                   + exposure_component + exploit_component)
            .round()
            .min(100.0) as u8;

        let tier = RiskTier::from_score(total);
        let sla_days = tier.sla_days();

        RiskScore {
            total,
            cvss_component,
            epss_component,
            business_component,
            exposure_component,
            exploit_component,
            tier,
            sla_days,
        }
    }

    /// CVSS scoring (0-30 punti)
    ///
    /// - Critical (9.0-10.0): 30 punti
    /// - High (7.0-8.9): 22 punti
    /// - Medium (4.0-6.9): 15 punti
    /// - Low (0.1-3.9): 5 punti
    fn calculate_cvss_component(cvss: f32) -> f32 {
        match cvss {
            9.0..=10.0 => 30.0,
            7.0..=8.9 => 22.0,
            4.0..=6.9 => 15.0,
            0.1..=3.9 => 5.0,
            _ => 0.0,
        }
    }

    /// EPSS scoring (0-25 punti)
    ///
    /// - EPSS >50% (high probability): 25 punti
    /// - EPSS 20-50%: 18 punti
    /// - EPSS 5-20%: 10 punti
    /// - EPSS <5%: 3 punti
    fn calculate_epss_component(epss: f32) -> f32 {
        match epss {
            0.50..=1.0 => 25.0,
            0.20..=0.49 => 18.0,
            0.05..=0.19 => 10.0,
            0.0..=0.04 => 3.0,
            _ => 0.0,
        }
    }

    /// Calcola priority override per scenari speciali
    pub fn apply_overrides(
        score: &mut RiskScore,
        is_zero_day: bool,
        is_ransomware_targeted: bool,
        is_compliance_critical: bool,
        is_actively_exploited: bool,
    ) {
        // Zero-day: Auto-escalate a Critical
        if is_zero_day {
            score.total = score.total.max(90);
            score.tier = RiskTier::Critical;
            score.sla_days = 1;
        }

        // Ransomware targeted: Critical
        if is_ransomware_targeted {
            score.total = score.total.max(85);
            score.tier = RiskTier::Critical;
            score.sla_days = 1;
        }

        // Active exploitation confirmed: +20 punti
        if is_actively_exploited {
            score.total = (score.total + 20).min(100);
            score.tier = RiskTier::from_score(score.total);
            score.sla_days = score.tier.sla_days();
        }

        // Compliance mandate: Force P1
        if is_compliance_critical {
            score.total = score.total.max(80);
            score.tier = RiskTier::Critical;
            score.sla_days = 7; // 7 giorni per compliance
        }
    }

    /// Stima effort di remediation
    pub fn estimate_remediation_effort(
        patch_available: bool,
        requires_reboot: bool,
        requires_config_change: bool,
        requires_testing: bool,
        vendor_responsive: bool,
    ) -> RemediationEffort {
        match (patch_available, requires_reboot, requires_config_change, requires_testing, vendor_responsive) {
            // Trivial: patch + reboot, that's it
            (true, true, false, false, _) => RemediationEffort::Trivial,

            // Easy: patch + minimal config
            (true, _, true, false, _) => RemediationEffort::Easy,

            // Medium: patch + testing + coordination
            (true, _, _, true, _) => RemediationEffort::Medium,

            // Hard: workaround, vendor slow
            (false, _, _, _, false) => RemediationEffort::Hard,

            // Very Hard: architectural change, no fix
            (false, _, _, _, _) => RemediationEffort::VeryHard,

            // Default: Easy
            _ => RemediationEffort::Easy,
        }
    }
}

/// Stima sforzo remediation
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub enum RemediationEffort {
    Trivial,   // 1-2 ore (patch + reboot)
    Easy,      // 4-8 ore (patch + config)
    Medium,    // 1-3 giorni (patch + testing + coordination)
    Hard,      // 1-2 settimane (workaround, vendor issues)
    VeryHard,  // >1 mese (architectural change, no fix)
}

impl RemediationEffort {
    /// Ore stimate per remediation
    pub fn estimated_hours(&self) -> u16 {
        match self {
            RemediationEffort::Trivial => 2,
            RemediationEffort::Easy => 6,
            RemediationEffort::Medium => 24,    // 3 giorni × 8h
            RemediationEffort::Hard => 80,      // 2 settimane × 40h
            RemediationEffort::VeryHard => 200, // >1 mese
        }
    }

    pub fn label(&self) -> &'static str {
        match self {
            RemediationEffort::Trivial => "Trivial (1-2h)",
            RemediationEffort::Easy => "Easy (4-8h)",
            RemediationEffort::Medium => "Medium (1-3 days)",
            RemediationEffort::Hard => "Hard (1-2 weeks)",
            RemediationEffort::VeryHard => "Very Hard (>1 month)",
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::scoring::business_impact::AssetCriticality;
    use crate::scoring::asset_exposure::ExposureLevel;
    use crate::scoring::exploit_intelligence::ExploitStatus;

    #[test]
    fn test_critical_vulnerability() {
        // Critical CVSS, high EPSS, critical asset, internet-facing
        let score = RiskCalculator::calculate(
            9.8,  // CVSS Critical
            0.75, // EPSS 75% (very high)
            BusinessImpact::new(AssetCriticality::Critical, true, 50000.0),
            AssetExposure::new(ExposureLevel::InternetFacing, vec!["rdp".to_string()]),
            ExploitAvailability::new(ExploitStatus::PublicExploitActiveCampaigns),
        );

        assert_eq!(score.tier, RiskTier::Critical);
        assert!(score.total >= 80);
        assert_eq!(score.sla_days, 1);
    }

    #[test]
    fn test_medium_vulnerability() {
        // Medium CVSS, low EPSS, medium asset, internal
        let score = RiskCalculator::calculate(
            5.5,  // CVSS Medium
            0.08, // EPSS 8%
            BusinessImpact::new(AssetCriticality::Medium, false, 0.0),
            AssetExposure::new(ExposureLevel::Internal, vec![]),
            ExploitAvailability::new(ExploitStatus::TheoreticalExploit),
        );

        assert_eq!(score.tier, RiskTier::Medium);
        assert!(score.total >= 40 && score.total < 60);
        assert_eq!(score.sla_days, 30);
    }

    #[test]
    fn test_zero_day_override() {
        // Even low score becomes Critical if zero-day
        let mut score = RiskCalculator::calculate(
            3.0,
            0.02,
            BusinessImpact::new(AssetCriticality::Low, false, 0.0),
            AssetExposure::new(ExposureLevel::Internal, vec![]),
            ExploitAvailability::new(ExploitStatus::NoExploit),
        );

        RiskCalculator::apply_overrides(&mut score, true, false, false, false);

        assert_eq!(score.tier, RiskTier::Critical);
        assert!(score.total >= 90);
    }

    #[test]
    fn test_remediation_effort() {
        // Trivial: patch available, just reboot
        let effort = RiskCalculator::estimate_remediation_effort(
            true, true, false, false, true
        );
        assert_eq!(effort, RemediationEffort::Trivial);
        assert_eq!(effort.estimated_hours(), 2);

        // Very Hard: no patch, vendor unresponsive
        let effort = RiskCalculator::estimate_remediation_effort(
            false, false, false, false, false
        );
        assert_eq!(effort, RemediationEffort::VeryHard);
        assert!(effort.estimated_hours() > 100);
    }
}
