// src/middleware/jwt_cookie.rs
use axum::{
    http::StatusCode,
    response::{IntoResponse, Response},
};
use tower_cookies::{Cookie, Cookies};
use time::Duration;
use crate::config::CookieConfig;

pub const JWT_COOKIE_NAME: &str = "auth_token";
pub const REFRESH_TOKEN_COOKIE_NAME: &str = "refresh_token";

/// Set JWT token as httpOnly cookie
pub fn set_jwt_cookie(cookies: &Cookies, token: &str, config: &CookieConfig) {
    let mut cookie = Cookie::new(JWT_COOKIE_NAME, token.to_string());

    cookie.set_path(&config.path);
    cookie.set_max_age(Duration::seconds(config.max_age_seconds));
    cookie.set_secure(config.secure);
    cookie.set_http_only(config.http_only);

    if let Some(ref domain) = config.domain {
        cookie.set_domain(domain.clone());
    }

    match config.same_site.as_str() {
        "Strict" => cookie.set_same_site(tower_cookies::cookie::SameSite::Strict),
        "Lax" => cookie.set_same_site(tower_cookies::cookie::SameSite::Lax),
        "None" => cookie.set_same_site(tower_cookies::cookie::SameSite::None),
        _ => cookie.set_same_site(tower_cookies::cookie::SameSite::Lax),
    }

    cookies.add(cookie);
}

/// Set refresh token as httpOnly cookie
pub fn set_refresh_token_cookie(cookies: &Cookies, token: &str, config: &CookieConfig, duration_hours: i64) {
    let mut cookie = Cookie::new(REFRESH_TOKEN_COOKIE_NAME, token.to_string());

    cookie.set_path(&config.path);
    cookie.set_max_age(Duration::hours(duration_hours));
    cookie.set_secure(config.secure);
    cookie.set_http_only(true); // Refresh tokens should ALWAYS be httpOnly

    if let Some(ref domain) = config.domain {
        cookie.set_domain(domain.clone());
    }

    match config.same_site.as_str() {
        "Strict" => cookie.set_same_site(tower_cookies::cookie::SameSite::Strict),
        "Lax" => cookie.set_same_site(tower_cookies::cookie::SameSite::Lax),
        "None" => cookie.set_same_site(tower_cookies::cookie::SameSite::None),
        _ => cookie.set_same_site(tower_cookies::cookie::SameSite::Strict),
    }

    cookies.add(cookie);
}

/// Get JWT token from cookie
pub fn get_jwt_cookie(cookies: &Cookies) -> Option<String> {
    cookies.get(JWT_COOKIE_NAME).map(|c| c.value().to_string())
}

/// Get refresh token from cookie
pub fn get_refresh_token_cookie(cookies: &Cookies) -> Option<String> {
    cookies.get(REFRESH_TOKEN_COOKIE_NAME).map(|c| c.value().to_string())
}

/// Clear authentication cookies (logout)
pub fn clear_auth_cookies(cookies: &Cookies, config: &CookieConfig) {
    let mut jwt_cookie = Cookie::new(JWT_COOKIE_NAME, "");
    jwt_cookie.set_path(&config.path);
    jwt_cookie.set_max_age(Duration::seconds(-1)); // Expire immediately
    if let Some(ref domain) = config.domain {
        jwt_cookie.set_domain(domain.clone());
    }
    cookies.remove(jwt_cookie);

    let mut refresh_cookie = Cookie::new(REFRESH_TOKEN_COOKIE_NAME, "");
    refresh_cookie.set_path(&config.path);
    refresh_cookie.set_max_age(Duration::seconds(-1));
    if let Some(ref domain) = config.domain {
        refresh_cookie.set_domain(domain.clone());
    }
    cookies.remove(refresh_cookie);
}

/// Error response for cookie-related errors
pub fn cookie_error_response(message: &str) -> Response {
    (StatusCode::UNAUTHORIZED, message).into_response()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_cookie_names() {
        assert_eq!(JWT_COOKIE_NAME, "auth_token");
        assert_eq!(REFRESH_TOKEN_COOKIE_NAME, "refresh_token");
    }
}
