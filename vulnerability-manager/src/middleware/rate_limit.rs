// src/middleware/rate_limit.rs
use axum::{
    body::Body,
    http::{StatusCode, Request},
    middleware::Next,
    response::{IntoResponse, Response},
};
use std::collections::HashMap;
use std::net::IpAddr;
use std::sync::Arc;
use std::time::{Duration, Instant};
use tokio::sync::RwLock;
use tracing::{debug, warn};

/// Rate limiter state for tracking requests
#[derive(Clone)]
pub struct RateLimiter {
    state: Arc<RwLock<RateLimiterState>>,
    requests_per_minute: u32,
    burst_size: u32,
}

struct RateLimiterState {
    /// Map of IP address to request count and window start time
    requests: HashMap<IpAddr, (u32, Instant)>,
}

impl RateLimiter {
    pub fn new(requests_per_minute: u32, burst_size: u32) -> Self {
        Self {
            state: Arc::new(RwLock::new(RateLimiterState {
                requests: HashMap::new(),
            })),
            requests_per_minute,
            burst_size,
        }
    }

    /// Check if a request from the given IP should be allowed
    pub async fn check_rate_limit(&self, ip: IpAddr) -> bool {
        let mut state = self.state.write().await;
        let now = Instant::now();
        let window = Duration::from_secs(60);

        let entry = state.requests.entry(ip).or_insert((0, now));
        let (count, window_start) = entry;

        // Reset counter if window expired
        if now.duration_since(*window_start) >= window {
            *count = 1;
            *window_start = now;
            debug!("Rate limit reset for IP: {}", ip);
            return true;
        }

        // Check if burst limit exceeded
        if *count >= self.burst_size {
            warn!("Rate limit exceeded for IP: {} (burst)", ip);
            return false;
        }

        // Check if rate limit exceeded
        let elapsed_secs = now.duration_since(*window_start).as_secs() as f64;
        let rate = (*count as f64) / (elapsed_secs / 60.0);

        if rate >= self.requests_per_minute as f64 {
            warn!("Rate limit exceeded for IP: {} (rate)", ip);
            return false;
        }

        *count += 1;
        true
    }

    /// Clean up old entries periodically
    pub async fn cleanup_old_entries(&self) {
        let mut state = self.state.write().await;
        let now = Instant::now();
        let window = Duration::from_secs(60);

        state.requests.retain(|_ip, (_, window_start)| {
            now.duration_since(*window_start) < window * 2
        });

        debug!("Cleaned up rate limiter state, {} entries remaining", state.requests.len());
    }
}

/// Middleware function for rate limiting
pub async fn rate_limit_middleware(
    req: Request,
    next: Next,
    limiter: RateLimiter,
) -> Response {
    // Extract IP address from request
    let ip = extract_ip_from_request(&req);

    // Check rate limit
    if !limiter.check_rate_limit(ip).await {
        return (
            StatusCode::TOO_MANY_REQUESTS,
            "Rate limit exceeded. Please try again later.",
        )
            .into_response();
    }

    next.run(req).await
}

/// Extract IP address from request
fn extract_ip_from_request(req: &Request) -> IpAddr {
    // Try to get IP from X-Forwarded-For header first (for proxies)
    if let Some(forwarded) = req.headers().get("x-forwarded-for") {
        if let Ok(forwarded_str) = forwarded.to_str() {
            if let Some(ip_str) = forwarded_str.split(',').next() {
                if let Ok(ip) = ip_str.trim().parse() {
                    return ip;
                }
            }
        }
    }

    // Try to get IP from X-Real-IP header
    if let Some(real_ip) = req.headers().get("x-real-ip") {
        if let Ok(ip_str) = real_ip.to_str() {
            if let Ok(ip) = ip_str.parse() {
                return ip;
            }
        }
    }

    // Fallback: try to get from connection info (not always available in Axum)
    // Default to localhost if unable to extract
    IpAddr::from([127, 0, 0, 1])
}

/// Create a rate limiter layer for use with Axum
pub fn create_rate_limiter_layer(
    requests_per_minute: u32,
    burst_size: u32,
) -> (RateLimiter, impl Fn(Request, Next) -> std::pin::Pin<Box<dyn std::future::Future<Output = Response> + Send>> + Clone) {
    let limiter = RateLimiter::new(requests_per_minute, burst_size);
    let limiter_clone = limiter.clone();

    let middleware_fn = move |req: Request, next: Next| {
        let limiter = limiter_clone.clone();
        Box::pin(async move {
            rate_limit_middleware(req, next, limiter).await
        })
    };

    (limiter, middleware_fn)
}

/// Spawn a background task to clean up old rate limiter entries
pub fn spawn_cleanup_task(limiter: RateLimiter) {
    tokio::spawn(async move {
        let mut interval = tokio::time::interval(Duration::from_secs(120));
        loop {
            interval.tick().await;
            limiter.cleanup_old_entries().await;
        }
    });
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_rate_limiter_allows_requests() {
        let limiter = RateLimiter::new(10, 20);
        let ip = "127.0.0.1".parse().unwrap();

        // First request should be allowed
        assert!(limiter.check_rate_limit(ip).await);
    }

    #[tokio::test]
    async fn test_rate_limiter_blocks_burst() {
        let limiter = RateLimiter::new(10, 5);
        let ip = "127.0.0.1".parse().unwrap();

        // Allow up to burst size
        for _ in 0..5 {
            assert!(limiter.check_rate_limit(ip).await);
        }

        // Next request should be blocked
        assert!(!limiter.check_rate_limit(ip).await);
    }

    #[tokio::test]
    async fn test_rate_limiter_resets_after_window() {
        let limiter = RateLimiter::new(1, 2);
        let ip = "127.0.0.1".parse().unwrap();

        // Use up the burst
        assert!(limiter.check_rate_limit(ip).await);
        assert!(limiter.check_rate_limit(ip).await);
        assert!(!limiter.check_rate_limit(ip).await);

        // Wait for window to expire
        tokio::time::sleep(Duration::from_secs(61)).await;

        // Should be allowed again
        assert!(limiter.check_rate_limit(ip).await);
    }
}
