// src/middleware/csrf.rs
use axum::{
    body::Body,
    extract::State,
    http::{StatusCode, header, HeaderMap, Request},
    middleware::Next,
    response::{IntoResponse, Response},
};
use axum::response::Html;
use rand::Rng;
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use tower_cookies::{Cookie, Cookies};
use time::Duration;
use crate::config::CsrfConfig;

/// CSRF token storage
#[derive(Clone)]
pub struct CsrfState {
    tokens: Arc<RwLock<HashMap<String, std::time::Instant>>>,
    config: CsrfConfig,
}

impl CsrfState {
    pub fn new(config: CsrfConfig) -> Self {
        Self {
            tokens: Arc::new(RwLock::new(HashMap::new())),
            config,
        }
    }

    /// Generate a new CSRF token
    pub async fn generate_token(&self) -> String {
        let token = generate_random_token(self.config.token_length);
        let mut tokens = self.tokens.write().await;
        tokens.insert(token.clone(), std::time::Instant::now());
        token
    }

    /// Validate a CSRF token
    pub async fn validate_token(&self, token: &str) -> bool {
        let mut tokens = self.tokens.write().await;

        if let Some(created_at) = tokens.get(token) {
            // Token is valid for 1 hour
            if created_at.elapsed().as_secs() < 3600 {
                return true;
            } else {
                // Remove expired token
                tokens.remove(token);
            }
        }

        false
    }

    /// Clean up expired tokens
    pub async fn cleanup_expired_tokens(&self) {
        let mut tokens = self.tokens.write().await;
        tokens.retain(|_, created_at| created_at.elapsed().as_secs() < 3600);
    }
}

/// Generate a random token
fn generate_random_token(length: usize) -> String {
    const CHARSET: &[u8] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    let mut rng = rand::thread_rng();

    (0..length)
        .map(|_| {
            let idx = rng.gen_range(0..CHARSET.len());
            CHARSET[idx] as char
        })
        .collect()
}

/// Middleware to add CSRF token to responses
pub async fn csrf_middleware(
    cookies: Cookies,
    csrf_state: State<CsrfState>,
    req: Request,
    next: Next,
) -> Response {
    // Generate CSRF token if not present
    let csrf_token = if let Some(cookie) = cookies.get(&csrf_state.config.cookie_name) {
        cookie.value().to_string()
    } else {
        let token = csrf_state.generate_token().await;

        // Set CSRF cookie
        let mut cookie = Cookie::new(csrf_state.config.cookie_name.clone(), token.clone());
        cookie.set_path("/");
        cookie.set_max_age(Duration::hours(1));
        cookie.set_secure(csrf_state.config.secure_cookie);
        cookie.set_http_only(csrf_state.config.http_only);

        match csrf_state.config.same_site.as_str() {
            "Strict" => cookie.set_same_site(tower_cookies::cookie::SameSite::Strict),
            "Lax" => cookie.set_same_site(tower_cookies::cookie::SameSite::Lax),
            "None" => cookie.set_same_site(tower_cookies::cookie::SameSite::None),
            _ => cookie.set_same_site(tower_cookies::cookie::SameSite::Lax),
        }

        cookies.add(cookie);
        token
    };

    // Continue with request
    next.run(req).await
}

/// Middleware to validate CSRF token on state-changing requests
pub async fn validate_csrf_middleware(
    cookies: Cookies,
    headers: HeaderMap,
    csrf_state: State<CsrfState>,
    req: Request,
    next: Next,
) -> Result<Response, StatusCode> {
    let method = req.method().clone();

    // Only validate on state-changing methods
    if !matches!(method.as_str(), "POST" | "PUT" | "DELETE" | "PATCH") {
        return Ok(next.run(req).await);
    }

    // Get token from header
    let header_token = headers
        .get(&csrf_state.config.header_name)
        .and_then(|h| h.to_str().ok())
        .map(|s| s.to_string());

    // Get token from cookie
    let cookie_token = cookies
        .get(&csrf_state.config.cookie_name)
        .map(|c| c.value().to_string());

    // Both must be present and match
    if let (Some(header_token), Some(cookie_token)) = (header_token, cookie_token) {
        if header_token == cookie_token {
            // Validate token exists in our store
            if csrf_state.validate_token(&header_token).await {
                return Ok(next.run(req).await);
            }
        }
    }

    // CSRF validation failed
    Err(StatusCode::FORBIDDEN)
}

/// Spawn a background task to clean up expired CSRF tokens
pub fn spawn_csrf_cleanup_task(csrf_state: CsrfState) {
    tokio::spawn(async move {
        let mut interval = tokio::time::interval(std::time::Duration::from_secs(300)); // Every 5 minutes
        loop {
            interval.tick().await;
            csrf_state.cleanup_expired_tokens().await;
        }
    });
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_random_token() {
        let token1 = generate_random_token(32);
        let token2 = generate_random_token(32);

        assert_eq!(token1.len(), 32);
        assert_eq!(token2.len(), 32);
        assert_ne!(token1, token2);
    }

    #[tokio::test]
    async fn test_csrf_state() {
        let config = CsrfConfig {
            enabled: true,
            cookie_name: "XSRF-TOKEN".to_string(),
            header_name: "X-CSRF-Token".to_string(),
            token_length: 32,
            secure_cookie: true,
            http_only: false,
            same_site: "Strict".to_string(),
        };

        let state = CsrfState::new(config);

        let token = state.generate_token().await;
        assert!(state.validate_token(&token).await);
        assert!(!state.validate_token("invalid").await);
    }
}
