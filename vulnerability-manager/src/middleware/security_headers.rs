// src/middleware/security_headers.rs
use axum::{
    body::Body,
    http::{Request, header},
    middleware::Next,
    response::{Response, IntoResponse},
};
use crate::config::SecurityHeadersConfig;

/// Middleware to add security headers to all responses
pub async fn add_security_headers<B>(
    req: Request<B>,
    next: Next<B>,
    config: SecurityHeadersConfig,
) -> Response {
    let mut response = next.run(req).await;
    let headers = response.headers_mut();

    // Strict-Transport-Security (HSTS)
    let hsts_value = if config.hsts_preload {
        format!(
            "max-age={}; includeSubDomains; preload",
            config.hsts_max_age_seconds
        )
    } else if config.hsts_include_subdomains {
        format!(
            "max-age={}; includeSubDomains",
            config.hsts_max_age_seconds
        )
    } else {
        format!("max-age={}", config.hsts_max_age_seconds)
    };

    if let Ok(value) = hsts_value.parse() {
        headers.insert(header::STRICT_TRANSPORT_SECURITY, value);
    }

    // X-Frame-Options
    if let Ok(value) = config.frame_options.parse() {
        headers.insert(header::X_FRAME_OPTIONS, value);
    }

    // X-Content-Type-Options
    if let Ok(value) = config.content_type_options.parse() {
        headers.insert(header::X_CONTENT_TYPE_OPTIONS, value);
    }

    // X-XSS-Protection
    if let Ok(value) = config.xss_protection.parse() {
        headers.insert(header::X_XSS_PROTECTION, value);
    }

    // Referrer-Policy
    if let Ok(value) = config.referrer_policy.parse() {
        headers.insert(header::REFERRER_POLICY, value);
    }

    // Content-Security-Policy
    if let Some(csp) = config.csp {
        if let Ok(value) = csp.parse() {
            headers.insert(header::CONTENT_SECURITY_POLICY, value);
        }
    }

    // Permissions-Policy
    if let Some(permissions) = config.permissions_policy {
        if let Ok(value) = permissions.parse() {
            headers.insert(header::HeaderName::from_static("permissions-policy"), value);
        }
    }

    response
}

/// Apply security headers to a response (synchronous version for map_response)
pub fn apply_security_headers(response: &mut Response, config: &SecurityHeadersConfig) {
    let headers = response.headers_mut();

    // Strict-Transport-Security (HSTS)
    let hsts_value = if config.hsts_preload {
        format!(
            "max-age={}; includeSubDomains; preload",
            config.hsts_max_age_seconds
        )
    } else if config.hsts_include_subdomains {
        format!(
            "max-age={}; includeSubDomains",
            config.hsts_max_age_seconds
        )
    } else {
        format!("max-age={}", config.hsts_max_age_seconds)
    };

    if let Ok(value) = hsts_value.parse() {
        headers.insert(header::STRICT_TRANSPORT_SECURITY, value);
    }

    // X-Frame-Options
    if let Ok(value) = config.frame_options.parse() {
        headers.insert(header::X_FRAME_OPTIONS, value);
    }

    // X-Content-Type-Options
    if let Ok(value) = config.content_type_options.parse() {
        headers.insert(header::X_CONTENT_TYPE_OPTIONS, value);
    }

    // X-XSS-Protection
    if let Ok(value) = config.xss_protection.parse() {
        headers.insert(header::X_XSS_PROTECTION, value);
    }

    // Referrer-Policy
    if let Ok(value) = config.referrer_policy.parse() {
        headers.insert(header::REFERRER_POLICY, value);
    }

    // Content-Security-Policy
    if let Some(ref csp) = config.csp {
        if let Ok(value) = csp.parse() {
            headers.insert(header::CONTENT_SECURITY_POLICY, value);
        }
    }

    // Permissions-Policy
    if let Some(ref permissions) = config.permissions_policy {
        if let Ok(value) = permissions.parse() {
            headers.insert(header::HeaderName::from_static("permissions-policy"), value);
        }
    }
}

/// Creates a middleware layer for security headers
pub fn security_headers_layer<B>(
    config: SecurityHeadersConfig,
) -> axum::middleware::MapResponseLayer<impl FnMut(Response) -> Response + Clone> {
    axum::middleware::map_response(move |mut response: Response| {
        let headers = response.headers_mut();

        // Strict-Transport-Security (HSTS)
        let hsts_value = if config.hsts_preload {
            format!(
                "max-age={}; includeSubDomains; preload",
                config.hsts_max_age_seconds
            )
        } else if config.hsts_include_subdomains {
            format!(
                "max-age={}; includeSubDomains",
                config.hsts_max_age_seconds
            )
        } else {
            format!("max-age={}", config.hsts_max_age_seconds)
        };

        if let Ok(value) = hsts_value.parse() {
            headers.insert(header::STRICT_TRANSPORT_SECURITY, value);
        }

        // X-Frame-Options
        if let Ok(value) = config.frame_options.parse() {
            headers.insert(header::X_FRAME_OPTIONS, value);
        }

        // X-Content-Type-Options
        if let Ok(value) = config.content_type_options.parse() {
            headers.insert(header::X_CONTENT_TYPE_OPTIONS, value);
        }

        // X-XSS-Protection
        if let Ok(value) = config.xss_protection.parse() {
            headers.insert(header::X_XSS_PROTECTION, value);
        }

        // Referrer-Policy
        if let Ok(value) = config.referrer_policy.parse() {
            headers.insert(header::REFERRER_POLICY, value);
        }

        // Content-Security-Policy
        if let Some(ref csp) = config.csp {
            if let Ok(value) = csp.parse() {
                headers.insert(header::CONTENT_SECURITY_POLICY, value);
            }
        }

        // Permissions-Policy
        if let Some(ref permissions) = config.permissions_policy {
            if let Ok(value) = permissions.parse() {
                headers.insert(
                    header::HeaderName::from_static("permissions-policy"),
                    value,
                );
            }
        }

        response
    })
}

#[cfg(test)]
mod tests {
    use super::*;
    use axum::{
        body::Body,
        http::{Request, StatusCode},
        response::Response,
        middleware::Next,
        Router,
        routing::get,
    };

    #[tokio::test]
    async fn test_security_headers_added() {
        let config = SecurityHeadersConfig {
            hsts_max_age_seconds: 31536000,
            hsts_include_subdomains: true,
            hsts_preload: true,
            frame_options: "DENY".to_string(),
            content_type_options: "nosniff".to_string(),
            xss_protection: "1; mode=block".to_string(),
            referrer_policy: "strict-origin-when-cross-origin".to_string(),
            csp: Some("default-src 'self'".to_string()),
            permissions_policy: Some("geolocation=()".to_string()),
        };

        let layer = security_headers_layer(config);

        // Test would require full axum setup
        // This is a placeholder for integration tests
    }
}
