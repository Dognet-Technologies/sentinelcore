// src/middleware/cors.rs
use axum::{
    http::{HeaderValue, Method, header},
    response::{IntoResponse, Response},
    middleware::Next,
};
use tower_http::cors::{CorsLayer, Any};
use crate::config::CorsConfig;

/// Creates a CORS layer based on configuration
pub fn create_cors_layer(config: &CorsConfig) -> CorsLayer {
    if !config.enabled {
        // Return permissive CORS for development if disabled
        return CorsLayer::permissive();
    }

    let mut cors = CorsLayer::new();

    // Configure allowed origins
    if config.allowed_origins.is_empty() {
        // If no origins specified, allow any (development mode)
        cors = cors.allow_origin(Any);
    } else {
        // Parse and set allowed origins
        let origins: Vec<HeaderValue> = config
            .allowed_origins
            .iter()
            .filter_map(|origin| origin.parse().ok())
            .collect();

        if !origins.is_empty() {
            cors = cors.allow_origin(origins);
        }
    }

    // Configure allowed methods
    if config.allowed_methods.is_empty() {
        cors = cors.allow_methods(Any);
    } else {
        let methods: Vec<Method> = config
            .allowed_methods
            .iter()
            .filter_map(|m| m.parse().ok())
            .collect();

        if !methods.is_empty() {
            cors = cors.allow_methods(methods);
        }
    }

    // Configure allowed headers
    if config.allowed_headers.is_empty() {
        cors = cors.allow_headers(Any);
    } else {
        let headers: Vec<header::HeaderName> = config
            .allowed_headers
            .iter()
            .filter_map(|h| h.parse().ok())
            .collect();

        if !headers.is_empty() {
            cors = cors.allow_headers(headers);
        }
    }

    // Configure exposed headers
    if !config.expose_headers.is_empty() {
        let headers: Vec<header::HeaderName> = config
            .expose_headers
            .iter()
            .filter_map(|h| h.parse().ok())
            .collect();

        if !headers.is_empty() {
            cors = cors.expose_headers(headers);
        }
    }

    // Configure credentials
    if config.allow_credentials {
        cors = cors.allow_credentials(true);
    }

    // Configure max age
    cors = cors.max_age(std::time::Duration::from_secs(config.max_age_seconds));

    cors
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_cors_layer_creation() {
        let config = CorsConfig {
            enabled: true,
            allowed_origins: vec!["https://example.com".to_string()],
            allowed_methods: vec!["GET".to_string(), "POST".to_string()],
            allowed_headers: vec!["Content-Type".to_string()],
            expose_headers: vec![],
            max_age_seconds: 3600,
            allow_credentials: true,
        };

        let _cors_layer = create_cors_layer(&config);
        // If it doesn't panic, the test passes
    }

    #[test]
    fn test_cors_disabled() {
        let config = CorsConfig {
            enabled: false,
            allowed_origins: vec![],
            allowed_methods: vec![],
            allowed_headers: vec![],
            expose_headers: vec![],
            max_age_seconds: 0,
            allow_credentials: false,
        };

        let _cors_layer = create_cors_layer(&config);
        // Should create permissive layer
    }
}
