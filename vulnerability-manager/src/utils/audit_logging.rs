use sqlx::PgPool;
use serde_json::json;
use uuid::Uuid;

pub struct AuditLogger;

impl AuditLogger {
    pub async fn log_action(
        pool: &PgPool,
        user_id: Uuid,
        action: &str,
        entity_type: &str,
        entity_id: Option<Uuid>,
        old_values: Option<serde_json::Value>,
        new_values: Option<serde_json::Value>,
    ) -> Result<(), String> {
        sqlx::query(
            r#"
            INSERT INTO audit_logs (user_id, action, entity_type, entity_id, old_values, new_values)
            VALUES ($1, $2, $3, $4, $5, $6)
            "#,
        )
        .bind(user_id)
        .bind(action)
        .bind(entity_type)
        .bind(entity_id)
        .bind(old_values)
        .bind(new_values)
        .execute(pool)
        .await
        .map_err(|e| format!("Failed to log audit action: {}", e))?;

        Ok(())
    }

    pub async fn log_create(
        pool: &PgPool,
        user_id: Uuid,
        entity_type: &str,
        entity_id: Uuid,
        new_values: serde_json::Value,
    ) -> Result<(), String> {
        Self::log_action(
            pool,
            user_id,
            "CREATE",
            entity_type,
            Some(entity_id),
            None,
            Some(new_values),
        )
        .await
    }

    pub async fn log_update(
        pool: &PgPool,
        user_id: Uuid,
        entity_type: &str,
        entity_id: Uuid,
        old_values: serde_json::Value,
        new_values: serde_json::Value,
    ) -> Result<(), String> {
        Self::log_action(
            pool,
            user_id,
            "UPDATE",
            entity_type,
            Some(entity_id),
            Some(old_values),
            Some(new_values),
        )
        .await
    }

    pub async fn log_delete(
        pool: &PgPool,
        user_id: Uuid,
        entity_type: &str,
        entity_id: Uuid,
        old_values: serde_json::Value,
    ) -> Result<(), String> {
        Self::log_action(
            pool,
            user_id,
            "DELETE",
            entity_type,
            Some(entity_id),
            Some(old_values),
            None,
        )
        .await
    }

    pub async fn log_assign(
        pool: &PgPool,
        user_id: Uuid,
        entity_type: &str,
        entity_id: Uuid,
        assign_to: &str,
    ) -> Result<(), String> {
        Self::log_action(
            pool,
            user_id,
            "ASSIGN",
            entity_type,
            Some(entity_id),
            None,
            Some(json!({"assigned_to": assign_to})),
        )
        .await
    }

    pub async fn log_status_change(
        pool: &PgPool,
        user_id: Uuid,
        entity_type: &str,
        entity_id: Uuid,
        from_status: &str,
        to_status: &str,
    ) -> Result<(), String> {
        Self::log_action(
            pool,
            user_id,
            "STATUS_CHANGE",
            entity_type,
            Some(entity_id),
            Some(json!({"status": from_status})),
            Some(json!({"status": to_status})),
        )
        .await
    }

    pub async fn log_permission_change(
        pool: &PgPool,
        user_id: Uuid,
        target_user_id: Uuid,
        action_type: &str,
        permission: &str,
    ) -> Result<(), String> {
        Self::log_action(
            pool,
            user_id,
            action_type,
            "USER_PERMISSION",
            Some(target_user_id),
            None,
            Some(json!({"permission": permission})),
        )
        .await
    }
}
