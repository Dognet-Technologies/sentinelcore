use anyhow::Result;
use serde_json::Value;
use std::sync::{Arc, RwLock};
use std::fs;
use std::path::Path;
use tracing::info;
use uuid::Uuid;

use crate::config::PluginsConfig;
use crate::models::PluginMetadata;

pub mod loader;
pub mod interface;
pub mod executor;
pub mod scanner;

pub trait Plugin: Send + Sync {
    fn name(&self) -> &str;
    fn version(&self) -> &str;
    fn execute(&self, action: &str, data: &Value) -> Result<Value>;
}

#[derive(Clone)]
pub struct PluginContext {
    pub config: Value,
}

#[allow(dead_code)]
pub struct PluginManager {
    plugins: RwLock<Vec<(PluginMetadata, Box<dyn Plugin>)>>,
    config: PluginsConfig,
}

impl PluginManager {
    pub fn new(config: PluginsConfig) -> Self {
        Self {
            plugins: RwLock::new(Vec::new()),
            config,
        }
    }

    pub fn register_plugin(&self, metadata: PluginMetadata, plugin: Box<dyn Plugin>) -> Result<()> {
        let mut plugins = self.plugins.write().map_err(|e| anyhow::anyhow!("Lock error: {}", e))?;
        
        // Verify that names match
        if metadata.name != plugin.name() {
            return Err(anyhow::anyhow!("Plugin name mismatch: {} vs {}", metadata.name, plugin.name()));
        }
        
        // Verify that versions match
        if metadata.version != plugin.version() {
            return Err(anyhow::anyhow!("Plugin version mismatch: {} vs {}", metadata.version, plugin.version()));
        }
        
        info!("Registered plugin: {} v{}", metadata.name, metadata.version);
        plugins.push((metadata, plugin));
        Ok(())
    }
    
    pub fn get_plugins(&self) -> Result<Vec<PluginMetadata>> {
        let plugins = self.plugins.read().map_err(|e| anyhow::anyhow!("Lock error: {}", e))?;
        Ok(plugins.iter().map(|(metadata, _)| metadata.clone()).collect())
    }
    
    pub fn get_plugin(&self, id: Uuid) -> Result<Option<PluginMetadata>> {
        let plugins = self.plugins.read().map_err(|e| anyhow::anyhow!("Lock error: {}", e))?;
        
        for (metadata, _) in plugins.iter() {
            if metadata.id == id {
                return Ok(Some(metadata.clone()));
            }
        }
        
        Ok(None)
    }
    
    pub fn execute_plugin(&self, plugin_id: Uuid, action: &str, data: &Value) -> Result<Value> {
        let plugins = self.plugins.read().map_err(|e| anyhow::anyhow!("Lock error: {}", e))?;
        
        for (metadata, plugin) in plugins.iter() {
            if metadata.id == plugin_id {
                if !metadata.enabled {
                    return Err(anyhow::anyhow!("Plugin is disabled: {}", metadata.name));
                }
                
                return plugin.execute(action, data);
            }
        }
        
        Err(anyhow::anyhow!("Plugin not found: {}", plugin_id))
    }
    
    pub fn update_plugin_config(&self, id: Uuid, config: Value) -> Result<PluginMetadata> {
        let mut plugins = self.plugins.write().map_err(|e| anyhow::anyhow!("Lock error: {}", e))?;
        
        for (metadata, _) in plugins.iter_mut() {
            if metadata.id == id {
                metadata.config = config;
                return Ok(metadata.clone());
            }
        }
        
        Err(anyhow::anyhow!("Plugin not found: {}", id))
    }
    
    pub fn enable_plugin(&self, id: Uuid) -> Result<PluginMetadata> {
        let mut plugins = self.plugins.write().map_err(|e| anyhow::anyhow!("Lock error: {}", e))?;
        
        for (metadata, _) in plugins.iter_mut() {
            if metadata.id == id {
                metadata.enabled = true;
                return Ok(metadata.clone());
            }
        }
        
        Err(anyhow::anyhow!("Plugin not found: {}", id))
    }
    
    pub fn disable_plugin(&self, id: Uuid) -> Result<PluginMetadata> {
        let mut plugins = self.plugins.write().map_err(|e| anyhow::anyhow!("Lock error: {}", e))?;
        
        for (metadata, _) in plugins.iter_mut() {
            if metadata.id == id {
                metadata.enabled = false;
                return Ok(metadata.clone());
            }
        }
        
        Err(anyhow::anyhow!("Plugin not found: {}", id))
    }
    
    // Implementazione base del caricamento plugin
    #[allow(dead_code)]
    fn load_plugins_from_directory(&self, directory: &Path) -> Result<()> {
        if !directory.exists() {
            info!("Plugin directory does not exist: {:?}", directory);
            return Ok(());
        }
        
        for entry in fs::read_dir(directory)? {
            let entry = entry?;
            let path = entry.path();
            
            // Ignora directory e file non .so/.dll
            if path.is_dir() || 
               path.extension().map_or(true, |ext| ext != "so" && ext != "dll") {
                continue;
            }
            
            info!("Found potential plugin at: {:?}", path);
            
            // Qui dovremmo usare loader::load_plugin, che sarà implementato
            // nel modulo loader
        }
        
        Ok(())
    }
}

pub fn init_plugin_manager(config: &PluginsConfig) -> Result<Arc<PluginManager>> {
    let manager = PluginManager::new(config.clone());
    
    if config.enabled {
        // Crea solo la directory se non esiste
        let plugin_dir = Path::new(&config.directory);
        if !plugin_dir.exists() {
            info!("Creating plugin directory: {:?}", plugin_dir);
            fs::create_dir_all(plugin_dir)?;
        }
        
        // Non carichiamo plugin per ora, verrà implementato in seguito
        info!("Plugin system is enabled. Directory: {}", config.directory);
    } else {
        info!("Plugin system is disabled.");
    }
    
    Ok(Arc::new(manager))
}