// src/plugins/scanner.rs
use anyhow::{Result, Context};
use serde::{Deserialize};
use std::fs;
use std::path::Path;
use tracing::{info, warn};

use crate::models::{PluginType, NewPlugin};

#[derive(Debug, Deserialize)]
struct PluginManifest {
    name: String,
    display_name: String,
    version: String,
    author: String,
    description: Option<String>,
    language: String,
    #[serde(rename = "type")]
    plugin_type: String,
    entry_point: String,
    config: Option<serde_json::Value>,
}

pub struct PluginScanner {
    plugin_dir: String,
}

impl PluginScanner {
    pub fn new(plugin_dir: String) -> Self {
        Self { plugin_dir }
    }

    pub async fn scan_directory(&self) -> Result<Vec<NewPlugin>> {
        let mut plugins = Vec::new();
        let plugin_path = Path::new(&self.plugin_dir);

        if !plugin_path.exists() {
            warn!("Plugin directory does not exist: {}", self.plugin_dir);
            fs::create_dir_all(plugin_path)?;
            return Ok(plugins);
        }

        // Leggi tutte le directory nella cartella plugins
        for entry in fs::read_dir(plugin_path)? {
            let entry = entry?;
            let path = entry.path();

            // Solo directory
            if !path.is_dir() {
                continue;
            }

            // Cerca plugin.yaml o plugin.yml
            let yaml_path = path.join("plugin.yaml");
            let yml_path = path.join("plugin.yml");
            
            let manifest_path = if yaml_path.exists() {
                yaml_path
            } else if yml_path.exists() {
                yml_path
            } else {
                warn!("No plugin manifest found in {:?}", path);
                continue;
            };

            // Leggi e parse manifest
            match self.read_plugin_manifest(&manifest_path, &path).await {
                Ok(plugin) => {
                    info!("Found plugin: {} v{}", plugin.name, plugin.version);
                    plugins.push(plugin);
                }
                Err(e) => {
                    warn!("Failed to read plugin from {:?}: {}", path, e);
                }
            }
        }

        Ok(plugins)
    }

    async fn read_plugin_manifest(&self, manifest_path: &Path, plugin_dir: &Path) -> Result<NewPlugin> {
        let content = fs::read_to_string(manifest_path)
            .context("Failed to read plugin manifest")?;

        let manifest: PluginManifest = serde_yaml::from_str(&content)
            .context("Failed to parse plugin manifest")?;

        // Parse plugin type
        let plugin_type = match manifest.plugin_type.as_str() {
            "import" => PluginType::Import,
            "export" => PluginType::Export,
            "notification" => PluginType::Notification,
            "analysis" => PluginType::Analysis,
            "integration" => PluginType::Integration,
            _ => PluginType::Other,
        };

        // Costruisci path completo all'entry point
        let entry_point_path = plugin_dir.join(&manifest.entry_point);
        
        if !entry_point_path.exists() {
            return Err(anyhow::anyhow!(
                "Plugin entry point not found: {:?}", 
                entry_point_path
            ));
        }

        Ok(NewPlugin {
            name: manifest.name,
            display_name: manifest.display_name,
            version: manifest.version,
            author: manifest.author,
            description: manifest.description,
            plugin_type,
            language: manifest.language,
            path: entry_point_path.to_string_lossy().to_string(),
            config: manifest.config,
        })
    }
}