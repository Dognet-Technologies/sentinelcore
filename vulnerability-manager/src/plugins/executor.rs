// src/plugins/executor.rs
use anyhow::{Result, Context};
use std::os::unix::process::ExitStatusExt;
use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::process::{Command, Stdio};
use std::path::Path;
use tracing::{info, error, debug};

#[derive(Debug, Serialize, Deserialize)]
pub struct PluginRequest {
    pub action: String,
    pub data: Value,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct PluginResponse {
    pub success: bool,
    pub data: Option<Value>,
    pub error: Option<String>,
}

pub struct PythonExecutor {
    python_path: String,
    timeout_seconds: u64,
}

impl PythonExecutor {
    pub fn new() -> Self {
        Self {
            python_path: "python3".to_string(),
            timeout_seconds: 300, // 5 minuti default
        }
    }

    pub async fn execute(
        &self,
        plugin_path: &Path,
        action: &str,
        data: &Value,
    ) -> Result<Value> {
        let request = PluginRequest {
            action: action.to_string(),
            data: data.clone(),
        };

        let request_json = serde_json::to_string(&request)?;
        
        info!("Executing Python plugin: {:?}, action: {}", plugin_path, action);
        debug!("Plugin request: {}", request_json);

        // Costruisci il comando
        let output = tokio::task::spawn_blocking({
            let python_path = self.python_path.clone();
            let plugin_path = plugin_path.to_path_buf();
            let request_json = request_json.clone();
            
            move || {
                let mut cmd = Command::new(python_path);
                cmd.arg(plugin_path)
                    .arg("--request")
                    .arg(request_json)
                    .stdin(Stdio::null())
                    .stdout(Stdio::piped())
                    .stderr(Stdio::piped());

                // Esegui
                match cmd.output() {
                    Ok(output) => output,
                    Err(e) => {
                        error!("Failed to execute plugin: {}", e);
                        std::process::Output {
                            status: std::process::ExitStatus::from_raw(1),
                            stdout: Vec::new(),
                            stderr: format!("Execution error: {}", e).into_bytes(),
                        }
                    }
                }
            }
        }).await?;

        // Parse output
        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            error!("Plugin execution failed: {}", stderr);
            return Err(anyhow::anyhow!("Plugin execution failed: {}", stderr));
        }

        let stdout = String::from_utf8_lossy(&output.stdout);
        debug!("Plugin output: {}", stdout);

        // Parse response
        let response: PluginResponse = serde_json::from_str(&stdout)
            .context("Failed to parse plugin response")?;

        if !response.success {
            return Err(anyhow::anyhow!(
                "Plugin returned error: {}",
                response.error.unwrap_or_else(|| "Unknown error".to_string())
            ));
        }

        Ok(response.data.unwrap_or(Value::Null))
    }
}