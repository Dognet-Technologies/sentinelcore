// src/audit.rs
// Comprehensive audit logging system for tracking all critical operations

use sqlx::PgPool;
use uuid::Uuid;
use serde_json::{Value as JsonValue, json};
use std::net::IpAddr;
use chrono::{DateTime, Utc};
use serde::{Serialize, Deserialize};

/// Audit log entry
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuditLog {
    pub id: Uuid,
    pub user_id: Option<Uuid>,
    pub action: String,
    pub entity_type: Option<String>,
    pub entity_id: Option<Uuid>,
    pub old_values: Option<JsonValue>,
    pub new_values: Option<JsonValue>,
    pub ip_address: Option<IpAddr>,
    pub user_agent: Option<String>,
    pub created_at: DateTime<Utc>,
}

/// Audit action types
#[derive(Debug, Clone, Copy)]
pub enum AuditAction {
    // Authentication
    Login,
    Logout,
    LoginFailed,
    PasswordChanged,
    TwoFactorEnabled,
    TwoFactorDisabled,

    // User management
    UserCreated,
    UserUpdated,
    UserDeleted,
    UserRoleChanged,

    // Vulnerability management
    VulnerabilityCreated,
    VulnerabilityUpdated,
    VulnerabilityDeleted,
    VulnerabilityAssigned,
    VulnerabilityStatusChanged,

    // Team management
    TeamCreated,
    TeamUpdated,
    TeamDeleted,
    TeamMemberAdded,
    TeamMemberRemoved,

    // Asset management
    AssetCreated,
    AssetUpdated,
    AssetDeleted,

    // Network scanning
    NetworkScanStarted,
    NetworkScanCompleted,

    // Reports
    ReportGenerated,
    ReportDownloaded,

    // Settings
    SettingsChanged,

    // Security events
    UnauthorizedAccess,
    SuspiciousActivity,
}

impl AuditAction {
    pub fn as_str(&self) -> &'static str {
        match self {
            // Authentication
            Self::Login => "user.login",
            Self::Logout => "user.logout",
            Self::LoginFailed => "user.login_failed",
            Self::PasswordChanged => "user.password_changed",
            Self::TwoFactorEnabled => "user.2fa_enabled",
            Self::TwoFactorDisabled => "user.2fa_disabled",

            // User management
            Self::UserCreated => "user.created",
            Self::UserUpdated => "user.updated",
            Self::UserDeleted => "user.deleted",
            Self::UserRoleChanged => "user.role_changed",

            // Vulnerability management
            Self::VulnerabilityCreated => "vulnerability.created",
            Self::VulnerabilityUpdated => "vulnerability.updated",
            Self::VulnerabilityDeleted => "vulnerability.deleted",
            Self::VulnerabilityAssigned => "vulnerability.assigned",
            Self::VulnerabilityStatusChanged => "vulnerability.status_changed",

            // Team management
            Self::TeamCreated => "team.created",
            Self::TeamUpdated => "team.updated",
            Self::TeamDeleted => "team.deleted",
            Self::TeamMemberAdded => "team.member_added",
            Self::TeamMemberRemoved => "team.member_removed",

            // Asset management
            Self::AssetCreated => "asset.created",
            Self::AssetUpdated => "asset.updated",
            Self::AssetDeleted => "asset.deleted",

            // Network scanning
            Self::NetworkScanStarted => "network.scan_started",
            Self::NetworkScanCompleted => "network.scan_completed",

            // Reports
            Self::ReportGenerated => "report.generated",
            Self::ReportDownloaded => "report.downloaded",

            // Settings
            Self::SettingsChanged => "settings.changed",

            // Security events
            Self::UnauthorizedAccess => "security.unauthorized_access",
            Self::SuspiciousActivity => "security.suspicious_activity",
        }
    }
}

/// Audit log builder for fluent API
pub struct AuditLogBuilder {
    user_id: Option<Uuid>,
    action: String,
    entity_type: Option<String>,
    entity_id: Option<Uuid>,
    old_values: Option<JsonValue>,
    new_values: Option<JsonValue>,
    ip_address: Option<IpAddr>,
    user_agent: Option<String>,
}

impl AuditLogBuilder {
    pub fn new(action: AuditAction) -> Self {
        Self {
            user_id: None,
            action: action.as_str().to_string(),
            entity_type: None,
            entity_id: None,
            old_values: None,
            new_values: None,
            ip_address: None,
            user_agent: None,
        }
    }

    pub fn user_id(mut self, user_id: Uuid) -> Self {
        self.user_id = Some(user_id);
        self
    }

    pub fn entity(mut self, entity_type: &str, entity_id: Uuid) -> Self {
        self.entity_type = Some(entity_type.to_string());
        self.entity_id = Some(entity_id);
        self
    }

    pub fn old_values<T: Serialize>(mut self, values: &T) -> Self {
        self.old_values = serde_json::to_value(values).ok();
        self
    }

    pub fn new_values<T: Serialize>(mut self, values: &T) -> Self {
        self.new_values = serde_json::to_value(values).ok();
        self
    }

    pub fn ip_address(mut self, ip: IpAddr) -> Self {
        self.ip_address = Some(ip);
        self
    }

    pub fn user_agent(mut self, agent: String) -> Self {
        self.user_agent = Some(agent);
        self
    }

    /// Log the audit entry to the database
    pub async fn log(self, pool: &PgPool) -> Result<(), sqlx::Error> {
        sqlx::query(
            r#"
            INSERT INTO audit_logs (
                user_id, action, entity_type, entity_id,
                old_values, new_values, ip_address, user_agent
            )
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
            "#
        )
        .bind(self.user_id)
        .bind(&self.action)
        .bind(self.entity_type)
        .bind(self.entity_id)
        .bind(self.old_values)
        .bind(self.new_values)
        .bind(self.ip_address)
        .bind(self.user_agent)
        .execute(pool)
        .await?;

        tracing::debug!("Audit log created: {}", self.action);
        Ok(())
    }

    /// Log without waiting (fire and forget)
    /// Use this when audit logging shouldn't block the main operation
    pub fn log_async(self, pool: PgPool) {
        tokio::spawn(async move {
            if let Err(e) = self.log(&pool).await {
                tracing::error!("Failed to write audit log: {}", e);
            }
        });
    }
}

/// Convenience function to create audit log
pub fn audit(action: AuditAction) -> AuditLogBuilder {
    AuditLogBuilder::new(action)
}

/// Query audit logs with filters
pub async fn query_audit_logs(
    pool: &PgPool,
    user_id: Option<Uuid>,
    action: Option<String>,
    entity_type: Option<String>,
    entity_id: Option<Uuid>,
    limit: i64,
    offset: i64,
) -> Result<Vec<AuditLog>, sqlx::Error> {
    let mut query = String::from(
        r#"
        SELECT id, user_id, action, entity_type, entity_id,
               old_values, new_values, ip_address, user_agent, created_at
        FROM audit_logs
        WHERE 1=1
        "#
    );

    let mut bind_index = 1;
    let mut bindings: Vec<String> = vec![];

    if user_id.is_some() {
        query.push_str(&format!(" AND user_id = ${}", bind_index));
        bind_index += 1;
    }

    if action.is_some() {
        query.push_str(&format!(" AND action = ${}", bind_index));
        bind_index += 1;
    }

    if entity_type.is_some() {
        query.push_str(&format!(" AND entity_type = ${}", bind_index));
        bind_index += 1;
    }

    if entity_id.is_some() {
        query.push_str(&format!(" AND entity_id = ${}", bind_index));
        bind_index += 1;
    }

    query.push_str(&format!(
        " ORDER BY created_at DESC LIMIT ${} OFFSET ${}",
        bind_index,
        bind_index + 1
    ));

    let mut query_builder = sqlx::query_as::<_, AuditLog>(&query);

    if let Some(uid) = user_id {
        query_builder = query_builder.bind(uid);
    }
    if let Some(a) = action {
        query_builder = query_builder.bind(a);
    }
    if let Some(et) = entity_type {
        query_builder = query_builder.bind(et);
    }
    if let Some(eid) = entity_id {
        query_builder = query_builder.bind(eid);
    }

    query_builder = query_builder.bind(limit).bind(offset);

    query_builder.fetch_all(pool).await
}

/// Get audit logs count for pagination
pub async fn count_audit_logs(
    pool: &PgPool,
    user_id: Option<Uuid>,
    action: Option<String>,
    entity_type: Option<String>,
    entity_id: Option<Uuid>,
) -> Result<i64, sqlx::Error> {
    let mut query = String::from("SELECT COUNT(*) FROM audit_logs WHERE 1=1");
    let mut bind_index = 1;

    if user_id.is_some() {
        query.push_str(&format!(" AND user_id = ${}", bind_index));
        bind_index += 1;
    }
    if action.is_some() {
        query.push_str(&format!(" AND action = ${}", bind_index));
        bind_index += 1;
    }
    if entity_type.is_some() {
        query.push_str(&format!(" AND entity_type = ${}", bind_index));
        bind_index += 1;
    }
    if entity_id.is_some() {
        query.push_str(&format!(" AND entity_id = ${}", bind_index));
    }

    let mut query_builder = sqlx::query_scalar::<_, i64>(&query);

    if let Some(uid) = user_id {
        query_builder = query_builder.bind(uid);
    }
    if let Some(a) = action {
        query_builder = query_builder.bind(a);
    }
    if let Some(et) = entity_type {
        query_builder = query_builder.bind(et);
    }
    if let Some(eid) = entity_id {
        query_builder = query_builder.bind(eid);
    }

    query_builder.fetch_one(pool).await
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_audit_action_strings() {
        assert_eq!(AuditAction::Login.as_str(), "user.login");
        assert_eq!(AuditAction::VulnerabilityCreated.as_str(), "vulnerability.created");
        assert_eq!(AuditAction::UnauthorizedAccess.as_str(), "security.unauthorized_access");
    }

    #[test]
    fn test_builder() {
        let user_id = Uuid::new_v4();
        let entity_id = Uuid::new_v4();

        let builder = audit(AuditAction::VulnerabilityCreated)
            .user_id(user_id)
            .entity("vulnerability", entity_id);

        assert_eq!(builder.user_id, Some(user_id));
        assert_eq!(builder.entity_type, Some("vulnerability".to_string()));
        assert_eq!(builder.entity_id, Some(entity_id));
    }
}
