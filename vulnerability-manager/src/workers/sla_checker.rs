// src/workers/sla_checker.rs
// Background worker to check and mark SLA breaches

use std::sync::Arc;
use tokio::time::{interval, Duration};
use sqlx::PgPool;
use tracing::{info, error};

/// Start SLA breach checker worker
/// Runs every hour to check and mark SLA breaches
pub fn start_sla_checker(pool: Arc<PgPool>) {
    tokio::spawn(async move {
        let mut interval = interval(Duration::from_secs(3600)); // Every 1 hour

        info!("ðŸ•’ SLA breach checker worker started (interval: 1 hour)");

        loop {
            interval.tick().await;

            info!("ðŸ” Checking for SLA breaches...");

            match check_and_mark_breaches(&pool).await {
                Ok(count) => {
                    if count > 0 {
                        info!("âš ï¸  Marked {} SLA breaches", count);
                    } else {
                        info!("âœ… No new SLA breaches found");
                    }
                }
                Err(e) => {
                    error!("âŒ SLA breach check failed: {}", e);
                }
            }
        }
    });
}

async fn check_and_mark_breaches(pool: &PgPool) -> Result<i64, sqlx::Error> {
    let result = sqlx::query!(
        r#"
        WITH breached AS (
            SELECT mark_sla_breaches() as count
        )
        SELECT COALESCE(count, 0) as "count!" FROM breached
        "#
    )
    .fetch_one(pool)
    .await?;

    Ok(result.count)
}
