// src/workers/nvd_api.rs
// NVD API integration for CVE enrichment

use std::sync::Arc;
use tokio::time::{interval, Duration};
use sqlx::PgPool;
use tracing::{info, error, warn};
use serde::{Deserialize, Serialize};

#[derive(Debug, Deserialize)]
struct NvdResponse {
    vulnerabilities: Vec<NvdVulnerability>,
    #[serde(rename = "totalResults")]
    total_results: i32,
}

#[derive(Debug, Deserialize)]
struct NvdVulnerability {
    cve: NvdCve,
}

#[derive(Debug, Deserialize)]
struct NvdCve {
    id: String,
    descriptions: Vec<NvdDescription>,
    metrics: Option<NvdMetrics>,
    weaknesses: Option<Vec<NvdWeakness>>,
    references: Option<Vec<NvdReference>>,
}

#[derive(Debug, Deserialize)]
struct NvdDescription {
    lang: String,
    value: String,
}

#[derive(Debug, Deserialize)]
struct NvdMetrics {
    #[serde(rename = "cvssMetricV31")]
    cvss_v31: Option<Vec<NvdCvssV31>>,
}

#[derive(Debug, Deserialize)]
struct NvdCvssV31 {
    #[serde(rename = "cvssData")]
    cvss_data: NvdCvssData,
}

#[derive(Debug, Deserialize)]
struct NvdCvssData {
    #[serde(rename = "baseScore")]
    base_score: f32,
    #[serde(rename = "vectorString")]
    vector_string: String,
}

#[derive(Debug, Deserialize)]
struct NvdWeakness {
    description: Vec<NvdDescription>,
}

#[derive(Debug, Deserialize)]
struct NvdReference {
    url: String,
}

/// Start NVD API enrichment worker
/// Enriches vulnerabilities with NVD data (runs daily)
pub fn start_nvd_enrichment(pool: Arc<PgPool>) {
    tokio::spawn(async move {
        let mut interval = interval(Duration::from_secs(86400)); // Every 24 hours

        info!("ðŸ” NVD enrichment worker started (interval: 24 hours)");

        loop {
            interval.tick().await;

            info!("ðŸ” Enriching vulnerabilities with NVD data...");

            match enrich_vulnerabilities_with_nvd(&pool).await {
                Ok(count) => {
                    if count > 0 {
                        info!("âœ… Enriched {} vulnerabilities with NVD data", count);
                    } else {
                        info!("â„¹ï¸  No vulnerabilities to enrich");
                    }
                }
                Err(e) => {
                    error!("âŒ NVD enrichment failed: {}", e);
                }
            }
        }
    });
}

async fn enrich_vulnerabilities_with_nvd(pool: &PgPool) -> Result<i32, Box<dyn std::error::Error>> {
    // Get vulnerabilities with CVE but without enrichment
    let vulns = sqlx::query!(
        r#"
        SELECT id, cve_id
        FROM vulnerabilities
        WHERE cve_id IS NOT NULL
          AND nvd_enriched_at IS NULL
        LIMIT 100
        "#
    )
    .fetch_all(pool)
    .await?;

    let mut enriched_count = 0;

    for vuln in vulns {
        if let Some(cve_id) = vuln.cve_id {
            match fetch_nvd_data(&cve_id).await {
                Ok(nvd_data) => {
                    // Update vulnerability with NVD data
                    let _ = sqlx::query!(
                        r#"
                        UPDATE vulnerabilities
                        SET
                            cvss_score = COALESCE(cvss_score, $2),
                            cvss_vector = COALESCE(cvss_vector, $3),
                            description = COALESCE(description, $4),
                            nvd_enriched_at = NOW()
                        WHERE id = $1
                        "#,
                        vuln.id,
                        nvd_data.cvss_score,
                        nvd_data.cvss_vector,
                        nvd_data.description
                    )
                    .execute(pool)
                    .await;

                    enriched_count += 1;
                }
                Err(e) => {
                    warn!("Failed to fetch NVD data for {}: {}", cve_id, e);
                }
            }

            // Rate limit: NVD API allows 5 requests per 30 seconds
            tokio::time::sleep(Duration::from_secs(6)).await;
        }
    }

    Ok(enriched_count)
}

#[derive(Debug)]
struct NvdData {
    cvss_score: Option<f32>,
    cvss_vector: Option<String>,
    description: Option<String>,
}

async fn fetch_nvd_data(cve_id: &str) -> Result<NvdData, Box<dyn std::error::Error>> {
    let url = format!(
        "https://services.nvd.nist.gov/rest/json/cves/2.0?cveId={}",
        cve_id
    );

    let client = reqwest::Client::new();
    let response = client
        .get(&url)
        .header("User-Agent", "SentinelCore/1.0")
        .send()
        .await?;

    if !response.status().is_success() {
        return Err(format!("NVD API error: {}", response.status()).into());
    }

    let nvd_response: NvdResponse = response.json().await?;

    if nvd_response.vulnerabilities.is_empty() {
        return Err("No data found in NVD".into());
    }

    let cve = &nvd_response.vulnerabilities[0].cve;

    let description = cve
        .descriptions
        .iter()
        .find(|d| d.lang == "en")
        .map(|d| d.value.clone());

    let (cvss_score, cvss_vector) = cve
        .metrics
        .as_ref()
        .and_then(|m| m.cvss_v31.as_ref())
        .and_then(|v| v.first())
        .map(|c| {
            (
                Some(c.cvss_data.base_score),
                Some(c.cvss_data.vector_string.clone()),
            )
        })
        .unwrap_or((None, None));

    Ok(NvdData {
        cvss_score,
        cvss_vector,
        description,
    })
}
