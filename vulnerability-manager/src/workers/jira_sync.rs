// src/workers/jira_sync.rs
// Background worker for JIRA ticket synchronization

use std::sync::Arc;
use tokio::time::{interval, Duration};
use sqlx::PgPool;
use tracing::{info, error};

/// Start JIRA sync worker
/// Runs every 15 minutes to sync ticket status
pub fn start_jira_sync(pool: Arc<PgPool>) {
    tokio::spawn(async move {
        let mut interval = interval(Duration::from_secs(900)); // Every 15 minutes

        info!("ðŸ”„ JIRA sync worker started (interval: 15 minutes)");

        loop {
            interval.tick().await;

            info!("ðŸ”„ Syncing JIRA tickets...");

            match sync_jira_tickets(&pool).await {
                Ok(count) => {
                    if count > 0 {
                        info!("âœ… Synced {} JIRA tickets", count);
                    } else {
                        info!("â„¹ï¸  No JIRA tickets to sync");
                    }
                }
                Err(e) => {
                    error!("âŒ JIRA sync failed: {}", e);
                }
            }
        }
    });
}

async fn sync_jira_tickets(pool: &PgPool) -> Result<i64, sqlx::Error> {
    // Get all tickets with auto_sync enabled
    let tickets = sqlx::query!(
        r#"
        SELECT jt.id, jt.jira_issue_key, jt.entity_type, jt.entity_id
        FROM jira_tickets jt
        JOIN jira_configurations jc ON jc.id = jt.jira_config_id
        WHERE jc.auto_sync = TRUE
          AND jc.is_enabled = TRUE
          AND jt.sync_status != 'failed'
        LIMIT 100
        "#
    )
    .fetch_all(pool)
    .await?;

    let count = tickets.len() as i64;

    // TODO: Implement actual JIRA API sync
    // For now, just update last_sync_at
    for ticket in tickets {
        let _ = sqlx::query!(
            r#"
            UPDATE jira_tickets
            SET last_sync_at = NOW(), sync_status = 'synced'
            WHERE id = $1
            "#,
            ticket.id
        )
        .execute(pool)
        .await;
    }

    Ok(count)
}
