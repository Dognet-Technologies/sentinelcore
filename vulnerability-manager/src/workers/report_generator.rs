// src/workers/report_generator.rs
// Background worker to generate report files (PDF, CSV, JSON, XML)

use std::sync::Arc;
use tokio::time::{interval, Duration};
use sqlx::{PgPool, Row};
use uuid::Uuid;
use chrono::Utc;
use serde_json::json;

use crate::models::{Report, ReportStatus, ReportFormat};

/// Start the report generator background worker
/// Polls for pending/processing reports every 10 seconds and generates files
pub fn start_report_generator(pool: Arc<PgPool>) {
    tokio::spawn(async move {
        tracing::info!("ðŸ”„ Report generator worker started");
        let mut interval = interval(Duration::from_secs(10));

        loop {
            interval.tick().await;

            // Get reports that need processing
            match get_pending_reports(&pool).await {
                Ok(reports) => {
                    if !reports.is_empty() {
                        tracing::info!("ðŸ“Š Found {} reports to process", reports.len());
                    }

                    for report in reports {
                        process_report(&pool, &report).await;
                    }
                }
                Err(e) => {
                    tracing::error!("Failed to fetch pending reports: {}", e);
                }
            }
        }
    });
}

/// Get all reports with status 'pending' or 'processing'
async fn get_pending_reports(pool: &PgPool) -> Result<Vec<Report>, sqlx::Error> {
    sqlx::query_as::<_, Report>(
        r#"
        SELECT id, name, report_type, format,
               status, source, created_by, file_path,
               error_message, scan_date, processed_vulns, total_vulns,
               created_at, updated_at
        FROM reports
        WHERE status IN ('pending', 'processing')
        ORDER BY created_at ASC
        LIMIT 10
        "#
    )
    .fetch_all(pool)
    .await
}

/// Process a single report: generate file and update database
async fn process_report(pool: &PgPool, report: &Report) {
    let report_id = report.id;

    tracing::info!("ðŸ”„ Processing report: {} ({})", report.name, report_id);

    // Update status to processing
    if let Err(e) = update_report_status(pool, report_id, ReportStatus::Processing).await {
        tracing::error!("Failed to update report status to processing: {}", e);
        return;
    }

    // Generate the report file
    match generate_report_file(pool, report).await {
        Ok(file_path) => {
            // Success - update with file path and completed status
            match mark_report_completed(pool, report_id, &file_path).await {
                Ok(_) => {
                    tracing::info!("âœ… Report completed: {} -> {}", report.name, file_path);
                }
                Err(e) => {
                    tracing::error!("Failed to mark report as completed: {}", e);
                }
            }
        }
        Err(e) => {
            // Error - mark as failed with error message
            let error_msg = format!("Report generation failed: {}", e);
            tracing::error!("âŒ {}", error_msg);

            if let Err(e) = mark_report_failed(pool, report_id, &error_msg).await {
                tracing::error!("Failed to mark report as failed: {}", e);
            }
        }
    }
}

/// Generate the actual report file based on format
async fn generate_report_file(pool: &PgPool, report: &Report) -> Result<String, Box<dyn std::error::Error + Send + Sync>> {
    // Create reports directory if it doesn't exist
    let reports_dir = std::path::Path::new("./reports");
    if !reports_dir.exists() {
        std::fs::create_dir_all(reports_dir)?;
    }

    // Fetch vulnerability data for the report
    let vulnerabilities = fetch_report_data(pool, report).await?;

    // Generate file based on format
    let file_path = match report.format {
        ReportFormat::Json => generate_json_report(report, &vulnerabilities).await?,
        ReportFormat::Csv => generate_csv_report(report, &vulnerabilities).await?,
        ReportFormat::Pdf => generate_pdf_report(report, &vulnerabilities).await?,
        ReportFormat::Xml => generate_xml_report(report, &vulnerabilities).await?,
        ReportFormat::Text => generate_pdf_report(report, &vulnerabilities).await?, // Text uses same as PDF
    };

    Ok(file_path)
}

/// Fetch vulnerability data for the report
async fn fetch_report_data(pool: &PgPool, report: &Report) -> Result<Vec<serde_json::Value>, sqlx::Error> {
    // Query vulnerabilities based on report criteria
    let mut query = String::from(
        r#"
        SELECT
            v.id, v.title, v.description, v.cvss_score, v.epss_score,
            v.severity, v.status, v.cve_id, v.cwe_id, v.ip_address,
            v.hostname, v.port, v.protocol, v.remediation, v.discovered_at,
            t.name as team_name,
            u.username as assigned_user
        FROM vulnerabilities v
        LEFT JOIN teams t ON v.assigned_team_id = t.id
        LEFT JOIN users u ON v.assigned_user_id = u.id
        WHERE 1=1
        "#
    );

    // Add date filter if scan_date is specified
    if let Some(scan_date) = report.scan_date {
        query.push_str(&format!(" AND v.discovered_at >= '{}'", scan_date.format("%Y-%m-%d")));
    }

    // Add ordering
    query.push_str(" ORDER BY v.cvss_score DESC, v.discovered_at DESC");

    // Execute query and convert to JSON
    let rows = sqlx::query(&query).fetch_all(pool).await?;

    let vulnerabilities: Vec<serde_json::Value> = rows
        .iter()
        .map(|row| {
            json!({
                "id": row.try_get::<Uuid, _>("id").ok(),
                "title": row.try_get::<String, _>("title").ok(),
                "description": row.try_get::<String, _>("description").ok(),
                "cvss_score": row.try_get::<f64, _>("cvss_score").ok(),
                "epss_score": row.try_get::<Option<f64>, _>("epss_score").ok().flatten(),
                "severity": row.try_get::<String, _>("severity").ok(),
                "status": row.try_get::<String, _>("status").ok(),
                "cve_id": row.try_get::<Option<String>, _>("cve_id").ok().flatten(),
                "cwe_id": row.try_get::<Option<String>, _>("cwe_id").ok().flatten(),
                "ip_address": row.try_get::<String, _>("ip_address").ok(),
                "hostname": row.try_get::<Option<String>, _>("hostname").ok().flatten(),
                "port": row.try_get::<Option<i32>, _>("port").ok().flatten(),
                "protocol": row.try_get::<Option<String>, _>("protocol").ok().flatten(),
                "remediation": row.try_get::<Option<String>, _>("remediation").ok().flatten(),
                "discovered_at": row.try_get::<chrono::DateTime<Utc>, _>("discovered_at").ok(),
                "team_name": row.try_get::<Option<String>, _>("team_name").ok().flatten(),
                "assigned_user": row.try_get::<Option<String>, _>("assigned_user").ok().flatten(),
            })
        })
        .collect();

    Ok(vulnerabilities)
}

/// Generate JSON format report
async fn generate_json_report(report: &Report, vulnerabilities: &[serde_json::Value]) -> Result<String, Box<dyn std::error::Error + Send + Sync>> {
    let file_path = format!("./reports/{}.json", report.id);

    let report_data = json!({
        "report_id": report.id,
        "name": report.name,
        "type": format!("{:?}", report.report_type),
        "generated_at": Utc::now(),
        "total_vulnerabilities": vulnerabilities.len(),
        "vulnerabilities": vulnerabilities,
        "statistics": {
            "critical": vulnerabilities.iter().filter(|v| v["severity"].as_str() == Some("Critical")).count(),
            "high": vulnerabilities.iter().filter(|v| v["severity"].as_str() == Some("High")).count(),
            "medium": vulnerabilities.iter().filter(|v| v["severity"].as_str() == Some("Medium")).count(),
            "low": vulnerabilities.iter().filter(|v| v["severity"].as_str() == Some("Low")).count(),
        }
    });

    let json_string = serde_json::to_string_pretty(&report_data)?;
    std::fs::write(&file_path, json_string)?;

    Ok(file_path)
}

/// Generate CSV format report
async fn generate_csv_report(report: &Report, vulnerabilities: &[serde_json::Value]) -> Result<String, Box<dyn std::error::Error + Send + Sync>> {
    let file_path = format!("./reports/{}.csv", report.id);

    let mut csv_content = String::from("ID,Title,Severity,CVSS,Status,CVE,IP Address,Hostname,Discovered At,Team,Assigned User\n");

    for vuln in vulnerabilities {
        let line = format!(
            "{},{},{},{},{},{},{},{},{},{},{}\n",
            vuln["id"].as_str().unwrap_or(""),
            escape_csv(vuln["title"].as_str().unwrap_or("")),
            vuln["severity"].as_str().unwrap_or(""),
            vuln["cvss_score"].as_f64().unwrap_or(0.0),
            vuln["status"].as_str().unwrap_or(""),
            vuln["cve_id"].as_str().unwrap_or("N/A"),
            vuln["ip_address"].as_str().unwrap_or(""),
            vuln["hostname"].as_str().unwrap_or(""),
            vuln["discovered_at"].as_str().unwrap_or(""),
            vuln["team_name"].as_str().unwrap_or("Unassigned"),
            vuln["assigned_user"].as_str().unwrap_or("Unassigned"),
        );
        csv_content.push_str(&line);
    }

    std::fs::write(&file_path, csv_content)?;

    Ok(file_path)
}

/// Generate PDF format report (basic implementation)
async fn generate_pdf_report(report: &Report, vulnerabilities: &[serde_json::Value]) -> Result<String, Box<dyn std::error::Error + Send + Sync>> {
    // For now, generate a text-based PDF with basic formatting
    // In production, you'd use a proper PDF library like printpdf or wkhtmltopdf

    let file_path = format!("./reports/{}.txt", report.id);

    let mut content = format!("VULNERABILITY REPORT\n");
    content.push_str(&format!("===================\n\n"));
    content.push_str(&format!("Report: {}\n", report.name));
    content.push_str(&format!("Generated: {}\n", Utc::now().format("%Y-%m-%d %H:%M:%S UTC")));
    content.push_str(&format!("Total Vulnerabilities: {}\n\n", vulnerabilities.len()));

    // Statistics
    let critical = vulnerabilities.iter().filter(|v| v["severity"].as_str() == Some("Critical")).count();
    let high = vulnerabilities.iter().filter(|v| v["severity"].as_str() == Some("High")).count();
    let medium = vulnerabilities.iter().filter(|v| v["severity"].as_str() == Some("Medium")).count();
    let low = vulnerabilities.iter().filter(|v| v["severity"].as_str() == Some("Low")).count();

    content.push_str(&format!("SEVERITY BREAKDOWN\n"));
    content.push_str(&format!("------------------\n"));
    content.push_str(&format!("Critical: {}\n", critical));
    content.push_str(&format!("High:     {}\n", high));
    content.push_str(&format!("Medium:   {}\n", medium));
    content.push_str(&format!("Low:      {}\n\n", low));

    content.push_str(&format!("VULNERABILITIES\n"));
    content.push_str(&format!("===============\n\n"));

    for (i, vuln) in vulnerabilities.iter().enumerate() {
        content.push_str(&format!("{}. {} [{}]\n", i + 1,
            vuln["title"].as_str().unwrap_or("Untitled"),
            vuln["severity"].as_str().unwrap_or("Unknown")));
        content.push_str(&format!("   CVSS: {:.1}\n", vuln["cvss_score"].as_f64().unwrap_or(0.0)));
        if let Some(cve) = vuln["cve_id"].as_str() {
            content.push_str(&format!("   CVE: {}\n", cve));
        }
        content.push_str(&format!("   Target: {}:{}\n",
            vuln["ip_address"].as_str().unwrap_or("Unknown"),
            vuln["port"].as_i64().unwrap_or(0)));
        content.push_str(&format!("   Status: {}\n", vuln["status"].as_str().unwrap_or("Unknown")));
        content.push_str("\n");
    }

    std::fs::write(&file_path, content)?;

    Ok(file_path)
}

/// Generate XML format report
async fn generate_xml_report(report: &Report, vulnerabilities: &[serde_json::Value]) -> Result<String, Box<dyn std::error::Error + Send + Sync>> {
    let file_path = format!("./reports/{}.xml", report.id);

    let mut xml = String::from("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
    xml.push_str("<vulnerability_report>\n");
    xml.push_str(&format!("  <metadata>\n"));
    xml.push_str(&format!("    <id>{}</id>\n", report.id));
    xml.push_str(&format!("    <name>{}</name>\n", escape_xml(&report.name)));
    xml.push_str(&format!("    <generated_at>{}</generated_at>\n", Utc::now().to_rfc3339()));
    xml.push_str(&format!("    <total_count>{}</total_count>\n", vulnerabilities.len()));
    xml.push_str(&format!("  </metadata>\n"));
    xml.push_str(&format!("  <vulnerabilities>\n"));

    for vuln in vulnerabilities {
        xml.push_str("    <vulnerability>\n");
        xml.push_str(&format!("      <id>{}</id>\n", vuln["id"].as_str().unwrap_or("")));
        xml.push_str(&format!("      <title>{}</title>\n", escape_xml(vuln["title"].as_str().unwrap_or(""))));
        xml.push_str(&format!("      <severity>{}</severity>\n", vuln["severity"].as_str().unwrap_or("")));
        xml.push_str(&format!("      <cvss_score>{}</cvss_score>\n", vuln["cvss_score"].as_f64().unwrap_or(0.0)));
        if let Some(cve) = vuln["cve_id"].as_str() {
            xml.push_str(&format!("      <cve_id>{}</cve_id>\n", cve));
        }
        xml.push_str(&format!("      <status>{}</status>\n", vuln["status"].as_str().unwrap_or("")));
        xml.push_str("    </vulnerability>\n");
    }

    xml.push_str("  </vulnerabilities>\n");
    xml.push_str("</vulnerability_report>\n");

    std::fs::write(&file_path, xml)?;

    Ok(file_path)
}

/// Update report status
async fn update_report_status(pool: &PgPool, report_id: Uuid, status: ReportStatus) -> Result<(), sqlx::Error> {
    sqlx::query(
        "UPDATE reports SET status = $1, updated_at = NOW() WHERE id = $2"
    )
    .bind(status)
    .bind(report_id)
    .execute(pool)
    .await?;

    Ok(())
}

/// Mark report as completed with file path
async fn mark_report_completed(pool: &PgPool, report_id: Uuid, file_path: &str) -> Result<(), sqlx::Error> {
    sqlx::query(
        "UPDATE reports SET status = $1, file_path = $2, updated_at = NOW() WHERE id = $3"
    )
    .bind(ReportStatus::Completed)
    .bind(file_path)
    .bind(report_id)
    .execute(pool)
    .await?;

    Ok(())
}

/// Mark report as failed with error message
async fn mark_report_failed(pool: &PgPool, report_id: Uuid, error_message: &str) -> Result<(), sqlx::Error> {
    sqlx::query(
        "UPDATE reports SET status = $1, error_message = $2, updated_at = NOW() WHERE id = $3"
    )
    .bind(ReportStatus::Failed)
    .bind(error_message)
    .bind(report_id)
    .execute(pool)
    .await?;

    Ok(())
}

/// Escape CSV special characters
fn escape_csv(s: &str) -> String {
    if s.contains(',') || s.contains('"') || s.contains('\n') {
        format!("\"{}\"", s.replace('"', "\"\""))
    } else {
        s.to_string()
    }
}

/// Escape XML special characters
fn escape_xml(s: &str) -> String {
    s.replace('&', "&amp;")
        .replace('<', "&lt;")
        .replace('>', "&gt;")
        .replace('"', "&quot;")
        .replace('\'', "&apos;")
}
