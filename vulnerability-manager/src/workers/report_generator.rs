use std::sync::Arc;
use std::path::PathBuf;
use tokio::time::{interval, Duration};
use sqlx::PgPool;
use tracing::{info, error, warn};
use uuid::Uuid;
use chrono::Utc;
use serde_json::json;



pub fn start_report_generator(pool: Arc<PgPool>) {
    tokio::spawn(async move {
        let mut interval = interval(Duration::from_secs(300));

        info!("ðŸ“Š Report generator worker started (interval: 5 minutes)");

        loop {
            interval.tick().await;

            match process_pending_reports(&pool).await {
                Ok(count) => {
                    if count > 0 {
                        info!("âœ… Processed {} pending reports", count);
                    }
                }
                Err(e) => {
                    error!("âŒ Report generation failed: {}", e);
                }
            }
        }
    });
}

async fn process_pending_reports(pool: &PgPool) -> Result<i64, String> {
    let pending_reports = sqlx::query!(
        r#"
        SELECT id, name, report_type as "report_type: String", 
               format as "format: String", source, created_by, scan_date
        FROM reports
        WHERE status = 'pending'
        ORDER BY created_at ASC
        LIMIT 10
        "#
    )
    .fetch_all(pool)
    .await
    .map_err(|e| format!("Failed to fetch pending reports: {}", e))?;

    let count = pending_reports.len() as i64;

    for report in pending_reports {
        let report_id = report.id;
        
        info!("â³ Processing report: {} ({})", report.name, report.report_type);

        match update_report_status(pool, report_id, "processing", None).await {
            Ok(_) => {
                match generate_report_content(
                    pool,
                    report_id,
                    &report.report_type,
                    &report.format,
                    &report.source,
                    report.created_by,
                ).await {
                    Ok((file_path, stats)) => {
                        let _ = update_report_status(
                            pool,
                            report_id,
                            "completed",
                            Some(file_path),
                        ).await;
                        
                        let _ = sqlx::query!(
                            r#"
                            UPDATE reports
                            SET processed_vulns = $2, total_vulns = $3
                            WHERE id = $1
                            "#,
                            report_id,
                            stats.0 as i32,
                            stats.1 as i32
                        )
                        .execute(pool)
                        .await;

                        info!("âœ… Report {} generated successfully", report_id);
                    }
                    Err(e) => {
                        let err_msg = format!("Generation failed: {}", e);
                        let _ = update_report_status(pool, report_id, "failed", None).await;
                        let _ = sqlx::query!(
                            "UPDATE reports SET error_message = $2 WHERE id = $1",
                            report_id,
                            err_msg
                        )
                        .execute(pool)
                        .await;
                        error!("âŒ Report {} generation error: {}", report_id, e);
                    }
                }
            }
            Err(e) => {
                error!("Failed to update report status for {}: {}", report_id, e);
            }
        }
    }

    Ok(count)
}

async fn update_report_status(
    pool: &PgPool,
    report_id: Uuid,
    status: &str,
    file_path: Option<String>,
) -> Result<(), String> {
    sqlx::query(
        "UPDATE reports SET status = $2, file_path = COALESCE($3, file_path), updated_at = NOW() WHERE id = $1"
    )
    .bind(report_id)
    .bind(status)
    .bind(file_path)
    .execute(pool)
    .await
    .map_err(|e| format!("Failed to update report status: {}", e))?;

    Ok(())
}

async fn generate_report_content(
    pool: &PgPool,
    report_id: Uuid,
    report_type: &str,
    format: &str,
    source: &str,
    _user_id: Uuid,
) -> Result<(String, (u64, u64)), String> {
    let vulnerabilities = fetch_vulnerabilities_for_report(pool, report_type, source).await?;
    
    let total_vulns = vulnerabilities.len() as u64;
    let processed_vulns = vulnerabilities.iter()
        .filter(|v| v.get("status").and_then(|s| s.as_str()) == Some("resolved"))
        .count() as u64;

    let content = match format {
        "json" => generate_json_report(&vulnerabilities, report_id)?,
        "csv" => generate_csv_report(&vulnerabilities, report_id)?,
        "xml" => generate_xml_report(&vulnerabilities, report_id)?,
        "pdf" => generate_pdf_report(&vulnerabilities, report_id)?,
        "text" => generate_text_report(&vulnerabilities, report_id)?,
        _ => return Err("Unsupported report format".to_string()),
    };

    let file_path = save_report_file(report_id, format, &content)?;

    Ok((file_path, (processed_vulns, total_vulns)))
}

async fn fetch_vulnerabilities_for_report(
    pool: &PgPool,
    report_type: &str,
    source: &str,
) -> Result<Vec<serde_json::Value>, String> {
    let vulns = sqlx::query_as::<_, (String, String, String, Option<f32>, Option<f32>)>(
        r#"
        SELECT id::text, title, severity, cvss_score, epss_score
        FROM vulnerabilities
        WHERE source = $1 AND status != 'closed'
        ORDER BY severity DESC, cvss_score DESC
        "#
    )
    .bind(source)
    .fetch_all(pool)
    .await
    .map_err(|e| format!("Failed to fetch vulnerabilities: {}", e))?;

    let mut results = Vec::new();
    for (id, title, severity, cvss, epss) in vulns {
        results.push(json!({
            "id": id,
            "title": title,
            "severity": severity,
            "cvss_score": cvss.unwrap_or(0.0),
            "epss_score": epss,
        }));
    }

    Ok(results)
}

fn generate_json_report(vulnerabilities: &[serde_json::Value], report_id: Uuid) -> Result<String, String> {
    let report = json!({
        "report_id": report_id,
        "generated_at": Utc::now().to_rfc3339(),
        "total_vulnerabilities": vulnerabilities.len(),
        "vulnerabilities": vulnerabilities,
        "severity_breakdown": {
            "critical": vulnerabilities.iter()
                .filter(|v| v.get("severity").and_then(|s| s.as_str()) == Some("critical"))
                .count(),
            "high": vulnerabilities.iter()
                .filter(|v| v.get("severity").and_then(|s| s.as_str()) == Some("high"))
                .count(),
            "medium": vulnerabilities.iter()
                .filter(|v| v.get("severity").and_then(|s| s.as_str()) == Some("medium"))
                .count(),
            "low": vulnerabilities.iter()
                .filter(|v| v.get("severity").and_then(|s| s.as_str()) == Some("low"))
                .count(),
        }
    });

    serde_json::to_string_pretty(&report)
        .map_err(|e| format!("JSON serialization error: {}", e))
}

fn generate_csv_report(vulnerabilities: &[serde_json::Value], _report_id: Uuid) -> Result<String, String> {
    let mut csv = String::from("ID,Title,Severity,CVSS Score,EPSS Score\n");

    for vuln in vulnerabilities {
        let id = vuln.get("id").and_then(|v| v.as_str()).unwrap_or("N/A");
        let title = vuln.get("title").and_then(|v| v.as_str()).unwrap_or("N/A");
        let severity = vuln.get("severity").and_then(|v| v.as_str()).unwrap_or("N/A");
        let cvss = vuln.get("cvss_score").and_then(|v| v.as_f64()).unwrap_or(0.0);
        let epss = vuln.get("epss_score")
            .and_then(|v| v.as_f64())
            .map(|e| e.to_string())
            .unwrap_or_else(|| "N/A".to_string());

        csv.push_str(&format!("\"{}\",\"{}\",\"{}\",{},{}\n", id, title, severity, cvss, epss));
    }

    Ok(csv)
}

fn generate_xml_report(vulnerabilities: &[serde_json::Value], report_id: Uuid) -> Result<String, String> {
    let mut xml = String::from("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
    xml.push_str("<report>\n");
    xml.push_str(&format!("  <id>{}</id>\n", report_id));
    xml.push_str(&format!("  <generated_at>{}</generated_at>\n", Utc::now().to_rfc3339()));
    xml.push_str(&format!("  <total_vulnerabilities>{}</total_vulnerabilities>\n", vulnerabilities.len()));
    xml.push_str("  <vulnerabilities>\n");

    for vuln in vulnerabilities {
        xml.push_str("    <vulnerability>\n");
        if let Some(id) = vuln.get("id").and_then(|v| v.as_str()) {
            xml.push_str(&format!("      <id>{}</id>\n", escape_xml(id)));
        }
        if let Some(title) = vuln.get("title").and_then(|v| v.as_str()) {
            xml.push_str(&format!("      <title>{}</title>\n", escape_xml(title)));
        }
        if let Some(severity) = vuln.get("severity").and_then(|v| v.as_str()) {
            xml.push_str(&format!("      <severity>{}</severity>\n", severity));
        }
        if let Some(cvss) = vuln.get("cvss_score").and_then(|v| v.as_f64()) {
            xml.push_str(&format!("      <cvss_score>{}</cvss_score>\n", cvss));
        }
        if let Some(epss) = vuln.get("epss_score").and_then(|v| v.as_f64()) {
            xml.push_str(&format!("      <epss_score>{}</epss_score>\n", epss));
        }
        xml.push_str("    </vulnerability>\n");
    }

    xml.push_str("  </vulnerabilities>\n");
    xml.push_str("</report>\n");

    Ok(xml)
}

fn generate_pdf_report(_vulnerabilities: &[serde_json::Value], report_id: Uuid) -> Result<String, String> {
    warn!("PDF generation requires additional dependencies. Using placeholder.");
    
    let placeholder = format!(
        "PDF Report {}\nGenerated: {}\nNote: PDF generation requires PDF library integration.",
        report_id,
        Utc::now()
    );
    
    Ok(placeholder)
}

fn generate_text_report(vulnerabilities: &[serde_json::Value], report_id: Uuid) -> Result<String, String> {
    let mut text = String::new();
    text.push_str(&format!("VULNERABILITY REPORT\n"));
    text.push_str(&format!("Report ID: {}\n", report_id));
    text.push_str(&format!("Generated: {}\n", Utc::now()));
    text.push_str(&format!("Total Vulnerabilities: {}\n", vulnerabilities.len()));
    text.push_str("\n");
    text.push_str("VULNERABILITIES:\n");
    text.push_str("================\n");

    for vuln in vulnerabilities {
        text.push_str("\n");
        if let Some(title) = vuln.get("title").and_then(|v| v.as_str()) {
            text.push_str(&format!("Title: {}\n", title));
        }
        if let Some(severity) = vuln.get("severity").and_then(|v| v.as_str()) {
            text.push_str(&format!("Severity: {}\n", severity));
        }
        if let Some(cvss) = vuln.get("cvss_score").and_then(|v| v.as_f64()) {
            text.push_str(&format!("CVSS Score: {}\n", cvss));
        }
    }

    Ok(text)
}

fn escape_xml(s: &str) -> String {
    s.replace("&", "&amp;")
        .replace("<", "&lt;")
        .replace(">", "&gt;")
        .replace("\"", "&quot;")
        .replace("'", "&apos;")
}

fn save_report_file(report_id: Uuid, format: &str, content: &str) -> Result<String, String> {
    let upload_dir = PathBuf::from("./uploads");
    
    if !upload_dir.exists() {
        std::fs::create_dir_all(&upload_dir)
            .map_err(|e| format!("Failed to create upload directory: {}", e))?;
    }

    let extension = match format {
        "json" => "json",
        "csv" => "csv",
        "xml" => "xml",
        "pdf" => "pdf",
        "text" => "txt",
        _ => "txt",
    };

    let file_name = format!("report_{}.{}", report_id, extension);
    let file_path = upload_dir.join(&file_name);

    std::fs::write(&file_path, content)
        .map_err(|e| format!("Failed to write report file: {}", e))?;

    Ok(file_path.to_string_lossy().to_string())
}
