// src/workers/notification_digest.rs
// Background worker for sending daily notification digests

use std::sync::Arc;
use tokio::time::{interval, Duration};
use sqlx::PgPool;
use tracing::{info, error};
use chrono::Utc;

/// Start notification digest worker
/// Runs daily at configured time to send digest emails
pub fn start_notification_digest(pool: Arc<PgPool>) {
    tokio::spawn(async move {
        let mut interval = interval(Duration::from_secs(86400)); // Every 24 hours

        info!("ðŸ“§ Notification digest worker started (interval: 24 hours)");

        loop {
            interval.tick().await;

            info!("ðŸ“§ Preparing daily notification digest...");

            match send_daily_digest(&pool).await {
                Ok(count) => {
                    info!("âœ… Sent {} digest notifications", count);
                }
                Err(e) => {
                    error!("âŒ Digest send failed: {}", e);
                }
            }
        }
    });
}

async fn send_daily_digest(pool: &PgPool) -> Result<i64, sqlx::Error> {
    // Get digest rules (non-immediate notifications)
    let rules = sqlx::query!(
        r#"
        SELECT id, name, email_recipients, user_ids, team_ids
        FROM notification_rules
        WHERE is_enabled = TRUE
          AND immediate = FALSE
        "#
    )
    .fetch_all(pool)
    .await?;

    let count = rules.len() as i64;

    // TODO: Implement actual digest email sending
    // For now, just log pending notifications
    for rule in rules {
        info!("ðŸ“¬ Would send digest for rule: {}", rule.name);

        // Create notification history entry
        let _ = sqlx::query!(
            r#"
            INSERT INTO notification_history (
                rule_id, event_type, entity_type, entity_id,
                channel_type, recipient, status, sent_at
            )
            VALUES ($1, 'daily_digest', 'system', gen_random_uuid(), 'email', 'digest@example.com', 'sent', NOW())
            "#,
            rule.id
        )
        .execute(pool)
        .await;
    }

    Ok(count)
}
