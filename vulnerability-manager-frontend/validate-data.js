#!/usr/bin/env node
/**
 * Data Validation Runner (JavaScript version)
 *
 * Quick validation script che non richiede compilazione TypeScript
 */

const http = require('http');

const API_BASE = 'http://localhost:8080/api';

// Helper per fare richieste HTTP
function makeRequest(path) {
  return new Promise((resolve, reject) => {
    const url = `${API_BASE}${path}`;
    console.log(`  Fetching: ${path}`);

    http.get(url, (res) => {
      let data = '';

      res.on('data', (chunk) => {
        data += chunk;
      });

      res.on('end', () => {
        try {
          resolve(JSON.parse(data));
        } catch (e) {
          resolve(data);
        }
      });
    }).on('error', (err) => {
      reject(err);
    });
  });
}

async function runValidation() {
  console.log('ðŸ” Starting Data Validation Tests...\n');
  console.log('='.repeat(80));

  let totalTests = 0;
  let passedTests = 0;
  let errors = [];

  try {
    // Test 1: Fetch vulnerabilities
    console.log('\nðŸ“Š Test 1: Fetching Vulnerabilities...');
    totalTests++;
    const vulnerabilities = await makeRequest('/vulnerabilities');
    if (Array.isArray(vulnerabilities)) {
      console.log(`  âœ… SUCCESS: Fetched ${vulnerabilities.length} vulnerabilities`);
      passedTests++;
    } else {
      console.log(`  âŒ FAIL: Expected array, got ${typeof vulnerabilities}`);
      errors.push({ test: 'Fetch Vulnerabilities', error: 'Invalid response type' });
    }

    // Test 2: Fetch assets
    console.log('\nðŸ“¦ Test 2: Fetching Assets...');
    totalTests++;
    const assets = await makeRequest('/assets');
    if (Array.isArray(assets)) {
      console.log(`  âœ… SUCCESS: Fetched ${assets.length} assets`);
      passedTests++;
    } else {
      console.log(`  âŒ FAIL: Expected array, got ${typeof assets}`);
      errors.push({ test: 'Fetch Assets', error: 'Invalid response type' });
    }

    // Test 3: Fetch teams
    console.log('\nðŸ‘¥ Test 3: Fetching Teams...');
    totalTests++;
    const teams = await makeRequest('/teams');
    if (Array.isArray(teams)) {
      console.log(`  âœ… SUCCESS: Fetched ${teams.length} teams`);
      passedTests++;
    } else {
      console.log(`  âŒ FAIL: Expected array, got ${typeof teams}`);
      errors.push({ test: 'Fetch Teams', error: 'Invalid response type' });
    }

    if (!Array.isArray(vulnerabilities) || !Array.isArray(assets) || !Array.isArray(teams)) {
      console.log('\nâš ï¸  Skipping data validation tests due to API errors');
      return;
    }

    // Test 4: Vulnerability-Asset Consistency
    console.log('\nðŸ”— Test 4: Checking Vulnerability-Asset References...');
    totalTests++;
    const assetIds = new Set(assets.map(a => a.id));
    const invalidAssetRefs = vulnerabilities.filter(v => v.asset_id && !assetIds.has(v.asset_id));

    if (invalidAssetRefs.length === 0) {
      console.log(`  âœ… SUCCESS: All ${vulnerabilities.filter(v => v.asset_id).length} asset references are valid`);
      passedTests++;
    } else {
      console.log(`  âŒ FAIL: Found ${invalidAssetRefs.length} invalid asset references`);
      errors.push({
        test: 'Vulnerability-Asset References',
        error: `${invalidAssetRefs.length} vulnerabilities reference non-existent assets`,
        details: invalidAssetRefs.slice(0, 3).map(v => ({ vuln_id: v.id, asset_id: v.asset_id }))
      });
    }

    // Test 5: Vulnerability-Team Consistency
    console.log('\nðŸ”— Test 5: Checking Vulnerability-Team References...');
    totalTests++;
    const teamIds = new Set(teams.map(t => t.id));
    const invalidTeamRefs = vulnerabilities.filter(v => v.assigned_team_id && !teamIds.has(v.assigned_team_id));

    if (invalidTeamRefs.length === 0) {
      console.log(`  âœ… SUCCESS: All ${vulnerabilities.filter(v => v.assigned_team_id).length} team references are valid`);
      passedTests++;
    } else {
      console.log(`  âŒ FAIL: Found ${invalidTeamRefs.length} invalid team references`);
      errors.push({
        test: 'Vulnerability-Team References',
        error: `${invalidTeamRefs.length} vulnerabilities reference non-existent teams`,
        details: invalidTeamRefs.slice(0, 3).map(v => ({ vuln_id: v.id, team_id: v.assigned_team_id }))
      });
    }

    // Test 6: Asset Vulnerability Counts
    console.log('\nðŸ”¢ Test 6: Checking Asset Vulnerability Counts...');
    totalTests++;
    const countMismatches = [];

    for (const asset of assets) {
      const actualCount = vulnerabilities.filter(v => v.asset_id === asset.id).length;
      const reportedCount = asset.vulnerability_count || 0;

      if (actualCount !== reportedCount) {
        countMismatches.push({
          asset_id: asset.id,
          asset_name: asset.name,
          reported: reportedCount,
          actual: actualCount,
          diff: actualCount - reportedCount
        });
      }
    }

    if (countMismatches.length === 0) {
      console.log(`  âœ… SUCCESS: All ${assets.length} asset vulnerability counts are accurate`);
      passedTests++;
    } else {
      console.log(`  âŒ FAIL: Found ${countMismatches.length} count mismatches`);
      errors.push({
        test: 'Asset Vulnerability Counts',
        error: `${countMismatches.length} assets have incorrect vulnerability counts`,
        details: countMismatches.slice(0, 3)
      });
    }

    // Test 7: CVSS Score Validation
    console.log('\nðŸ“Š Test 7: Validating CVSS Scores...');
    totalTests++;
    const invalidCVSS = vulnerabilities.filter(v => v.cvss_score < 0 || v.cvss_score > 10);

    if (invalidCVSS.length === 0) {
      console.log(`  âœ… SUCCESS: All ${vulnerabilities.length} CVSS scores are in valid range (0-10)`);
      passedTests++;
    } else {
      console.log(`  âŒ FAIL: Found ${invalidCVSS.length} invalid CVSS scores`);
      errors.push({
        test: 'CVSS Score Validation',
        error: `${invalidCVSS.length} vulnerabilities have invalid CVSS scores`,
        details: invalidCVSS.slice(0, 3).map(v => ({ id: v.id, cvss_score: v.cvss_score }))
      });
    }

    // Test 8: Required Fields
    console.log('\nâœ… Test 8: Checking Required Fields...');
    totalTests++;
    const requiredFields = ['id', 'title', 'description', 'cvss_score', 'ip_address', 'status', 'severity', 'source'];
    const incompleteVulns = [];

    for (const vuln of vulnerabilities) {
      const missing = requiredFields.filter(field => !vuln[field] && vuln[field] !== 0);
      if (missing.length > 0) {
        incompleteVulns.push({ id: vuln.id, missing });
      }
    }

    if (incompleteVulns.length === 0) {
      console.log(`  âœ… SUCCESS: All ${vulnerabilities.length} vulnerabilities have required fields`);
      passedTests++;
    } else {
      console.log(`  âŒ FAIL: Found ${incompleteVulns.length} vulnerabilities with missing fields`);
      errors.push({
        test: 'Required Fields',
        error: `${incompleteVulns.length} vulnerabilities missing required fields`,
        details: incompleteVulns.slice(0, 3)
      });
    }

  } catch (error) {
    console.log(`\nâŒ Fatal error: ${error.message}`);
    errors.push({ test: 'General', error: error.message });
  }

  // Print summary
  console.log('\n' + '='.repeat(80));
  console.log('ðŸ“‹ SUMMARY');
  console.log('='.repeat(80));
  console.log(`Total Tests:    ${totalTests}`);
  console.log(`Passed:         ${passedTests} (${totalTests > 0 ? Math.round((passedTests / totalTests) * 100) : 0}%)`);
  console.log(`Failed:         ${totalTests - passedTests}`);
  console.log(`Total Errors:   ${errors.length}`);

  if (errors.length > 0) {
    console.log('\nâš ï¸  ERRORS FOUND:');
    console.log('='.repeat(80));
    errors.forEach((err, idx) => {
      console.log(`\n${idx + 1}. ${err.test}`);
      console.log(`   Error: ${err.error}`);
      if (err.details) {
        console.log(`   Details:`, JSON.stringify(err.details, null, 2));
      }
    });
  }

  if (passedTests === totalTests && errors.length === 0) {
    console.log('\nðŸŽ‰ All data validation tests passed!');
  } else {
    console.log(`\nâš ï¸  Found ${errors.length} data integrity issues`);
  }

  console.log('='.repeat(80) + '\n');
}

// Run validation
runValidation().catch((error) => {
  console.error('Fatal error:', error);
  process.exit(1);
});
