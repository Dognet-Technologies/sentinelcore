import React, { useState, useEffect, useMemo } from 'react';
import {
  Box,
  Card,
  CardContent,
  Typography,
  Button,
  IconButton,
  TextField,
  InputAdornment,
  Chip,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Alert,
  Tooltip,
  Snackbar,
  FormHelperText,
  Grid,
  Menu,
  ListItemIcon,
  ListItemText,
} from '@mui/material';
import StatsCard from '../components/common/StatsCard';
import { DataGrid, GridColDef, GridRenderCellParams, GridRowSelectionModel } from '@mui/x-data-grid';
import {
  Add as AddIcon,
  Search as SearchIcon,
  Edit as EditIcon,
  Delete as DeleteIcon,
  Person as PersonIcon,
  AdminPanelSettings as AdminIcon,
  Badge as ReporterIcon,
} from '@mui/icons-material';
import Autocomplete from '@mui/material/Autocomplete';
import { api } from '../api/api';
import type { User, Role } from '../types';

const Users: React.FC = () => {
  const [users, setUsers] = useState<User[]>([]);
  const [loading, setLoading] = useState(true);
  const [searchTerm, setSearchTerm] = useState('');
  const [openDialog, setOpenDialog] = useState(false);
  const [editingUser, setEditingUser] = useState<User | null>(null);
  const [formData, setFormData] = useState({
    username: '',
    email: '',
    password: '',
    role: 'user' as Role,
    skills: [] as string[],
    skip_email_verification: false,
  });
  const [formErrors, setFormErrors] = useState<{
    username?: string;
    email?: string;
    password?: string;
  }>({});
  const [error, setError] = useState<string | null>(null);
  const [snackbar, setSnackbar] = useState<{ open: boolean; message: string; severity: 'success' | 'error' }>({
    open: false,
    message: '',
    severity: 'success',
  });
  const [availableSkills, setAvailableSkills] = useState<Array<{ name: string; category: string; description: string }>>([]);
  const [selectedRows, setSelectedRows] = useState<GridRowSelectionModel>([]);
  const [contextMenu, setContextMenu] = useState<{ mouseX: number; mouseY: number } | null>(null);

  useEffect(() => {
    fetchUsers();
    fetchSkills();
  }, []);

  const fetchSkills = async () => {
    try {
      const response = await api.get('/api/skills-catalog');
      setAvailableSkills(response.data);
    } catch (err) {
      console.error('Error fetching skills:', err);
    }
  };

  const fetchUsers = async () => {
    try {
      setLoading(true);
      const response = await api.get('/api/users');
      setUsers(response.data);
    } catch (err) {
      setError('Errore nel caricamento degli utenti');
      console.error('Error fetching users:', err);
    } finally {
      setLoading(false);
    }
  };

  const handleOpenDialog = (user?: User) => {
    if (user) {
      setEditingUser(user);
      setFormData({
        username: user.username,
        email: user.email || '',
        password: '',
        role: user.role,
        skills: (user as any).skills || [],
        skip_email_verification: false,
      });
    } else {
      setEditingUser(null);
      setFormData({
        username: '',
        email: '',
        password: '',
        role: 'user',
        skills: [],
        skip_email_verification: false,
      });
    }
    setOpenDialog(true);
  };

  const handleCloseDialog = () => {
    setOpenDialog(false);
    setEditingUser(null);
    setFormData({
      username: '',
      email: '',
      password: '',
      role: 'user',
      skills: [],
      skip_email_verification: false,
    });
    setFormErrors({});
  };

  const validateForm = (): boolean => {
    const errors: typeof formErrors = {};

    // Username validation
    if (!formData.username.trim()) {
      errors.username = 'Username obbligatorio';
    } else if (formData.username.length < 3) {
      errors.username = 'Username deve essere almeno 3 caratteri';
    } else if (formData.username.length > 50) {
      errors.username = 'Username non può superare 50 caratteri';
    } else if (!/^[a-zA-Z0-9_]+$/.test(formData.username)) {
      errors.username = 'Username può contenere solo lettere, numeri e underscore';
    }

    // Email validation
    if (formData.email) {
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(formData.email)) {
        errors.email = 'Formato email non valido';
      }
    }

    // Password validation (required only for new users)
    if (!editingUser) {
      if (!formData.password) {
        errors.password = 'Password obbligatoria';
      } else if (formData.password.length < 8) {
        errors.password = 'Password deve essere almeno 8 caratteri';
      } else if (!/(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/.test(formData.password)) {
        errors.password = 'Password deve contenere maiuscole, minuscole e numeri';
      }
    } else if (formData.password && formData.password.length > 0) {
      // If editing and password provided, validate it
      if (formData.password.length < 8) {
        errors.password = 'Password deve essere almeno 8 caratteri';
      } else if (!/(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/.test(formData.password)) {
        errors.password = 'Password deve contenere maiuscole, minuscole e numeri';
      }
    }

    setFormErrors(errors);
    return Object.keys(errors).length === 0;
  };

  const handleSubmit = async () => {
    if (!validateForm()) {
      return;
    }

    try {
      if (editingUser) {
        const updateData: any = {
          username: formData.username,
          email: formData.email,
          role: formData.role,
        };
        if (formData.password) {
          updateData.password = formData.password;
        }
        await api.put(`/api/users/${editingUser.id}`, updateData);
        setSnackbar({ open: true, message: 'Utente aggiornato con successo', severity: 'success' });
      } else {
        await api.post('/api/users', formData);
        setSnackbar({ open: true, message: 'Utente creato con successo', severity: 'success' });
      }
      handleCloseDialog();
      fetchUsers();
    } catch (err: any) {
      const errorMsg = err.response?.data?.error || 'Errore nel salvataggio dell\'utente';
      setSnackbar({ open: true, message: errorMsg, severity: 'error' });
    }
  };

  const handleDelete = async (id: number) => {
    if (window.confirm('Sei sicuro di voler eliminare questo utente?')) {
      try {
        await api.delete(`/api/users/${id}`);
        setSnackbar({ open: true, message: 'Utente eliminato con successo', severity: 'success' });
        fetchUsers();
      } catch (err: any) {
        const errorMsg = err.response?.data?.error || 'Errore nell\'eliminazione dell\'utente';
        setSnackbar({ open: true, message: errorMsg, severity: 'error' });
      }
    }
  };

  // Handle context menu
  const handleContextMenu = (event: React.MouseEvent) => {
    event.preventDefault();
    if (selectedRows.length === 0) return;
    setContextMenu(
      contextMenu === null
        ? { mouseX: event.clientX + 2, mouseY: event.clientY - 6 }
        : null
    );
  };

  const handleCloseContextMenu = () => {
    setContextMenu(null);
  };

  // Handle bulk delete
  const handleBulkDelete = async () => {
    if (selectedRows.length === 0) return;
    if (window.confirm(`Sei sicuro di voler eliminare ${selectedRows.length} utenti?`)) {
      try {
        await Promise.all(selectedRows.map((id) => api.delete(`/api/users/${id}`)));
        setSelectedRows([]);
        setSnackbar({ open: true, message: 'Utenti eliminati con successo', severity: 'success' });
        fetchUsers();
      } catch (err: any) {
        const errorMsg = err.response?.data?.error || 'Errore durante l\'eliminazione';
        setSnackbar({ open: true, message: errorMsg, severity: 'error' });
      }
    }
    handleCloseContextMenu();
  };

  const filteredUsers = users.filter(user =>
    user.username.toLowerCase().includes(searchTerm.toLowerCase()) ||
    user.email?.toLowerCase().includes(searchTerm.toLowerCase())
  );

  // Calculate statistics
  const stats = useMemo(() => {
    return {
      total: users.length,
      admins: users.filter(u => u.role === 'admin').length,
      team_leaders: users.filter(u => u.role === 'team_leader').length,
      regular_users: users.filter(u => u.role === 'user').length,
    };
  }, [users]);

  const columns: GridColDef[] = [
    {
      field: 'id',
      headerName: 'ID',
      width: 70,
    },
    {
      field: 'username',
      headerName: 'Username',
      width: 200,
      renderCell: (params: GridRenderCellParams) => (
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
          <PersonIcon fontSize="small" color="action" />
          {params.value}
        </Box>
      ),
    },
    {
      field: 'email',
      headerName: 'Email',
      width: 250,
    },
    {
      field: 'role',
      headerName: 'Ruolo',
      width: 150,
      renderCell: (params: GridRenderCellParams) => {
        const roleConfig: Record<string, { icon: React.ReactNode; label: string; color: 'primary' | 'info' | 'default' }> = {
          admin: { icon: <AdminIcon />, label: 'Amministratore', color: 'primary' },
          team_leader: { icon: <ReporterIcon />, label: 'Team Leader', color: 'info' },
          user: { icon: <PersonIcon />, label: 'Utente', color: 'default' },
        };
        const config = roleConfig[params.value] || roleConfig.user;
        return (
          <Chip
            icon={config.icon as React.ReactElement}
            label={config.label}
            color={config.color}
            size="small"
          />
        );
      },
    },
    {
      field: 'created_at',
      headerName: 'Data Creazione',
      width: 180,
      valueFormatter: (params) => {
        return new Date(params.value).toLocaleString('it-IT');
      },
    },
    {
      field: 'actions',
      headerName: 'Azioni',
      width: 120,
      sortable: false,
      renderCell: (params: GridRenderCellParams) => (
        <Box>
          <Tooltip title="Modifica">
            <IconButton
              size="small"
              onClick={() => handleOpenDialog(params.row as User)}
            >
              <EditIcon fontSize="small" />
            </IconButton>
          </Tooltip>
          <Tooltip title="Elimina">
            <IconButton
              size="small"
              onClick={() => handleDelete(params.row.id)}
              color="error"
            >
              <DeleteIcon fontSize="small" />
            </IconButton>
          </Tooltip>
        </Box>
      ),
    },
  ];

  return (
    <Box>
      <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 3 }}>
        <Typography variant="h4" component="h1">
          Gestione Utenti
        </Typography>
        <Button
          variant="contained"
          startIcon={<AddIcon />}
          onClick={() => handleOpenDialog()}
        >
          Nuovo Utente
        </Button>
      </Box>

      {/* Statistics Cards */}
      <Grid container spacing={3} sx={{ mb: 3 }}>
        <Grid item xs={12} sm={6} md={3}>
          <StatsCard
            title="Totale Utenti"
            value={stats.total}
            description="Numero totale di utenti registrati nel sistema di gestione vulnerabilità. Include amministratori, team leader e utenti standard. Gli utenti possono essere assegnati a team, ricevere notifiche e gestire vulnerabilità secondo i loro permessi di ruolo."
          />
        </Grid>
        <Grid item xs={12} sm={6} md={3}>
          <StatsCard
            title="Amministratori"
            value={stats.admins}
            color="error"
            description="Utenti con ruolo 'Admin' che hanno accesso completo al sistema. Gli amministratori possono gestire utenti, team, configurazioni di sistema, integrazioni e visualizzare tutte le vulnerabilità e remediation plans. Hanno privilegi elevati per configurare scanner e plugin."
          />
        </Grid>
        <Grid item xs={12} sm={6} md={3}>
          <StatsCard
            title="Team Leader"
            value={stats.team_leaders}
            color="warning"
            description="Utenti con ruolo 'Team Leader' che gestiscono team di sicurezza. I team leader possono assegnare vulnerabilità ai membri del team, creare e gestire remediation plans, e monitorare il progresso del lavoro. Hanno visibilità completa sulle attività del loro team."
          />
        </Grid>
        <Grid item xs={12} sm={6} md={3}>
          <StatsCard
            title="Utenti Standard"
            value={stats.regular_users}
            color="success"
            description="Utenti con ruolo 'User' standard che lavorano su vulnerabilità assegnate. Possono visualizzare e aggiornare le vulnerabilità a loro assegnate, aggiungere commenti, caricare allegati e aggiornare lo stato della remediation. Non possono creare o eliminare vulnerabilità."
          />
        </Grid>
      </Grid>

      {error && (
        <Alert severity="error" sx={{ mb: 2 }} onClose={() => setError(null)}>
          {error}
        </Alert>
      )}

      <Card>
        <CardContent>
          <Box sx={{ mb: 2 }}>
            <TextField
              fullWidth
              variant="outlined"
              placeholder="Cerca utenti..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              InputProps={{
                startAdornment: (
                  <InputAdornment position="start">
                    <SearchIcon />
                  </InputAdornment>
                ),
              }}
            />
          </Box>

          <Box onContextMenu={handleContextMenu}>
            <DataGrid
              rows={filteredUsers}
              columns={columns}
              initialState={{
                pagination: {
                  paginationModel: { pageSize: 10 },
                },
              }}
              pageSizeOptions={[10, 25, 50]}
              checkboxSelection
              rowSelectionModel={selectedRows}
              onRowSelectionModelChange={setSelectedRows}
              disableRowSelectionOnClick
              autoHeight
              loading={loading}
              sx={{
                '& .MuiDataGrid-cell:focus': {
                  outline: 'none',
                },
              }}
            />
          </Box>
        </CardContent>
      </Card>

      <Dialog open={openDialog} onClose={handleCloseDialog} maxWidth="sm" fullWidth>
        <DialogTitle>
          {editingUser ? 'Modifica Utente' : 'Nuovo Utente'}
        </DialogTitle>
        <DialogContent>
          <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2, mt: 2 }}>
            <TextField
              fullWidth
              label="Username"
              value={formData.username}
              onChange={(e) => {
                setFormData({ ...formData, username: e.target.value });
                if (formErrors.username) setFormErrors({ ...formErrors, username: undefined });
              }}
              required
              error={!!formErrors.username}
              helperText={formErrors.username}
            />
            <TextField
              fullWidth
              label="Email"
              type="email"
              value={formData.email}
              onChange={(e) => {
                setFormData({ ...formData, email: e.target.value });
                if (formErrors.email) setFormErrors({ ...formErrors, email: undefined });
              }}
              error={!!formErrors.email}
              helperText={formErrors.email}
            />
            <TextField
              fullWidth
              label={editingUser ? 'Nuova Password (lascia vuoto per non modificare)' : 'Password'}
              type="password"
              value={formData.password}
              onChange={(e) => {
                setFormData({ ...formData, password: e.target.value });
                if (formErrors.password) setFormErrors({ ...formErrors, password: undefined });
              }}
              required={!editingUser}
              error={!!formErrors.password}
              helperText={formErrors.password || (!editingUser ? 'Minimo 8 caratteri, maiuscole, minuscole e numeri' : '')}
            />
            <FormControl fullWidth>
              <InputLabel>Ruolo</InputLabel>
              <Select
                value={formData.role}
                onChange={(e) => setFormData({ ...formData, role: e.target.value as Role })}
                label="Ruolo"
              >
                <MenuItem value="user">Utente</MenuItem>
                <MenuItem value="team_leader">Team Leader</MenuItem>
                <MenuItem value="admin">Amministratore</MenuItem>
              </Select>
              <FormHelperText>
                Team Leader e User devono avere skills per auto-assignment
              </FormHelperText>
            </FormControl>

            <Autocomplete
              multiple
              options={availableSkills.map(s => s.name)}
              value={formData.skills}
              onChange={(_, newValue) => setFormData({ ...formData, skills: newValue })}
              renderInput={(params) => (
                <TextField
                  {...params}
                  label="Skills"
                  placeholder="Seleziona skills"
                  helperText="Skills tecniche per auto-assignment vulnerabilità (es. web, database, kubernetes)"
                />
              )}
              groupBy={(option) => {
                const skill = availableSkills.find(s => s.name === option);
                return skill?.category || 'Other';
              }}
              getOptionLabel={(option) => {
                const skill = availableSkills.find(s => s.name === option);
                return skill ? `${option} (${skill.category})` : option;
              }}
            />

            {!editingUser && (
              <FormControl>
                <Box display="flex" alignItems="center">
                  <input
                    type="checkbox"
                    id="skip-email-verification"
                    checked={formData.skip_email_verification}
                    onChange={(e) => setFormData({ ...formData, skip_email_verification: e.target.checked })}
                    style={{ marginRight: '8px' }}
                  />
                  <label htmlFor="skip-email-verification" style={{ cursor: 'pointer' }}>
                    Skip conferma email (l'utente potrà accedere immediatamente)
                  </label>
                </Box>
                <FormHelperText>
                  Se attivo, l'utente non dovrà confermare l'email e potrà fare login subito
                </FormHelperText>
              </FormControl>
            )}
          </Box>
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCloseDialog}>Annulla</Button>
          <Button onClick={handleSubmit} variant="contained">
            {editingUser ? 'Aggiorna' : 'Crea'}
          </Button>
        </DialogActions>
      </Dialog>

      {/* Context Menu */}
      <Menu
        open={contextMenu !== null}
        onClose={handleCloseContextMenu}
        anchorReference="anchorPosition"
        anchorPosition={
          contextMenu !== null
            ? { top: contextMenu.mouseY, left: contextMenu.mouseX }
            : undefined
        }
      >
        <MenuItem onClick={handleBulkDelete}>
          <ListItemIcon>
            <DeleteIcon fontSize="small" />
          </ListItemIcon>
          <ListItemText>Elimina tutto ({selectedRows.length})</ListItemText>
        </MenuItem>
      </Menu>

      <Snackbar
        open={snackbar.open}
        autoHideDuration={4000}
        onClose={() => setSnackbar({ ...snackbar, open: false })}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
      >
        <Alert
          onClose={() => setSnackbar({ ...snackbar, open: false })}
          severity={snackbar.severity}
          variant="filled"
        >
          {snackbar.message}
        </Alert>
      </Snackbar>
    </Box>
  );
};

export default Users;