// src/pages/NewReport.tsx
import React, { useState, useEffect } from 'react';
import {
  Box,
  Card,
  CardContent,
  Typography,
  Button,
  TextField,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  SelectChangeEvent,
  Stepper,
  Step,
  StepLabel,
  Alert,
  Chip,
  FormLabel,
  RadioGroup,
  FormControlLabel,
  Radio,
  Checkbox,
  FormGroup,
  IconButton,
  Snackbar,
} from '@mui/material';
import {
  ArrowBack as ArrowBackIcon,
  ArrowForward as ArrowForwardIcon,
  Save as SaveIcon,
  Cancel as CancelIcon,
  Add as AddIcon,
  Delete as DeleteIcon,
} from '@mui/icons-material';
import { useNavigate } from 'react-router-dom';
import { api } from '../api/api';
import type { Host, Vulnerability } from '../types';

const steps = ['Selezione Host', 'Selezione Vulnerabilità', 'Dettagli Report', 'Riepilogo'];

const NewReport: React.FC = () => {
  const navigate = useNavigate();
  const [activeStep, setActiveStep] = useState(0);
  const [hosts, setHosts] = useState<Host[]>([]);
  const [vulnerabilities, setVulnerabilities] = useState<Vulnerability[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  // Form state - CORREZIONE: Both selectedHosts and selectedVulnerabilities must be string[] (UUIDs)
  const [selectedHosts, setSelectedHosts] = useState<string[]>([]);
  const [selectedVulnerabilities, setSelectedVulnerabilities] = useState<string[]>([]);
  const [reportData, setReportData] = useState({
    title: '',
    description: '',
    severity: 'medium' as 'low' | 'medium' | 'high' | 'critical',
    format: 'pdf' as 'pdf' | 'json' | 'csv' | 'xml' | 'text',
    report_type: 'manual' as 'scan' | 'manual' | 'export',
    includeRemediation: true,
    includeExecutiveSummary: true,
    recipientTeams: [] as number[],
  });

  useEffect(() => {
    fetchData();
  }, []);

  const fetchData = async () => {
    try {
      setLoading(true);
      const [hostsRes, vulnsRes] = await Promise.all([
        api.get('/api/assets'),
        api.get('/api/vulnerabilities'),
      ]);
      setHosts(hostsRes.data);
      setVulnerabilities(vulnsRes.data);
    } catch (err) {
      setError('Errore nel caricamento dei dati');
      console.error('Error fetching data:', err);
    } finally {
      setLoading(false);
    }
  };

  const handleNext = () => {
    if (activeStep === 0 && selectedHosts.length === 0) {
      setError('Seleziona almeno un host');
      return;
    }
    if (activeStep === 1 && selectedVulnerabilities.length === 0) {
      setError('Seleziona almeno una vulnerabilità');
      return;
    }
    if (activeStep === 2 && !reportData.title) {
      setError('Inserisci un titolo per il report');
      return;
    }
    
    setError(null);
    setActiveStep((prevActiveStep) => prevActiveStep + 1);
  };

  const handleBack = () => {
    setActiveStep((prevActiveStep) => prevActiveStep - 1);
  };

  const [successMessage, setSuccessMessage] = useState<string | null>(null);

  const handleSubmit = async () => {
    try {
      setLoading(true);

      // Align payload with backend schema
      const payload = {
        name: reportData.title, // Backend expects 'name' not 'title'
        report_type: reportData.report_type,
        format: reportData.format,
        source: `Manual (${selectedHosts.length} hosts, ${selectedVulnerabilities.length} vulnerabilities)`,
        scan_date: new Date().toISOString(),
        // Note: Backend doesn't handle host_ids and vulnerability_ids yet
        // These would need a separate endpoint or database schema update
      };

      await api.post('/api/reports', payload);
      setSuccessMessage('Report creato con successo!');
      // Navigate after showing success message
      setTimeout(() => {
        navigate('/reports');
      }, 1500);
    } catch (err: any) {
      const errorMessage = err.response?.data?.error || 'Errore nella creazione del report';
      setError(errorMessage);
      console.error('Error creating report:', err);
    } finally {
      setLoading(false);
    }
  };

  const renderStepContent = () => {
    switch (activeStep) {
      case 0:
        return (
          <Box>
            <Typography variant="h6" gutterBottom>
              Seleziona gli host da includere nel report
            </Typography>
            <FormGroup>
              {hosts.map((host) => (
                <FormControlLabel
                  key={host.id}
                  control={
                    <Checkbox
                      checked={selectedHosts.includes(host.id)}
                      onChange={(e) => {
                        if (e.target.checked) {
                          setSelectedHosts([...selectedHosts, host.id]);
                        } else {
                          setSelectedHosts(selectedHosts.filter(id => id !== host.id));
                        }
                      }}
                    />
                  }
                  label={
                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                      <span>{host.hostname}</span>
                      <Typography variant="caption" color="text.secondary">
                        ({host.ip_address})
                      </Typography>
                      {host.vulnerability_count && host.vulnerability_count > 0 && (
                        <Chip
                          label={`${host.vulnerability_count} vuln`}
                          size="small"
                          color={host.vulnerability_count > 5 ? 'error' : 'warning'}
                        />
                      )}
                    </Box>
                  }
                />
              ))}
            </FormGroup>
          </Box>
        );

      case 1:
        // CORREZIONE: Filter using asset_id (hosts are assets) or IP address matching
        const filteredVulnerabilities = vulnerabilities.filter(vuln => {
          // If vulnerability has asset_id, check if that asset is in selected hosts
          if (vuln.asset_id !== undefined) {
            return selectedHosts.includes(vuln.asset_id);
          }
          // Otherwise match by IP address
          return hosts.some(host =>
            selectedHosts.includes(host.id) &&
            host.ip_address === vuln.ip_address
          );
        });
        
        return (
          <Box>
            <Typography variant="h6" gutterBottom>
              Seleziona le vulnerabilità da includere nel report
            </Typography>
            <FormGroup>
              {filteredVulnerabilities.map((vuln) => (
                <FormControlLabel
                  key={vuln.id}
                  control={
                    <Checkbox
                      checked={selectedVulnerabilities.includes(vuln.id)}
                      onChange={(e) => {
                        if (e.target.checked) {
                          setSelectedVulnerabilities([...selectedVulnerabilities, vuln.id]);
                        } else {
                          setSelectedVulnerabilities(selectedVulnerabilities.filter(id => id !== vuln.id));
                        }
                      }}
                    />
                  }
                  label={
                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                      <span>{vuln.title || vuln.name}</span>
                      <Chip
                        label={vuln.severity}
                        size="small"
                        color={
                          vuln.severity === 'critical' ? 'error' :
                          vuln.severity === 'high' ? 'warning' :
                          vuln.severity === 'medium' ? 'info' : 'default'
                        }
                      />
                      <Typography variant="caption" color="text.secondary">
                        (CVSS: {vuln.cvss_score})
                      </Typography>
                    </Box>
                  }
                />
              ))}
            </FormGroup>
          </Box>
        );

      case 2:
        return (
          <Box sx={{ display: 'flex', flexDirection: 'column', gap: 3 }}>
            <Typography variant="h6" gutterBottom>
              Dettagli del Report
            </Typography>
            
            <TextField
              fullWidth
              label="Titolo Report"
              value={reportData.title}
              onChange={(e) => setReportData({ ...reportData, title: e.target.value })}
              required
            />

            <TextField
              fullWidth
              label="Descrizione"
              multiline
              rows={4}
              value={reportData.description}
              onChange={(e) => setReportData({ ...reportData, description: e.target.value })}
            />

            <FormControl fullWidth>
              <InputLabel>Severità Minima</InputLabel>
              <Select
                value={reportData.severity}
                onChange={(e: SelectChangeEvent) => 
                  setReportData({ ...reportData, severity: e.target.value as any })
                }
                label="Severità Minima"
              >
                <MenuItem value="low">Bassa</MenuItem>
                <MenuItem value="medium">Media</MenuItem>
                <MenuItem value="high">Alta</MenuItem>
                <MenuItem value="critical">Critica</MenuItem>
              </Select>
            </FormControl>

            <FormControl fullWidth>
              <InputLabel>Tipo Report</InputLabel>
              <Select
                value={reportData.report_type}
                onChange={(e: SelectChangeEvent) =>
                  setReportData({ ...reportData, report_type: e.target.value as any })
                }
                label="Tipo Report"
              >
                <MenuItem value="scan">Scan Report</MenuItem>
                <MenuItem value="manual">Manual Report</MenuItem>
                <MenuItem value="export">Export Report</MenuItem>
              </Select>
            </FormControl>

            <FormControl fullWidth>
              <InputLabel>Formato Report</InputLabel>
              <Select
                value={reportData.format}
                onChange={(e: SelectChangeEvent) =>
                  setReportData({ ...reportData, format: e.target.value as any })
                }
                label="Formato Report"
              >
                <MenuItem value="pdf">PDF</MenuItem>
                <MenuItem value="json">JSON</MenuItem>
                <MenuItem value="csv">CSV</MenuItem>
                <MenuItem value="xml">XML</MenuItem>
                <MenuItem value="text">Text</MenuItem>
              </Select>
            </FormControl>

            <FormGroup>
              <FormControlLabel
                control={
                  <Checkbox
                    checked={reportData.includeRemediation}
                    onChange={(e) => 
                      setReportData({ ...reportData, includeRemediation: e.target.checked })
                    }
                  />
                }
                label="Includi suggerimenti di remediation"
              />
              <FormControlLabel
                control={
                  <Checkbox
                    checked={reportData.includeExecutiveSummary}
                    onChange={(e) => 
                      setReportData({ ...reportData, includeExecutiveSummary: e.target.checked })
                    }
                  />
                }
                label="Includi executive summary"
              />
            </FormGroup>
          </Box>
        );

      case 3:
        return (
          <Box>
            <Typography variant="h6" gutterBottom>
              Riepilogo Report
            </Typography>
            
            <Box sx={{ mt: 2 }}>
              <Typography variant="subtitle1" gutterBottom>
                <strong>Titolo:</strong> {reportData.title}
              </Typography>
              
              <Typography variant="subtitle1" gutterBottom>
                <strong>Host selezionati:</strong> {selectedHosts.length}
              </Typography>
              
              <Typography variant="subtitle1" gutterBottom>
                <strong>Vulnerabilità selezionate:</strong> {selectedVulnerabilities.length}
              </Typography>

              <Typography variant="subtitle1" gutterBottom>
                <strong>Tipo Report:</strong> {reportData.report_type}
              </Typography>

              <Typography variant="subtitle1" gutterBottom>
                <strong>Formato:</strong> {reportData.format.toUpperCase()}
              </Typography>

              <Typography variant="subtitle1" gutterBottom>
                <strong>Severità minima:</strong> {reportData.severity}
              </Typography>
              
              {reportData.description && (
                <Box sx={{ mt: 2 }}>
                  <Typography variant="subtitle1" gutterBottom>
                    <strong>Descrizione:</strong>
                  </Typography>
                  <Typography variant="body2" color="text.secondary">
                    {reportData.description}
                  </Typography>
                </Box>
              )}
            </Box>
          </Box>
        );

      default:
        return 'Passaggio sconosciuto';
    }
  };

  return (
    <Box>
      <Box sx={{ mb: 3, display: 'flex', alignItems: 'center', gap: 2 }}>
        <IconButton onClick={() => navigate('/reports')}>
          <ArrowBackIcon />
        </IconButton>
        <Typography variant="h4">
          Nuovo Report
        </Typography>
      </Box>

      {error && (
        <Alert severity="error" sx={{ mb: 2 }} onClose={() => setError(null)}>
          {error}
        </Alert>
      )}

      <Card>
        <CardContent>
          <Stepper activeStep={activeStep} sx={{ mb: 4 }}>
            {steps.map((label) => (
              <Step key={label}>
                <StepLabel>{label}</StepLabel>
              </Step>
            ))}
          </Stepper>

          {renderStepContent()}

          <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 4 }}>
            <Button
              disabled={activeStep === 0}
              onClick={handleBack}
              startIcon={<ArrowBackIcon />}
            >
              Indietro
            </Button>
            
            <Box sx={{ display: 'flex', gap: 2 }}>
              <Button
                variant="outlined"
                onClick={() => navigate('/reports')}
                startIcon={<CancelIcon />}
              >
                Annulla
              </Button>
              
              {activeStep === steps.length - 1 ? (
                <Button
                  variant="contained"
                  onClick={handleSubmit}
                  disabled={loading}
                  startIcon={<SaveIcon />}
                >
                  Crea Report
                </Button>
              ) : (
                <Button
                  variant="contained"
                  onClick={handleNext}
                  endIcon={<ArrowForwardIcon />}
                >
                  Avanti
                </Button>
              )}
            </Box>
          </Box>
        </CardContent>
      </Card>

      {/* Success Snackbar */}
      <Snackbar
        open={!!successMessage}
        autoHideDuration={3000}
        onClose={() => setSuccessMessage(null)}
        anchorOrigin={{ vertical: 'top', horizontal: 'center' }}
      >
        <Alert
          onClose={() => setSuccessMessage(null)}
          severity="success"
          sx={{ width: '100%' }}
        >
          {successMessage}
        </Alert>
      </Snackbar>
    </Box>
  );
};

export default NewReport;