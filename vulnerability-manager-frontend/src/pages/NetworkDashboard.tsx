// NetworkDashboard.tsx - Comprehensive Vulnerability Management Dashboard
// Entuity-style interface focused on vulnerability metrics and asset security

import React, { useState, useEffect } from 'react';
import {
  Box,
  Grid,
  Typography,
  Button,
  Stack,
  Paper,
  CircularProgress,
  Alert,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  MenuItem,
  useTheme,
} from '@mui/material';
import {
  Refresh as RefreshIcon,
  Dashboard as DashboardIcon,
  PlayArrow as PlayIcon,
} from '@mui/icons-material';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import NetworkTopology from '../components/NetworkTopology';
import DeviceDetailView from '../components/DeviceDetailView';
import KeyInfoDashlet from '../components/dashlets/KeyInfoDashlet';
import ChartDashlet from '../components/dashlets/ChartDashlet';
import TableDashlet from '../components/dashlets/TableDashlet';
import { NetworkDevice, NetworkTopology as NetworkTopologyType } from '../types/network';
import apiClient from '../services/api';
import { networkApi, StartScanRequest, NetworkTopologyWithVulnerabilities } from '../api/network';
import { useRoleAccess } from '../hooks/useRoleAccess';
import StatsCard from '../components/common/StatsCard';

// Fetch real network topology from backend API
const fetchNetworkTopology = async (): Promise<NetworkTopologyType> => {
  try {
    const response = await apiClient.get<any>('/api/network/topology-with-vulnerabilities');

    // Map backend response to frontend NetworkDevice type
    const mappedDevices = response.data.devices.map((device: any) => {
      // Backend returns vulnerabilities for assets and vulnerability_metrics for network_devices
      const vulnData = device.vulnerabilities || device.vulnerability_metrics;
      
      return {
        ...device,
        // Map device_type to type for frontend compatibility
        // Backend returns device_type as enum (Router, Server, etc)
        type: device.device_type?.toLowerCase() || 'unknown',
        // Map device_status to status for frontend compatibility
        status: (device.device_status || device.status || 'unknown') as 'online' | 'offline' | 'warning' | 'maintenance' | 'unknown',
        // Calculate severity from vulnerabilities or use criticality field
        severity: device.vulnerabilities?.critical ? 'critical' 
          : device.vulnerabilities?.high ? 'high' 
          : device.vulnerabilities?.medium ? 'medium' 
          : device.criticality || 'none',
        incidentCount: device.incident_count || 0,
        lastSeen: device.last_seen,
        macAddress: device.mac_address,
        ipAddress: device.ip_address,
        name: device.hostname || device.ip_address || 'Unknown',
        manufacturer: device.vendor,
        model: device.model,
        osVersion: device.os_version || device.os_name,
        vulnerabilityMetrics: vulnData ? {
          totalVulnerabilities: vulnData.total || vulnData.total_vulnerabilities || 0,
          criticalCount: vulnData.critical || vulnData.critical_count || 0,
          highCount: vulnData.high || vulnData.high_count || 0,
          mediumCount: vulnData.medium || vulnData.medium_count || 0,
          lowCount: vulnData.low || vulnData.low_count || 0,
          resolvedCount: vulnData.resolved_count || 0,
          riskScore: vulnData.risk_score || 0,
          lastScanDate: vulnData.last_scan_date,
          scanStatus: vulnData.scan_status,
          complianceScore: vulnData.compliance_score,
        } : undefined,
        remediationInfo: device.remediation_info,
        assignment: device.assignment,
      };
    });

    return {
      devices: mappedDevices,
      links: response.data.links || [],
      lastUpdated: response.data.last_updated || new Date().toISOString(),
    };
  } catch (error) {
    console.error('Failed to fetch network topology:', error);
    throw error;
  }
};

const NetworkDashboard: React.FC = () => {
  const theme = useTheme();
  const queryClient = useQueryClient();
  const { isAdmin, isTeamLeader } = useRoleAccess();
  const [networkData, setNetworkData] = useState<NetworkTopologyType | null>(null);
  const [selectedDevice, setSelectedDevice] = useState<NetworkDevice | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Network scan state
  const [scanDialogOpen, setScanDialogOpen] = useState(false);
  const [scanFormData, setScanFormData] = useState<StartScanRequest>({
    scan_name: 'Network Scan',
    scan_type: 'arp',
    target_range: '192.168.1.0/24',
  });
  const [currentScanId, setCurrentScanId] = useState<string | null>(null);

  // Start scan mutation
  const startScanMutation = useMutation({
    mutationFn: (request: StartScanRequest) => networkApi.startScan(request),
    onSuccess: (data) => {
      setCurrentScanId(data.scan_id);
      setScanDialogOpen(false);
    },
  });

  // Poll scan status
  const { data: scanStatus } = useQuery({
    queryKey: ['scan-status', currentScanId],
    queryFn: () => networkApi.getScanStatus(currentScanId!),
    enabled: !!currentScanId,
    refetchInterval: 2000, // Poll every 2s
  });

  // Stop polling when scan is complete
  useEffect(() => {
    if (scanStatus && (scanStatus.status === 'completed' || scanStatus.status === 'failed')) {
      setCurrentScanId(null);
      loadNetworkTopology(); // Refresh topology
    }
  }, [scanStatus]);

  // Load network topology on component mount
  useEffect(() => {
    loadNetworkTopology();
  }, []);

  const loadNetworkTopology = async () => {
    setLoading(true);
    setError(null);
    try {
      const data = await fetchNetworkTopology();
      setNetworkData(data);
    } catch (err) {
      console.error('Error loading network topology:', err);
      setError('Failed to load network data. Please try again later.');
      setNetworkData(null);
    } finally {
      setLoading(false);
    }
  };

  const handleRefresh = () => {
    loadNetworkTopology();
  };

  // Show loading state
  if (loading || !networkData) {
    return (
      <Box sx={{ mt: 4, mb: 4, display: 'flex', flexDirection: 'column', justifyContent: 'center', alignItems: 'center', minHeight: '60vh' }}>
        <CircularProgress size={60} sx={{ mb: 2 }} />
        <Typography variant="h6" color="text.secondary">
          Loading network topology...
        </Typography>
      </Box>
    );
  }

  // Show error alert if there was an error
  const errorAlert = error && (
    <Alert severity="warning" sx={{ mb: 2 }} onClose={() => setError(null)}>
      {error}
    </Alert>
  );

  // Calculate vulnerability statistics
  const totalDevices = networkData.devices.length;
  const onlineDevices = networkData.devices.filter(d => d.status === 'online').length;
  const criticalDevices = networkData.devices.filter(d => d.severity === 'critical').length;
  const totalVulnerabilities = networkData.devices.reduce((sum, d) =>
    sum + (d.vulnerabilityMetrics?.totalVulnerabilities || 0), 0
  );
  const criticalVulnerabilities = networkData.devices.reduce((sum, d) =>
    sum + (d.vulnerabilityMetrics?.criticalCount || 0), 0
  );
  const avgRiskScore = Math.round(
    networkData.devices.reduce((sum, d) => sum + (d.vulnerabilityMetrics?.riskScore || 0), 0) / totalDevices
  );

  // Devices with critical vulnerabilities table
  const criticalDevicesColumns = [
    { id: 'name', label: 'Device Name' },
    { id: 'ipAddress', label: 'IP Address' },
    { id: 'severity', label: 'Severity' },
    { id: 'criticalCount', label: 'Critical Vulns', numeric: true },
    { id: 'riskScore', label: 'Risk Score', numeric: true },
    { id: 'assignedTeam', label: 'Assigned Team' },
  ];

  const criticalDevicesRows = networkData.devices
    .filter(d => (d.vulnerabilityMetrics?.criticalCount || 0) > 0)
    .map(d => ({
      id: d.id,
      name: d.name,
      ipAddress: d.ipAddress,
      severity: d.severity,
      criticalCount: d.vulnerabilityMetrics?.criticalCount || 0,
      riskScore: d.vulnerabilityMetrics?.riskScore || 0,
      assignedTeam: d.assignment?.assignedTeamName || 'Unassigned',
    }));

  if (selectedDevice) {
    return (
      <Box sx={{ p: 3 }}>
        <Button
          startIcon={<DashboardIcon />}
          onClick={() => setSelectedDevice(null)}
          sx={{ mb: 2 }}
        >
          Back to Dashboard
        </Button>
        <DeviceDetailView device={selectedDevice} onRefresh={handleRefresh} />
      </Box>
    );
  }

  return (
    <Box sx={{ p: 3 }}>
      {/* Error Alert */}
      {errorAlert}

      {/* Header */}
      <Stack direction="row" justifyContent="space-between" alignItems="center" mb={3}>
        <Box>
          <Typography variant="h4" gutterBottom sx={{ fontWeight: 600 }}>
            Network Topology & Vulnerability Dashboard
          </Typography>
          <Typography variant="body2" color="text.secondary">
            Real-time asset vulnerability monitoring • Last updated: {new Date(networkData.lastUpdated).toLocaleString()}
            {currentScanId && scanStatus && ` • Scanning: ${scanStatus.devices_found} devices found (${scanStatus.progress_percent}%)`}
          </Typography>
        </Box>
        <Stack direction="row" spacing={2}>
          <Button
            variant="outlined"
            startIcon={<PlayIcon />}
            onClick={() => setScanDialogOpen(true)}
            disabled={!!currentScanId}
          >
            {currentScanId ? 'Scanning...' : 'Start Network Scan'}
          </Button>
          <Button
            variant="contained"
            startIcon={<RefreshIcon />}
            onClick={handleRefresh}
          >
            Refresh All
          </Button>
        </Stack>
      </Stack>

      {/* Vulnerability Overview Cards */}
      <Grid container spacing={3} mb={3}>
        <Grid item xs={12} sm={6} md={3}>
          <StatsCard
            title="Total Assets"
            value={totalDevices}
            description="Numero totale di asset di rete scoperti e monitorati dalla Network Topology Dashboard. Include server, workstation, router, switch, firewall e altri dispositivi di rete. Gli asset vengono identificati attraverso scansioni di rete automatiche e possono essere categorizzati per tipo, criticità e vulnerabilità associate."
          />
        </Grid>
        <Grid item xs={12} sm={6} md={3}>
          <StatsCard
            title="Critical Risk Assets"
            value={criticalDevices}
            color="error"
            description="Asset classificati come a rischio critico in base al numero e severità delle vulnerabilità rilevate. Un asset è considerato critico se ha vulnerabilità con CVSS &gt;= 9.0 o se il Risk Score complessivo supera la soglia critica. Questi asset richiedono remediation immediata e potrebbero necessitare di isolamento dalla rete."
          />
        </Grid>
        <Grid item xs={12} sm={6} md={3}>
          <StatsCard
            title="Critical Vulnerabilities"
            value={criticalVulnerabilities}
            color="error"
            description="Numero totale di vulnerabilità con severità Critical (CVSS score &gt;= 9.0) presenti su tutti gli asset di rete. Le vulnerabilità critiche rappresentano rischi gravi che potrebbero consentire compromissione remota, escalation di privilegi o denial of service. Richiedono patching immediato entro 24-48 ore secondo gli SLA di sicurezza."
          />
        </Grid>
        <Grid item xs={12} sm={6} md={3}>
          <StatsCard
            title="Average Risk Score"
            value={avgRiskScore}
            color={avgRiskScore > 70 ? "error" : "warning"}
            description="Punteggio medio di rischio calcolato su tutti gli asset di rete. Il Risk Score combina severità delle vulnerabilità, esposizione dell'asset, criticità del business e altri fattori contestuali. Valori superiori a 70 indicano un livello di rischio elevato che richiede attenzione immediata da parte del team di sicurezza e possibili azioni di mitigazione."
          />
        </Grid>
      </Grid>

      {/* Main Dashboard Grid */}
      <Grid container spacing={3}>
        {/* Network Topology - Full width */}
        <Grid item xs={12} sx={{ minHeight: '1500px' }}>
          <NetworkTopology
            data={networkData}
            onDeviceClick={setSelectedDevice}
            onRefresh={handleRefresh}
            height="100%"
            isAdmin={isAdmin()}
            isTeamLeader={isTeamLeader()}
          />
        </Grid>

        {/* Vulnerability Summary */}
        <Grid item xs={12} md={6}>
          <KeyInfoDashlet
            title="Vulnerability Summary"
            status={criticalVulnerabilities > 0 ? 'warning' : 'online'}
            severity={criticalVulnerabilities > 10 ? 'critical' : criticalVulnerabilities > 0 ? 'high' : 'none'}
            primaryInfo={[
              { label: 'Total Vulnerabilities', value: totalVulnerabilities, severity: criticalVulnerabilities > 0 ? 'high' : 'none' },
              { label: 'Critical', value: criticalVulnerabilities, severity: criticalVulnerabilities > 0 ? 'critical' : 'none' },
              { label: 'High', value: networkData.devices.reduce((sum, d) => sum + (d.vulnerabilityMetrics?.highCount || 0), 0), severity: 'high' },
              { label: 'Medium', value: networkData.devices.reduce((sum, d) => sum + (d.vulnerabilityMetrics?.mediumCount || 0), 0), severity: 'medium' },
            ]}
            secondaryInfo={[
              { label: 'Assets Scanned', value: `${onlineDevices}/${totalDevices}` },
              { label: 'Avg Compliance', value: `${Math.round(networkData.devices.reduce((sum, d) => sum + (d.vulnerabilityMetrics?.complianceScore || 0), 0) / totalDevices)}%` },
              { label: 'Pending Remediations', value: networkData.devices.reduce((sum, d) => sum + (d.remediationInfo?.pendingRemediations || 0), 0) },
            ]}
            incidentCount={criticalVulnerabilities}
            lastUpdated={networkData.lastUpdated}
          />
        </Grid>

        {/* Vulnerability Trend Chart */}
        <Grid item xs={12} md={6}>
          <ChartDashlet
            title="Vulnerability Trend"
            subtitle="Total vulnerabilities over last 30 days"
            chartType="line"
            series={[
              {
                name: 'Vulnerabilities',
                data: [],
                color: (theme as any).severity?.critical || theme.palette.error.main,
              },
            ]}
            currentValue={totalVulnerabilities}
            currentUnit=" vulns"
            threshold={{ warning: 50, critical: 100 }}
            onRefresh={handleRefresh}
            timeRange="30d"
          />
        </Grid>

        {/* Devices with Critical Vulnerabilities Table */}
        <Grid item xs={12}>
          <TableDashlet
            title="Critical Risk Assets"
            subtitle={`${criticalDevicesRows.length} assets with critical vulnerabilities`}
            columns={criticalDevicesColumns}
            rows={criticalDevicesRows}
            onRowClick={(row) => {
              const device = networkData.devices.find(d => d.id === row.id);
              if (device) setSelectedDevice(device);
            }}
            onRefresh={handleRefresh}
            searchable
            sortable
          />
        </Grid>
      </Grid>

      {/* Network Scan Dialog */}
      <Dialog open={scanDialogOpen} onClose={() => setScanDialogOpen(false)} maxWidth="sm" fullWidth>
        <DialogTitle>Start Network Scan</DialogTitle>
        <DialogContent>
          <Stack spacing={2} sx={{ mt: 1 }}>
            <TextField
              select
              label="Scan Type"
              fullWidth
              value={scanFormData.scan_type}
              onChange={(e) => setScanFormData({ ...scanFormData, scan_type: e.target.value })}
            >
              <MenuItem value="arp">ARP Scan (Fast)</MenuItem>
              <MenuItem value="ping">Ping Scan</MenuItem>
              <MenuItem value="full">Full Port Scan</MenuItem>
            </TextField>
            <TextField
              label="Target Range (CIDR)"
              fullWidth
              value={scanFormData.target_range}
              onChange={(e) => setScanFormData({ ...scanFormData, target_range: e.target.value })}
              placeholder="192.168.1.0/24"
              helperText="Enter network range in CIDR notation"
            />
          </Stack>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setScanDialogOpen(false)}>Cancel</Button>
          <Button
            variant="contained"
            onClick={() => startScanMutation.mutate({ ...scanFormData, scan_name: `Scan ${new Date().toLocaleTimeString()}` })}
            disabled={startScanMutation.isPending}
            startIcon={startScanMutation.isPending ? <CircularProgress size={20} /> : <PlayIcon />}
          >
            {startScanMutation.isPending ? 'Starting...' : 'Start Scan'}
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default NetworkDashboard;
