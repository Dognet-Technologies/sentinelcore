import React, { useState, useEffect } from 'react';
import {
  Box,
  Card,
  CardContent,
  Typography,
  IconButton,
  TextField,
  InputAdornment,
  Chip,
  Tooltip,
  Menu,
  MenuItem,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Button,
  Alert,
  Snackbar,
  CircularProgress,
} from '@mui/material';
import { DataGrid, GridColDef, GridRenderCellParams } from '@mui/x-data-grid';
import {
  Search as SearchIcon,
  Download as DownloadIcon,
  Visibility as VisibilityIcon,
  MoreVert as MoreVertIcon,
  PictureAsPdf as PdfIcon,
  Code as JsonIcon,
  Language as HtmlIcon,
} from '@mui/icons-material';
import { useNavigate } from 'react-router-dom';
import { api } from '../api/api';
import { Report } from '../types';

const ReportHistory: React.FC = () => {
  const navigate = useNavigate();
  const [reports, setReports] = useState<Report[]>([]);
  const [loading, setLoading] = useState(true);
  const [searchTerm, setSearchTerm] = useState('');
  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);
  const [selectedReport, setSelectedReport] = useState<Report | null>(null);

  // Email dialog state
  const [emailDialogOpen, setEmailDialogOpen] = useState(false);
  const [emailAddress, setEmailAddress] = useState('');
  const [emailSending, setEmailSending] = useState(false);

  // Snackbar state
  const [snackbar, setSnackbar] = useState<{ open: boolean; message: string; severity: 'success' | 'error' | 'info' }>({
    open: false,
    message: '',
    severity: 'info'
  });

  // Duplicate loading state
  const [duplicating, setDuplicating] = useState(false);

  useEffect(() => {
    fetchReports();
  }, []);

  const fetchReports = async () => {
    try {
      setLoading(true);
      const response = await api.get('/api/reports');
      setReports(response.data);
    } catch (err) {
      console.error('Error fetching reports:', err);
    } finally {
      setLoading(false);
    }
  };

  const handleMenuOpen = (event: React.MouseEvent<HTMLElement>, report: Report) => {
    setAnchorEl(event.currentTarget);
    setSelectedReport(report);
  };

  const handleMenuClose = () => {
    setAnchorEl(null);
    setSelectedReport(null);
  };

  const handleDownload = async (report: Report) => {
    try {
      const response = await api.get(`/api/reports/${report.id}/download`, {
        responseType: 'blob',
      });

      const url = window.URL.createObjectURL(new Blob([response.data]));
      const link = document.createElement('a');
      link.href = url;
      link.setAttribute('download', `${report.name}.${report.format}`);
      document.body.appendChild(link);
      link.click();
      link.remove();
    } catch (err) {
      console.error('Error downloading report:', err);
      setSnackbar({ open: true, message: 'Errore nel download del report', severity: 'error' });
    }
  };

  // Open email dialog
  const handleOpenEmailDialog = () => {
    setEmailDialogOpen(true);
    handleMenuClose();
  };

  // Send report via email
  const handleSendEmail = async () => {
    if (!selectedReport || !emailAddress) return;

    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(emailAddress)) {
      setSnackbar({ open: true, message: 'Inserisci un indirizzo email valido', severity: 'error' });
      return;
    }

    try {
      setEmailSending(true);
      await api.post(`/api/reports/${selectedReport.id}/send`, {
        email: emailAddress,
      });
      setSnackbar({ open: true, message: `Report inviato a ${emailAddress}`, severity: 'success' });
      setEmailDialogOpen(false);
      setEmailAddress('');
    } catch (err) {
      console.error('Error sending report:', err);
      setSnackbar({ open: true, message: 'Errore nell\'invio del report. Verifica la configurazione email.', severity: 'error' });
    } finally {
      setEmailSending(false);
    }
  };

  // Duplicate report
  const handleDuplicateReport = async () => {
    if (!selectedReport) return;

    try {
      setDuplicating(true);
      handleMenuClose();

      // Use the duplicate endpoint which handles everything automatically
      await api.post(`/api/reports/${selectedReport.id}/duplicate`);

      setSnackbar({ open: true, message: 'Report duplicato con successo', severity: 'success' });
      fetchReports(); // Refresh the list
    } catch (err) {
      console.error('Error duplicating report:', err);
      setSnackbar({ open: true, message: 'Errore nella duplicazione del report', severity: 'error' });
    } finally {
      setDuplicating(false);
    }
  };

  const getFormatIcon = (format: string) => {
    switch (format) {
      case 'pdf':
        return <PdfIcon />;
      case 'html':
        return <HtmlIcon />;
      case 'json':
        return <JsonIcon />;
      default:
        return null;
    }
  };

  const getSeverityColor = (severity: string) => {
    switch (severity) {
      case 'critical':
        return 'error';
      case 'high':
        return 'warning';
      case 'medium':
        return 'info';
      case 'low':
        return 'success';
      default:
        return 'default';
    }
  };

  const filteredReports = reports.filter(report =>
    report.name?.toLowerCase().includes(searchTerm.toLowerCase()) ||
    report.created_by_name?.toLowerCase().includes(searchTerm.toLowerCase()) ||
    report.source?.toLowerCase().includes(searchTerm.toLowerCase())
  );

  const columns: GridColDef[] = [
    {
      field: 'name',
      headerName: 'Nome',
      flex: 1,
      renderCell: (params: GridRenderCellParams) => (
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
          {getFormatIcon(params.row.format)}
          <Typography variant="body2">{params.value}</Typography>
        </Box>
      ),
    },
    {
      field: 'status',
      headerName: 'Stato',
      width: 120,
      renderCell: (params: GridRenderCellParams) => (
        <Chip
          label={params.value}
          color={getSeverityColor(params.value)}
          size="small"
        />
      ),
    },
    {
      field: 'report_type',
      headerName: 'Tipo',
      width: 100,
      renderCell: (params: GridRenderCellParams) => (
        <Chip label={params.value} size="small" variant="outlined" />
      ),
    },
    {
      field: 'total_vulns',
      headerName: 'VulnerabilitÃ ',
      width: 120,
      renderCell: (params: GridRenderCellParams) => {
        const value = params.value || 0;
        return (
          <Chip
            label={value}
            size="small"
            color={value > 10 ? 'error' : value > 5 ? 'warning' : 'default'}
          />
        );
      },
    },
    {
      field: 'created_by_name',
      headerName: 'Creato da',
      width: 150,
    },
    {
      field: 'created_at',
      headerName: 'Data Creazione',
      width: 180,
      valueFormatter: (params) => {
        return new Date(params.value).toLocaleString('it-IT');
      },
    },
    {
      field: 'actions',
      headerName: 'Azioni',
      width: 120,
      sortable: false,
      renderCell: (params: GridRenderCellParams) => (
        <Box>
          <Tooltip title="Visualizza">
            <IconButton
              size="small"
              onClick={() => navigate(`/reports/${params.row.id}`)}
            >
              <VisibilityIcon fontSize="small" />
            </IconButton>
          </Tooltip>
          <Tooltip title="Download">
            <IconButton
              size="small"
              onClick={() => handleDownload(params.row as Report)}
            >
              <DownloadIcon fontSize="small" />
            </IconButton>
          </Tooltip>
          <IconButton
            size="small"
            onClick={(e) => handleMenuOpen(e, params.row as Report)}
          >
            <MoreVertIcon fontSize="small" />
          </IconButton>
        </Box>
      ),
    },
  ];

  return (
    <Box>
      <Typography variant="h4" component="h1" gutterBottom>
        Storico Report
      </Typography>

      <Card>
        <CardContent>
          <Box sx={{ mb: 2 }}>
            <TextField
              fullWidth
              variant="outlined"
              placeholder="Cerca report..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              InputProps={{
                startAdornment: (
                  <InputAdornment position="start">
                    <SearchIcon />
                  </InputAdornment>
                ),
              }}
            />
          </Box>

          <DataGrid
            rows={filteredReports}
            columns={columns}
            initialState={{
              pagination: {
                paginationModel: { pageSize: 10 },
              },
            }}
            pageSizeOptions={[10, 25, 50]}
            checkboxSelection
            disableRowSelectionOnClick
            autoHeight
            loading={loading}
            sx={{
              '& .MuiDataGrid-cell:focus': {
                outline: 'none',
              },
            }}
          />
        </CardContent>
      </Card>

      <Menu
        anchorEl={anchorEl}
        open={Boolean(anchorEl)}
        onClose={handleMenuClose}
      >
        <MenuItem onClick={() => {
          if (selectedReport) {
            navigate(`/reports/${selectedReport.id}/edit`);
          }
          handleMenuClose();
        }}>
          Modifica
        </MenuItem>
        <MenuItem onClick={handleOpenEmailDialog}>
          Invia via Email
        </MenuItem>
        <MenuItem onClick={handleDuplicateReport} disabled={duplicating}>
          {duplicating ? 'Duplicando...' : 'Duplica'}
        </MenuItem>
        <MenuItem onClick={() => {
          if (selectedReport) {
            // Implementare logica di eliminazione
            if (window.confirm('Sei sicuro di voler eliminare questo report?')) {
              api.delete(`/api/reports/${selectedReport.id}`).then(() => {
                fetchReports();
              });
            }
          }
          handleMenuClose();
        }} sx={{ color: 'error.main' }}>
          Elimina
        </MenuItem>
      </Menu>

      {/* Email Dialog */}
      <Dialog open={emailDialogOpen} onClose={() => setEmailDialogOpen(false)} maxWidth="sm" fullWidth>
        <DialogTitle>Invia Report via Email</DialogTitle>
        <DialogContent>
          <TextField
            autoFocus
            margin="dense"
            label="Indirizzo Email"
            type="email"
            fullWidth
            variant="outlined"
            value={emailAddress}
            onChange={(e) => setEmailAddress(e.target.value)}
            placeholder="esempio@email.com"
            sx={{ mt: 1 }}
          />
          {selectedReport && (
            <Typography variant="body2" color="text.secondary" sx={{ mt: 2 }}>
              Report: <strong>{selectedReport.name}</strong>
            </Typography>
          )}
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setEmailDialogOpen(false)}>Annulla</Button>
          <Button
            onClick={handleSendEmail}
            variant="contained"
            disabled={emailSending || !emailAddress}
          >
            {emailSending ? <CircularProgress size={20} /> : 'Invia'}
          </Button>
        </DialogActions>
      </Dialog>

      {/* Snackbar for notifications */}
      <Snackbar
        open={snackbar.open}
        autoHideDuration={4000}
        onClose={() => setSnackbar({ ...snackbar, open: false })}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
      >
        <Alert
          onClose={() => setSnackbar({ ...snackbar, open: false })}
          severity={snackbar.severity}
          sx={{ width: '100%' }}
        >
          {snackbar.message}
        </Alert>
      </Snackbar>
    </Box>
  );
};

export default ReportHistory;