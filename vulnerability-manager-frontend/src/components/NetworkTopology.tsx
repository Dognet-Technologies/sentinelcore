// NetworkTopology.tsx - Entuity-style network topology visualization
import React, { useState, useCallback, useMemo } from 'react';
import {
  Box,
  Card,
  CardContent,
  CardHeader,
  IconButton,
  Tooltip,
  ToggleButtonGroup,
  ToggleButton,
  Chip,
  Typography,
  Stack,
} from '@mui/material';
import {
  ZoomIn as ZoomInIcon,
  ZoomOut as ZoomOutIcon,
  FitScreen as FitScreenIcon,
  Refresh as RefreshIcon,
  Map as MapIcon,
  AccountTree as TopologyIcon,
  FilterList as FilterIcon,
} from '@mui/icons-material';
import { entuityColors, getDeviceStatusColor, getLinkStatusColor } from '../theme/entuityTheme';
import { NetworkDevice, NetworkLink, NetworkTopology as NetworkTopologyType } from '../types/network';

interface NetworkTopologyProps {
  data: NetworkTopologyType;
  onDeviceClick?: (device: NetworkDevice) => void;
  onRefresh?: () => void;
  height?: number | string;
}

type ViewMode = 'topology' | 'geographical';

// Device icon mapping
const getDeviceIcon = (type: string): string => {
  switch (type) {
    case 'router': return 'üåê';
    case 'switch': return 'üîÄ';
    case 'server': return 'üñ•Ô∏è';
    case 'firewall': return 'üõ°Ô∏è';
    case 'gateway': return 'üö™';
    case 'wireless': return 'üì°';
    case 'endpoint': return 'üíª';
    default: return 'üì¶';
  }
};

const NetworkTopology: React.FC<NetworkTopologyProps> = ({
  data,
  onDeviceClick,
  onRefresh,
  height = 600,
}) => {
  const [viewMode, setViewMode] = useState<ViewMode>('topology');
  const [zoom, setZoom] = useState(1);
  const [selectedDevice, setSelectedDevice] = useState<string | null>(null);

  // Calculate network statistics
  const stats = useMemo(() => {
    const total = data.devices.length;
    const online = data.devices.filter(d => d.status === 'online').length;
    const critical = data.devices.filter(d => d.severity === 'critical').length;
    const warning = data.devices.filter(d => d.severity === 'high' || d.severity === 'medium').length;

    return { total, online, critical, warning };
  }, [data.devices]);

  const handleDeviceClick = useCallback((device: NetworkDevice) => {
    setSelectedDevice(device.id);
    onDeviceClick?.(device);
  }, [onDeviceClick]);

  const handleZoomIn = () => setZoom(prev => Math.min(prev + 0.2, 3));
  const handleZoomOut = () => setZoom(prev => Math.max(prev - 0.2, 0.5));
  const handleFitScreen = () => setZoom(1);

  // Simple force-directed layout calculation
  const layoutDevices = useMemo(() => {
    const width = 800;
    const height = 600;
    const centerX = width / 2;
    const centerY = height / 2;

    return data.devices.map((device, index) => {
      const angle = (index / data.devices.length) * 2 * Math.PI;
      const radius = Math.min(width, height) * 0.35;

      return {
        ...device,
        x: centerX + radius * Math.cos(angle),
        y: centerY + radius * Math.sin(angle),
      };
    });
  }, [data.devices]);

  return (
    <Card sx={{ height: '100%' }}>
      <CardHeader
        title={
          <Stack direction="row" spacing={2} alignItems="center">
            <Typography variant="h6">Network Topology</Typography>
            <Chip
              label={`${stats.online}/${stats.total} Online`}
              size="small"
              sx={{ backgroundColor: entuityColors.success, color: 'white' }}
            />
            {stats.critical > 0 && (
              <Chip
                label={`${stats.critical} Critical`}
                size="small"
                sx={{ backgroundColor: entuityColors.critical, color: 'white' }}
              />
            )}
            {stats.warning > 0 && (
              <Chip
                label={`${stats.warning} Warning`}
                size="small"
                sx={{ backgroundColor: entuityColors.warning, color: 'white' }}
              />
            )}
          </Stack>
        }
        action={
          <Stack direction="row" spacing={1}>
            <ToggleButtonGroup
              value={viewMode}
              exclusive
              onChange={(_, mode) => mode && setViewMode(mode)}
              size="small"
            >
              <ToggleButton value="topology">
                <Tooltip title="Topological View">
                  <TopologyIcon fontSize="small" />
                </Tooltip>
              </ToggleButton>
              <ToggleButton value="geographical">
                <Tooltip title="Geographical View">
                  <MapIcon fontSize="small" />
                </Tooltip>
              </ToggleButton>
            </ToggleButtonGroup>

            <Tooltip title="Zoom In">
              <IconButton size="small" onClick={handleZoomIn}>
                <ZoomInIcon />
              </IconButton>
            </Tooltip>
            <Tooltip title="Zoom Out">
              <IconButton size="small" onClick={handleZoomOut}>
                <ZoomOutIcon />
              </IconButton>
            </Tooltip>
            <Tooltip title="Fit to Screen">
              <IconButton size="small" onClick={handleFitScreen}>
                <FitScreenIcon />
              </IconButton>
            </Tooltip>
            <Tooltip title="Refresh">
              <IconButton size="small" onClick={onRefresh}>
                <RefreshIcon />
              </IconButton>
            </Tooltip>
          </Stack>
        }
      />
      <CardContent sx={{ p: 0, height: `calc(100% - 80px)`, position: 'relative' }}>
        <Box
          sx={{
            width: '100%',
            height: '100%',
            overflow: 'hidden',
            backgroundColor: entuityColors.background.default,
            position: 'relative',
          }}
        >
          <svg
            width="100%"
            height="100%"
            style={{
              transform: `scale(${zoom})`,
              transformOrigin: 'center',
              transition: 'transform 0.3s ease',
            }}
          >
            {/* Render links */}
            <g>
              {data.links.map((link) => {
                const sourceDevice = layoutDevices.find(d => d.id === link.source);
                const targetDevice = layoutDevices.find(d => d.id === link.target);

                if (!sourceDevice || !targetDevice) return null;

                const linkColor = getLinkStatusColor(link.utilization);
                const lineWidth = link.status === 'active' ? 2 : 1;
                const isDashed = link.status !== 'active';

                return (
                  <line
                    key={link.id}
                    x1={sourceDevice.x}
                    y1={sourceDevice.y}
                    x2={targetDevice.x}
                    y2={targetDevice.y}
                    stroke={linkColor}
                    strokeWidth={lineWidth}
                    strokeDasharray={isDashed ? '5,5' : 'none'}
                    opacity={0.6}
                  >
                    <title>
                      {sourceDevice.name} ‚Üí {targetDevice.name}
                      {'\n'}Utilization: {link.utilization}%
                      {'\n'}Bandwidth: {link.bandwidth} Mbps
                    </title>
                  </line>
                );
              })}
            </g>

            {/* Render devices */}
            <g>
              {layoutDevices.map((device) => {
                const statusColor = getDeviceStatusColor(device.status);
                const severityColor = device.severity !== 'none'
                  ? entuityColors[device.severity as keyof typeof entuityColors] || statusColor
                  : statusColor;
                const isSelected = selectedDevice === device.id;

                return (
                  <g
                    key={device.id}
                    transform={`translate(${device.x}, ${device.y})`}
                    onClick={() => handleDeviceClick(device)}
                    style={{ cursor: 'pointer' }}
                  >
                    {/* Outer circle (severity indicator) */}
                    <circle
                      r={isSelected ? 28 : 25}
                      fill={severityColor}
                      opacity={0.2}
                      stroke={severityColor}
                      strokeWidth={isSelected ? 3 : 2}
                    />

                    {/* Inner circle (status) */}
                    <circle
                      r={20}
                      fill="white"
                      stroke={statusColor}
                      strokeWidth={3}
                    />

                    {/* Device icon */}
                    <text
                      textAnchor="middle"
                      dy="7"
                      fontSize="20"
                    >
                      {getDeviceIcon(device.type)}
                    </text>

                    {/* Device name */}
                    <text
                      textAnchor="middle"
                      y={40}
                      fontSize="12"
                      fontWeight="600"
                      fill={entuityColors.text.primary}
                    >
                      {device.name}
                    </text>

                    {/* IP Address */}
                    <text
                      textAnchor="middle"
                      y={54}
                      fontSize="10"
                      fill={entuityColors.text.secondary}
                    >
                      {device.ipAddress}
                    </text>

                    {/* Incident badge */}
                    {device.incidentCount > 0 && (
                      <g transform="translate(18, -18)">
                        <circle r="10" fill={entuityColors.critical} />
                        <text
                          textAnchor="middle"
                          dy="4"
                          fontSize="10"
                          fontWeight="bold"
                          fill="white"
                        >
                          {device.incidentCount}
                        </text>
                      </g>
                    )}

                    <title>
                      {device.name}
                      {'\n'}IP: {device.ipAddress}
                      {'\n'}Type: {device.type}
                      {'\n'}Status: {device.status}
                      {'\n'}Incidents: {device.incidentCount}
                      {device.metrics?.cpuUsage && `\nCPU: ${device.metrics.cpuUsage}%`}
                      {device.metrics?.memoryUsage && `\nMemory: ${device.metrics.memoryUsage}%`}
                    </title>
                  </g>
                );
              })}
            </g>
          </svg>

          {/* Legend */}
          <Box
            sx={{
              position: 'absolute',
              bottom: 16,
              right: 16,
              backgroundColor: 'white',
              borderRadius: 1,
              p: 2,
              boxShadow: 2,
            }}
          >
            <Typography variant="caption" fontWeight="600" display="block" mb={1}>
              Status Legend
            </Typography>
            <Stack spacing={0.5}>
              <Stack direction="row" spacing={1} alignItems="center">
                <Box sx={{ width: 12, height: 12, borderRadius: '50%', bgcolor: entuityColors.device.online }} />
                <Typography variant="caption">Online</Typography>
              </Stack>
              <Stack direction="row" spacing={1} alignItems="center">
                <Box sx={{ width: 12, height: 12, borderRadius: '50%', bgcolor: entuityColors.device.offline }} />
                <Typography variant="caption">Offline</Typography>
              </Stack>
              <Stack direction="row" spacing={1} alignItems="center">
                <Box sx={{ width: 12, height: 12, borderRadius: '50%', bgcolor: entuityColors.device.maintenance }} />
                <Typography variant="caption">Warning</Typography>
              </Stack>
              <Stack direction="row" spacing={1} alignItems="center">
                <Box sx={{ width: 12, height: 12, borderRadius: '50%', bgcolor: entuityColors.critical }} />
                <Typography variant="caption">Critical</Typography>
              </Stack>
            </Stack>
          </Box>
        </Box>
      </CardContent>
    </Card>
  );
};

export default NetworkTopology;
