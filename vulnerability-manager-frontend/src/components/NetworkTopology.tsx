// NetworkTopology.tsx - Advanced network topology visualization with subnet grouping
import React, { useState, useCallback, useMemo, useRef, useEffect } from 'react';
import {
  Box,
  Card,
  CardContent,
  CardHeader,
  IconButton,
  Tooltip,
  Chip,
  Typography,
  Stack,
  Menu,
  MenuItem,
  Button,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  Select,
  FormControl,
  InputLabel,
  useTheme,
} from '@mui/material';
import {
  ZoomIn as ZoomInIcon,
  ZoomOut as ZoomOutIcon,
  FitScreen as FitScreenIcon,
  Refresh as RefreshIcon,
  Fullscreen as FullscreenIcon,
  FullscreenExit as FullscreenExitIcon,
  ViewWeek as ViewWeekIcon,
  GridView as GridViewIcon,
  AccountTree as AccountTreeIcon,
  GetApp as GetAppIcon,
  Edit as EditIcon,
  Delete as DeleteIcon,
  Link as LinkIcon,
} from '@mui/icons-material';
import { entuityColors, getDeviceStatusColor, getLinkStatusColor } from '../theme/entuityTheme';
import { NetworkDevice, NetworkLink, NetworkTopology as NetworkTopologyType } from '../types/network';
import { getDeviceIcon } from './icons/DeviceIcons';
import BulkActionsDialog from './network/BulkActionsDialog';
import EditDeviceDialog from './network/EditDeviceDialog';

const animationStyles = `
  @keyframes pulse-animation {
    0%, 100% { opacity: 1; r: 20; }
    50% { opacity: 0.7; r: 22; }
  }

  @keyframes glow-animation {
    0%, 100% { filter: drop-shadow(0 0 4px rgba(255,107,107,0.5)); }
    50% { filter: drop-shadow(0 0 8px rgba(255,107,107,0.8)); }
  }

  .device-icon-critical {
    animation: pulse-animation 2s infinite;
  }

  .device-icon-high {
    animation: pulse-animation 3s infinite;
  }

  .device-outer-critical {
    animation: glow-animation 2s infinite;
  }

  .subnet-group {
    stroke: #5c6bc0;
    stroke-dasharray: 6,4;
    stroke-width: 1.5;
    fill: rgba(92, 107, 192, 0.04);
    rx: 8;
    ry: 8;
  }

  .subnet-group-label {
    font-size: 11px;
    font-weight: 600;
    fill: #5c6bc0;
    letter-spacing: 0.5px;
  }

  .selection-box {
    stroke: #1976d2;
    fill: rgba(25, 118, 210, 0.1);
    stroke-width: 2;
    stroke-dasharray: 5,5;
  }

  .device-group .connection-handle {
    opacity: 0;
    transition: opacity 0.15s;
  }
  .device-group:hover .connection-handle {
    opacity: 0.75;
  }
  .connection-handle:hover {
    opacity: 1 !important;
  }
`;

interface NetworkTopologyProps {
  data: NetworkTopologyType;
  onDeviceClick?: (device: NetworkDevice) => void;
  onRefresh?: () => void;
  height?: number | string;
  isAdmin?: boolean;
  isTeamLeader?: boolean;
}

type ViewMode = 'subnet-grid' | 'hierarchical' | 'topology' | 'custom';

interface DevicePosition {
  deviceId: string;
  x: number;
  y: number;
}

interface CustomConnection {
  id: string;
  source: string;
  target: string;
  isArrow?: boolean;
  label?: string;
}

interface SubnetGroup {
  subnet: string;
  devices: NetworkDevice[];
  x: number;
  y: number;
  width: number;
  height: number;
}

interface LayoutDevice extends NetworkDevice {
  x: number;
  y: number;
}

const extractSubnet = (ipAddress: string | undefined, cidr: number = 24): string => {
  if (!ipAddress) return 'unknown';
  const parts = ipAddress.split('.');
  if (parts.length !== 4) return 'unknown';
  
  const octets = Math.floor(cidr / 8);
  const subnet = parts.slice(0, octets).join('.');
  return `${subnet}.0/${cidr}`;
};

const getVisibleBadges = (
  device: NetworkDevice,
  isAdmin: boolean,
  isTeamLeader: boolean
): {
  showIncidents: boolean;
  showVulnerabilities: boolean;
  showRiskScore: boolean;
  showTeamInfo: boolean;
} => {
  const totalVulns = device.vulnerabilityMetrics?.totalVulnerabilities || 0;
  
  return {
    showIncidents: device.incidentCount > 0,
    showVulnerabilities: totalVulns > 0,
    showRiskScore: isAdmin || isTeamLeader,
    showTeamInfo: isAdmin || (isTeamLeader && !!device.assignment),
  };
};

const NetworkTopology: React.FC<NetworkTopologyProps> = ({
  data,
  onDeviceClick,
  onRefresh,
  height = '75vh',
  isAdmin = false,
  isTeamLeader = false,
}) => {
  const theme = useTheme();
  const canEditTopology = isAdmin || isTeamLeader;
  const svgRef = useRef<SVGSVGElement>(null);
  const [zoom, setZoom] = useState(1);
  const [selectedDevice, setSelectedDevice] = useState<string | null>(null);
  const [selectedDevices, setSelectedDevices] = useState<Set<string>>(new Set());
  const [isFullscreen, setIsFullscreen] = useState(false);
  const [viewMode, setViewMode] = useState<ViewMode>('subnet-grid');
  const [devicePositions, setDevicePositions] = useState<Map<string, DevicePosition>>(new Map());
  const [customConnections, setCustomConnections] = useState<CustomConnection[]>([]);
  const [contextMenu, setContextMenu] = useState<{ x: number; y: number; devices: string[] } | null>(null);
  const [selectionBox, setSelectionBox] = useState<{ x: number; y: number; width: number; height: number } | null>(null);
  const [isDrawingConnection, setIsDrawingConnection] = useState<string | null>(null);
  const [connectionEnd, setConnectionEnd] = useState<{ x: number; y: number } | null>(null);
  const [draggingDevice, setDraggingDevice] = useState<string | null>(null);
  const [editingConnection, setEditingConnection] = useState<CustomConnection | null>(null);
  const [showConnectionDialog, setShowConnectionDialog] = useState(false);
  const [bulkActionOpen, setBulkActionOpen] = useState(false);
  const [bulkActionType, setBulkActionType] = useState<'assign-team' | 'assign-user' | 'remediation-plan' | null>(null);
  const [bulkActionDevices, setBulkActionDevices] = useState<NetworkDevice[]>([]);
  const [editDeviceDialogOpen, setEditDeviceDialogOpen] = useState(false);
  const [editDevice, setEditDevice] = useState<NetworkDevice | null>(null);

  // Calculate network statistics
  const stats = useMemo(() => {
    const total = data.devices.length;
    const online = data.devices.filter(d => d.status === 'online').length;
    const critical = data.devices.filter(d => d.severity === 'critical').length;
    const warning = data.devices.filter(d => d.severity === 'high' || d.severity === 'medium').length;

    return { total, online, critical, warning };
  }, [data.devices]);

  // Group devices by subnet
  const subnetGroups = useMemo(() => {
    const groups: { [key: string]: NetworkDevice[] } = {};

    data.devices.forEach(device => {
      const subnet = extractSubnet(device.ipAddress);
      if (!groups[subnet]) {
        groups[subnet] = [];
      }
      groups[subnet].push(device);
    });

    const DEVICES_PER_ROW = 3;
    const DEVICE_SPACING_X = 170;
    const DEVICE_SPACING_Y = 140;
    const PADDING_X = 60;
    const PADDING_TOP = 55;
    const PADDING_BOTTOM = 30;
    const GROUPS_PER_ROW = 3;
    const GROUP_SPACING_X = 600;
    const GROUP_SPACING_Y = 480;

    return Object.entries(groups).map(([subnet, devices], index) => {
      const rows = Math.ceil(devices.length / DEVICES_PER_ROW);
      const groupWidth = PADDING_X * 2 + Math.min(devices.length, DEVICES_PER_ROW) * DEVICE_SPACING_X - (DEVICE_SPACING_X - 120);
      const groupHeight = PADDING_TOP + rows * DEVICE_SPACING_Y + PADDING_BOTTOM;
      return {
        subnet,
        devices,
        x: (index % GROUPS_PER_ROW) * GROUP_SPACING_X + 60,
        y: Math.floor(index / GROUPS_PER_ROW) * GROUP_SPACING_Y + 60,
        width: Math.max(280, groupWidth),
        height: Math.max(180, groupHeight),
      };
    });
  }, [data.devices]);

  // Layout devices based on view mode
  const layoutDevices = useMemo((): LayoutDevice[] => {
    const width = 1800;
    const height = 1200;
    const centerX = width / 2;
    const centerY = height / 2;

    return data.devices.map((device) => {
      const savedPos = devicePositions.get(device.id);
      if (savedPos) {
        return { ...device, x: savedPos.x, y: savedPos.y };
      }

      switch (viewMode) {
        case 'subnet-grid': {
          const DEVICES_PER_ROW = 3;
          const DEVICE_SPACING_X = 170;
          const DEVICE_SPACING_Y = 140;
          const subnet = extractSubnet(device.ipAddress);
          const group = subnetGroups.find(g => g.subnet === subnet);
          if (!group) break;

          const devicesInSubnet = group.devices;
          const deviceIndex = devicesInSubnet.indexOf(device);
          const col = deviceIndex % DEVICES_PER_ROW;
          const row = Math.floor(deviceIndex / DEVICES_PER_ROW);
          const x = group.x + 80 + col * DEVICE_SPACING_X;
          const y = group.y + 75 + row * DEVICE_SPACING_Y;
          return { ...device, x, y };
        }

        case 'hierarchical': {
          // Layer by device type: routers/firewalls ‚Üí switches ‚Üí servers ‚Üí workstations/iot/other
          const getLayer = (d: NetworkDevice): number => {
            switch (d.type) {
              case 'router': return 0;
              case 'firewall': return 0;
              case 'gateway': return 0;
              case 'switch': return 1;
              case 'wireless': return 1;
              case 'loadbalancer': return 1;
              case 'server': return 2;
              case 'database': return 2;
              case 'storage': return 2;
              case 'endpoint': return 3;
              default: return 3;
            }
          };
          const layer = getLayer(device);
          const layerDevices = data.devices.filter(d => getLayer(d) === layer);
          const deviceIndex = layerDevices.indexOf(device);
          const totalInLayer = layerDevices.length;
          const layerWidth = Math.min(totalInLayer * 180, width - 200);
          const startX = centerX - layerWidth / 2 + 90;
          const spacing = totalInLayer > 1 ? layerWidth / (totalInLayer - 1) : 0;
          const x = totalInLayer === 1 ? centerX : startX + deviceIndex * spacing;
          const y = 120 + layer * 240;
          return { ...device, x, y };
        }

        case 'topology':
        default: {
          const total = data.devices.length;
          const angle = (data.devices.indexOf(device) / total) * 2 * Math.PI - Math.PI / 2;
          const radius = Math.min(width, height) * 0.32;
          return {
            ...device,
            x: centerX + radius * Math.cos(angle),
            y: centerY + radius * Math.sin(angle),
          };
        }
      }

      return { ...device, x: 0, y: 0 };
    });
  }, [data.devices, viewMode, devicePositions, subnetGroups]);

  const handleDeviceClick = useCallback((device: NetworkDevice, event: React.MouseEvent) => {
    if (!canEditTopology) {
      setSelectedDevice(device.id);
      onDeviceClick?.(device);
      return;
    }

    if (event.ctrlKey) {
      setSelectedDevices(prev => {
        const next = new Set(prev);
        if (next.has(device.id)) {
          next.delete(device.id);
        } else {
          next.add(device.id);
        }
        return next;
      });
    } else {
      setSelectedDevice(device.id);
      setSelectedDevices(new Set([device.id]));
    }
  }, [canEditTopology, onDeviceClick]);

  const handleDeviceMouseDown = useCallback((deviceId: string, event: React.MouseEvent) => {
    if (!canEditTopology) return;
    if (event.button === 2) return; // Right click

    event.preventDefault();
    setDraggingDevice(deviceId);
  }, [canEditTopology]);

  const handleMouseMove = useCallback((event: React.MouseEvent<SVGSVGElement>) => {
    if (!svgRef.current) return;

    if (draggingDevice) {
      const rect = svgRef.current.getBoundingClientRect();
      const x = (event.clientX - rect.left) / zoom;
      const y = (event.clientY - rect.top) / zoom;

      setDevicePositions(prev => new Map(prev).set(draggingDevice, { deviceId: draggingDevice, x, y }));
    }

    if (isDrawingConnection) {
      const rect = svgRef.current.getBoundingClientRect();
      setConnectionEnd({
        x: (event.clientX - rect.left) / zoom,
        y: (event.clientY - rect.top) / zoom,
      });
    }
  }, [draggingDevice, isDrawingConnection, zoom]);

  const handleMouseUp = useCallback(() => {
    setDraggingDevice(null);
    // Cancel connection drawing if mouse released on background
    if (isDrawingConnection) {
      setIsDrawingConnection(null);
      setConnectionEnd(null);
    }
  }, [isDrawingConnection]);

  const handleContextMenu = useCallback((event: React.MouseEvent<SVGSVGElement>) => {
    event.preventDefault();
    const rect = svgRef.current?.getBoundingClientRect();
    if (!rect) return;

    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;

    setContextMenu({
      x,
      y,
      devices: Array.from(selectedDevices),
    });
  }, [selectedDevices]);

  const handleStartConnection = useCallback((deviceId: string) => {
    if (!canEditTopology) return;
    setIsDrawingConnection(deviceId);
  }, [canEditTopology]);

  const handleEndConnection = useCallback((targetId: string) => {
    if (!isDrawingConnection || isDrawingConnection === targetId) {
      setIsDrawingConnection(null);
      setConnectionEnd(null);
      return;
    }

    const newConnection: CustomConnection = {
      id: `conn-${Date.now()}`,
      source: isDrawingConnection,
      target: targetId,
    };

    setCustomConnections(prev => [...prev, newConnection]);
    setIsDrawingConnection(null);
    setConnectionEnd(null);
  }, [isDrawingConnection]);

  const handleZoomIn = () => setZoom(prev => Math.min(prev + 0.2, 3));
  const handleZoomOut = () => setZoom(prev => Math.max(prev - 0.2, 0.5));
  const handleFitScreen = () => setZoom(1);
  const toggleFullscreen = () => setIsFullscreen(prev => !prev);

  return (
    <Box
      sx={{
        height: '100%',
        ...(isFullscreen && {
          position: 'fixed',
          top: 0,
          left: 0,
          right: 0,
          bottom: 0,
          zIndex: 9999,
          backgroundColor: 'background.default',
        })
      }}
    >
      <style>{animationStyles}</style>
      <Card sx={{ height: '100%' }}>
        <CardHeader
          title={
            <Stack direction="row" spacing={2} alignItems="center">
              <Typography variant="h6">Network Topology</Typography>
              <Chip
                label={`${stats.online}/${stats.total} Online`}
                size="small"
                sx={{ backgroundColor: entuityColors.success, color: 'white' }}
              />
              {stats.critical > 0 && (
                <Chip
                  label={`${stats.critical} Critical`}
                  size="small"
                  sx={{ backgroundColor: entuityColors.critical, color: 'white' }}
                />
              )}
              {stats.warning > 0 && (
                <Chip
                  label={`${stats.warning} Warning`}
                  size="small"
                  sx={{ backgroundColor: entuityColors.warning, color: 'white' }}
                />
              )}
              {selectedDevices.size > 0 && (
                <Chip
                  label={`${selectedDevices.size} Selected`}
                  size="small"
                  sx={{ backgroundColor: '#1976d2', color: 'white' }}
                />
              )}
            </Stack>
          }
          action={
            <Stack direction="row" spacing={1}>
              {canEditTopology && (
                <>
                  <Tooltip title="Subnet Grid">
                    <IconButton
                      size="small"
                      onClick={() => setViewMode('subnet-grid')}
                      color={viewMode === 'subnet-grid' ? 'primary' : 'default'}
                    >
                      <GridViewIcon />
                    </IconButton>
                  </Tooltip>
                  <Tooltip title="Hierarchical">
                    <IconButton
                      size="small"
                      onClick={() => setViewMode('hierarchical')}
                      color={viewMode === 'hierarchical' ? 'primary' : 'default'}
                    >
                      <AccountTreeIcon />
                    </IconButton>
                  </Tooltip>
                  <Tooltip title="Circular Topology">
                    <IconButton
                      size="small"
                      onClick={() => setViewMode('topology')}
                      color={viewMode === 'topology' ? 'primary' : 'default'}
                    >
                      <ViewWeekIcon />
                    </IconButton>
                  </Tooltip>
                </>
              )}
              <Tooltip title="Zoom In">
                <IconButton size="small" onClick={handleZoomIn}>
                  <ZoomInIcon />
                </IconButton>
              </Tooltip>
              <Tooltip title="Zoom Out">
                <IconButton size="small" onClick={handleZoomOut}>
                  <ZoomOutIcon />
                </IconButton>
              </Tooltip>
              <Tooltip title="Fit to Screen">
                <IconButton size="small" onClick={handleFitScreen}>
                  <FitScreenIcon />
                </IconButton>
              </Tooltip>
              <Tooltip title={isFullscreen ? "Exit Fullscreen" : "Fullscreen"}>
                <IconButton size="small" onClick={toggleFullscreen}>
                  {isFullscreen ? <FullscreenExitIcon /> : <FullscreenIcon />}
                </IconButton>
              </Tooltip>
              <Tooltip title="Refresh">
                <IconButton size="small" onClick={onRefresh}>
                  <RefreshIcon />
                </IconButton>
              </Tooltip>
            </Stack>
          }
        />
        <CardContent sx={{ p: 0, height: `calc(100% - 80px)`, position: 'relative' }}>
          {canEditTopology && (
            <Box sx={{ position: 'absolute', top: 16, left: 16, zIndex: 100, backgroundColor: 'rgba(255,255,255,0.95)', p: 1, borderRadius: 1, boxShadow: 1 }}>
              <Typography variant="caption" display="block" fontWeight={600} color={isDrawingConnection ? 'primary' : 'text.secondary'}>
                {isDrawingConnection
                  ? 'üîó Connessione in corso... rilascia su un altro device'
                  : 'Ctrl+click: multi-selezione | Drag: sposta | Hover device: pulsante connessione (arancione)'}
              </Typography>
            </Box>
          )}
          <Box
            sx={{
              width: '100%',
              height: '100%',
              overflow: 'auto',
              backgroundColor: theme.palette.background.default,
              position: 'relative',
            }}
          >
            <svg
              ref={svgRef}
              width="100%"
              height="100%"
              style={{
                transform: `scale(${zoom})`,
                transformOrigin: 'top left',
                transition: 'transform 0.3s ease',
                cursor: isDrawingConnection ? 'crosshair' : canEditTopology ? 'grab' : 'default',
              }}
              onMouseMove={handleMouseMove}
              onMouseUp={handleMouseUp}
              onMouseLeave={handleMouseUp}
              onContextMenu={handleContextMenu}
            >
              {/* Subnet groups background */}
              {viewMode === 'subnet-grid' && subnetGroups.map((group) => (
                <g key={`subnet-${group.subnet}`}>
                  <rect
                    x={group.x}
                    y={group.y}
                    width={group.width}
                    height={group.height}
                    rx={10}
                    ry={10}
                    className="subnet-group"
                  />
                  <text
                    x={group.x + 14}
                    y={group.y + 22}
                    className="subnet-group-label"
                  >
                    üåê {group.subnet}
                  </text>
                  <text
                    x={group.x + group.width - 10}
                    y={group.y + 22}
                    textAnchor="end"
                    fontSize="10"
                    fill="#888"
                  >
                    {group.devices.length} device{group.devices.length !== 1 ? 's' : ''}
                  </text>
                </g>
              ))}

              {/* Render data links */}
              <g>
                {data.links.map((link) => {
                  const sourceDevice = layoutDevices.find(d => d.id === link.source);
                  const targetDevice = layoutDevices.find(d => d.id === link.target);

                  if (!sourceDevice || !targetDevice) return null;

                  const linkColor = getLinkStatusColor(link.utilization);
                  const lineWidth = link.status === 'active' ? 2 : 1;
                  const isDashed = link.status !== 'active';

                  return (
                    <line
                      key={link.id}
                      x1={sourceDevice.x}
                      y1={sourceDevice.y}
                      x2={targetDevice.x}
                      y2={targetDevice.y}
                      stroke={linkColor}
                      strokeWidth={lineWidth}
                      strokeDasharray={isDashed ? '5,5' : 'none'}
                      opacity={0.6}
                    >
                      <title>
                        {sourceDevice.name} ‚Üí {targetDevice.name}
                        {'\n'}Utilization: {link.utilization}%
                        {'\n'}Bandwidth: {link.bandwidth} Mbps
                      </title>
                    </line>
                  );
                })}
              </g>

              {/* Render custom connections */}
              <g>
                {customConnections.map((conn) => {
                  const sourceDevice = layoutDevices.find(d => d.id === conn.source);
                  const targetDevice = layoutDevices.find(d => d.id === conn.target);

                  if (!sourceDevice || !targetDevice) return null;

                  const dx = targetDevice.x - sourceDevice.x;
                  const dy = targetDevice.y - sourceDevice.y;
                  const distance = Math.sqrt(dx * dx + dy * dy);
                  const angle = Math.atan2(dy, dx);

                  return (
                    <g key={conn.id}>
                      <line
                        x1={sourceDevice.x}
                        y1={sourceDevice.y}
                        x2={targetDevice.x}
                        y2={targetDevice.y}
                        stroke="#FF9800"
                        strokeWidth={2}
                        opacity={0.8}
                        style={{ cursor: 'pointer' }}
                        onClick={() => {
                          setEditingConnection(conn);
                          setShowConnectionDialog(true);
                        }}
                      />
                      {conn.isArrow && (
                        <polygon
                          points={`${targetDevice.x},${targetDevice.y} ${targetDevice.x - 12 * Math.cos(angle - Math.PI / 6)},${targetDevice.y - 12 * Math.sin(angle - Math.PI / 6)} ${targetDevice.x - 12 * Math.cos(angle + Math.PI / 6)},${targetDevice.y - 12 * Math.sin(angle + Math.PI / 6)}`}
                          fill="#FF9800"
                        />
                      )}
                    </g>
                  );
                })}
              </g>

              {/* Connection being drawn */}
              {isDrawingConnection && connectionEnd && (
                <line
                  x1={layoutDevices.find(d => d.id === isDrawingConnection)?.x || 0}
                  y1={layoutDevices.find(d => d.id === isDrawingConnection)?.y || 0}
                  x2={connectionEnd.x}
                  y2={connectionEnd.y}
                  stroke="#FF9800"
                  strokeWidth={2}
                  strokeDasharray="5,5"
                  opacity={0.6}
                />
              )}

              {/* Render devices */}
              <g>
                {layoutDevices.map((device) => {
                  const statusColor = getDeviceStatusColor(device.status);
                  const severityColorRaw = device.severity !== 'none'
                    ? entuityColors[device.severity as keyof typeof entuityColors]
                    : null;
                  const severityColor = (typeof severityColorRaw === 'string' ? severityColorRaw : null) || statusColor;
                  const isSelected = selectedDevice === device.id || selectedDevices.has(device.id);
                  const badges = getVisibleBadges(device, isAdmin, isTeamLeader);
                  const hasCriticalVulns = (device.vulnerabilityMetrics?.criticalCount || 0) > 0;

                  return (
                    <g
                      key={device.id}
                      className="device-group"
                      transform={`translate(${device.x}, ${device.y})`}
                      onClick={(e) => handleDeviceClick(device, e as any)}
                      onContextMenu={(e) => {
                        e.preventDefault();
                        const rect = svgRef.current?.getBoundingClientRect();
                        if (rect) {
                          setContextMenu({
                            x: e.clientX - rect.left,
                            y: e.clientY - rect.top,
                            devices: [device.id],
                          });
                        }
                      }}
                      onMouseDown={(e) => handleDeviceMouseDown(device.id, e as any)}
                      onMouseUp={(e) => {
                        if (isDrawingConnection && isDrawingConnection !== device.id) {
                          e.stopPropagation();
                          handleEndConnection(device.id);
                        }
                      }}
                      style={{ cursor: canEditTopology ? 'grab' : 'pointer' }}
                    >
                      {/* Outer circle (severity indicator) with glow animation for critical */}
                      <circle
                        r={isSelected ? 28 : 25}
                        fill={severityColor}
                        opacity={0.2}
                        stroke={severityColor}
                        strokeWidth={isSelected ? 3 : 2}
                        className={hasCriticalVulns ? 'device-outer-critical' : ''}
                      />

                      {/* Inner circle (status) */}
                      <circle
                        r={20}
                        fill="white"
                        stroke={statusColor}
                        strokeWidth={3}
                      />

                      {/* Device icon with animation */}
                      <foreignObject
                        x="-16"
                        y="-16"
                        width="32"
                        height="32"
                        className={
                          hasCriticalVulns
                            ? 'device-icon-critical'
                            : (device.vulnerabilityMetrics?.highCount || 0) > 0
                            ? 'device-icon-high'
                            : ''
                        }
                      >
                        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                          {getDeviceIcon(device.type, 32, statusColor)}
                        </div>
                      </foreignObject>

                      {/* Device name */}
                      <text
                        textAnchor="middle"
                        y={40}
                        fontSize="12"
                        fontWeight="600"
                        fill={entuityColors.text.primary}
                        pointerEvents="none"
                      >
                        {device.name}
                      </text>

                      {/* IP Address */}
                      <text
                        textAnchor="middle"
                        y={54}
                        fontSize="10"
                        fill={entuityColors.text.secondary}
                        pointerEvents="none"
                      >
                        {device.ipAddress}
                      </text>

                      {/* Incident badge - Top Right */}
                      {badges.showIncidents && (
                        <g transform="translate(18, -18)">
                          <circle r="10" fill={entuityColors.critical} />
                          <text
                            textAnchor="middle"
                            dy="4"
                            fontSize="10"
                            fontWeight="bold"
                            fill="white"
                            pointerEvents="none"
                          >
                            {device.incidentCount}
                          </text>
                        </g>
                      )}

                      {/* Vulnerability badge - Bottom Right */}
                      {badges.showVulnerabilities && (
                        <g transform="translate(18, 18)">
                          <circle
                            r="10"
                            fill={
                              hasCriticalVulns
                                ? entuityColors.critical
                                : (device.vulnerabilityMetrics?.highCount || 0) > 0
                                ? entuityColors.warning
                                : entuityColors.info
                            }
                          />
                          <text
                            textAnchor="middle"
                            dy="4"
                            fontSize="10"
                            fontWeight="bold"
                            fill="white"
                            pointerEvents="none"
                          >
                            {device.vulnerabilityMetrics?.totalVulnerabilities || 0}
                          </text>
                        </g>
                      )}

                      {/* Risk Score badge - Bottom Left (admin/team_leader only) */}
                      {badges.showRiskScore && (
                        <g transform="translate(-18, 18)">
                          <circle
                            r="10"
                            fill={
                              (device.vulnerabilityMetrics?.riskScore || 0) > 70
                                ? entuityColors.critical
                                : (device.vulnerabilityMetrics?.riskScore || 0) > 40
                                ? entuityColors.warning
                                : entuityColors.success
                            }
                          />
                          <text
                            textAnchor="middle"
                            dy="4"
                            fontSize="9"
                            fontWeight="bold"
                            fill="white"
                            pointerEvents="none"
                          >
                            {device.vulnerabilityMetrics?.riskScore || 0}
                          </text>
                        </g>
                      )}

                      {/* Connection button for edit mode */}
                      {canEditTopology && (
                        <circle
                          cx="24"
                          cy="-24"
                          r="8"
                          fill="#FF9800"
                          opacity="0"
                          onMouseDown={() => handleStartConnection(device.id)}
                          onMouseUp={() => handleEndConnection(device.id)}
                          style={{ cursor: 'crosshair' }}
                          className="connection-handle"
                        />
                      )}

                      <title>
                        {device.name}
                        {'\n'}IP: {device.ipAddress}
                        {'\n'}Type: {device.type}
                        {'\n'}Status: {device.status}
                        {'\n'}Risk Score: {device.vulnerabilityMetrics?.riskScore ?? 0}/100
                        {'\n'}Total Vulnerabilities: {device.vulnerabilityMetrics?.totalVulnerabilities ?? 0}
                        {'\n'}Critical: {device.vulnerabilityMetrics?.criticalCount ?? 0}
                        {'\n'}High: {device.vulnerabilityMetrics?.highCount ?? 0}
                        {'\n'}Medium: {device.vulnerabilityMetrics?.mediumCount ?? 0}
                        {device.vulnerabilityMetrics?.lastScanDate && `\nLast Scan: ${new Date(device.vulnerabilityMetrics.lastScanDate).toLocaleDateString()}`}
                        {badges.showTeamInfo && device.assignment?.assignedTeamName && `\nTeam: ${device.assignment.assignedTeamName}`}
                        {device.incidentCount > 0 && `\nIncidents: ${device.incidentCount}`}
                      </title>
                    </g>
                  );
                })}
              </g>
            </svg>

            {/* Legend */}
            <Box
              sx={{
                position: 'absolute',
                bottom: 16,
                right: 16,
                backgroundColor: 'white',
                borderRadius: 1,
                p: 2,
                boxShadow: 2,
              }}
            >
              <Typography variant="caption" fontWeight="600" display="block" mb={1}>
                Status Legend
              </Typography>
              <Stack spacing={0.5}>
                <Stack direction="row" spacing={1} alignItems="center">
                  <Box sx={{ width: 12, height: 12, borderRadius: '50%', bgcolor: entuityColors.device.online }} />
                  <Typography variant="caption">Online</Typography>
                </Stack>
                <Stack direction="row" spacing={1} alignItems="center">
                  <Box sx={{ width: 12, height: 12, borderRadius: '50%', bgcolor: entuityColors.device.offline }} />
                  <Typography variant="caption">Offline</Typography>
                </Stack>
                <Stack direction="row" spacing={1} alignItems="center">
                  <Box sx={{ width: 12, height: 12, borderRadius: '50%', bgcolor: entuityColors.device.maintenance }} />
                  <Typography variant="caption">Warning</Typography>
                </Stack>
                <Stack direction="row" spacing={1} alignItems="center">
                  <Box sx={{ width: 12, height: 12, borderRadius: '50%', bgcolor: entuityColors.critical }} />
                  <Typography variant="caption">Critical</Typography>
                </Stack>
              </Stack>
            </Box>
          </Box>
        </CardContent>
      </Card>

      {/* Context Menu */}
      <Menu
        open={!!contextMenu}
        onClose={() => setContextMenu(null)}
        anchorReference="anchorPosition"
        anchorPosition={contextMenu ? { top: contextMenu.y, left: contextMenu.x } : undefined}
      >
        <MenuItem onClick={() => {
          if (contextMenu && contextMenu.devices.length === 1) {
            const device = data.devices.find(d => d.id === contextMenu.devices[0]);
            if (device) {
              onDeviceClick?.(device);
            }
          }
          setContextMenu(null);
        }} disabled={!contextMenu || contextMenu.devices.length !== 1}>
          Edit Device
        </MenuItem>
        <MenuItem onClick={() => {
          if (contextMenu) {
            const devices = contextMenu.devices.map(id => data.devices.find(d => d.id === id)).filter(Boolean) as NetworkDevice[];
            setBulkActionDevices(devices);
            setBulkActionType('assign-team');
            setBulkActionOpen(true);
            setContextMenu(null);
          }
        }}>
          Assign to Team
        </MenuItem>
        <MenuItem onClick={() => {
          if (contextMenu) {
            const devices = contextMenu.devices.map(id => data.devices.find(d => d.id === id)).filter(Boolean) as NetworkDevice[];
            setBulkActionDevices(devices);
            setBulkActionType('assign-user');
            setBulkActionOpen(true);
            setContextMenu(null);
          }
        }}>
          Assign to User
        </MenuItem>
        <MenuItem onClick={() => {
          if (contextMenu) {
            const devices = contextMenu.devices.map(id => data.devices.find(d => d.id === id)).filter(Boolean) as NetworkDevice[];
            setBulkActionDevices(devices);
            setBulkActionType('remediation-plan');
            setBulkActionOpen(true);
            setContextMenu(null);
          }
        }}>
          Generate Remediation Plan
        </MenuItem>
        <MenuItem onClick={() => {
          // TODO: Implement report generation
          setContextMenu(null);
        }}>
          Export Report
        </MenuItem>
      </Menu>

      {/* Bulk Actions Dialog */}
      <BulkActionsDialog
        open={bulkActionOpen}
        onClose={() => {
          setBulkActionOpen(false);
          setBulkActionType(null);
          setBulkActionDevices([]);
        }}
        selectedDevices={bulkActionDevices}
        actionType={bulkActionType}
      />

      {/* Connection Dialog */}
      <Dialog open={showConnectionDialog} onClose={() => {
        setShowConnectionDialog(false);
        setEditingConnection(null);
      }}>
        <DialogTitle>Edit Connection</DialogTitle>
        <DialogContent>
          <Stack spacing={2} sx={{ mt: 2 }}>
            <TextField
              label="Label"
              fullWidth
              defaultValue={editingConnection?.label || ''}
              onChange={(e) => {
                if (editingConnection) {
                  setEditingConnection({
                    ...editingConnection,
                    label: e.target.value,
                  });
                }
              }}
            />
            <FormControl fullWidth>
              <InputLabel>Connection Type</InputLabel>
              <Select
                defaultValue={editingConnection?.isArrow ? 'arrow' : 'line'}
                onChange={(e) => {
                  if (editingConnection) {
                    setEditingConnection({
                      ...editingConnection,
                      isArrow: e.target.value === 'arrow',
                    });
                  }
                }}
              >
                <MenuItem value="line">Line</MenuItem>
                <MenuItem value="arrow">Arrow</MenuItem>
              </Select>
            </FormControl>
          </Stack>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => {
            if (editingConnection) {
              setCustomConnections(prev => prev.filter(c => c.id !== editingConnection.id));
            }
            setShowConnectionDialog(false);
            setEditingConnection(null);
          }} color="error">
            Delete
          </Button>
          <Button onClick={() => setShowConnectionDialog(false)}>Cancel</Button>
          <Button
            onClick={() => {
              if (editingConnection) {
                setCustomConnections(prev =>
                  prev.map(c => (c.id === editingConnection.id ? editingConnection : c))
                );
              }
              setShowConnectionDialog(false);
              setEditingConnection(null);
            }}
            variant="contained"
          >
            Save
          </Button>
        </DialogActions>
      </Dialog>

      {/* Edit Device Dialog */}
      <EditDeviceDialog
        open={editDeviceDialogOpen}
        device={editDevice}
        onClose={() => {
          setEditDeviceDialogOpen(false);
          setEditDevice(null);
        }}
        onSuccess={() => {
          onRefresh?.();
        }}
      />
    </Box>
  );
};

export default NetworkTopology;
