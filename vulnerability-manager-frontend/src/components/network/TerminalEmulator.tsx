// src/components/network/TerminalEmulator.tsx
// Terminal emulator integrato con xterm.js

import React, { useEffect, useRef } from 'react';
import { Terminal } from '@xterm/xterm';
import { FitAddon } from '@xterm/addon-fit';
import '@xterm/xterm/css/xterm.css';
import { Box, Alert } from '@mui/material';

interface TerminalEmulatorProps {
  deviceId: string;
  ipAddress: string;
}

const TerminalEmulator: React.FC<TerminalEmulatorProps> = ({
  deviceId,
  ipAddress,
}) => {
  const terminalRef = useRef<HTMLDivElement>(null);
  const xtermRef = useRef<Terminal | null>(null);
  const fitAddonRef = useRef<FitAddon | null>(null);
  const commandHistory = useRef<string[]>([]);
  const historyIndex = useRef<number>(-1);
  const currentLine = useRef<string>('');

  useEffect(() => {
    if (!terminalRef.current) return;

    // Inizializza terminale
    const term = new Terminal({
      cursorBlink: true,
      fontSize: 14,
      fontFamily: 'Menlo, Monaco, "Courier New", monospace',
      theme: {
        background: '#1e1e1e',
        foreground: '#d4d4d4',
        cursor: '#d4d4d4',
        black: '#000000',
        red: '#cd3131',
        green: '#0dbc79',
        yellow: '#e5e510',
        blue: '#2472c8',
        magenta: '#bc3fbc',
        cyan: '#11a8cd',
        white: '#e5e5e5',
        brightBlack: '#666666',
        brightRed: '#f14c4c',
        brightGreen: '#23d18b',
        brightYellow: '#f5f543',
        brightBlue: '#3b8eea',
        brightMagenta: '#d670d6',
        brightCyan: '#29b8db',
        brightWhite: '#e5e5e5',
      },
    });

    const fitAddon = new FitAddon();
    term.loadAddon(fitAddon);

    term.open(terminalRef.current);
    fitAddon.fit();

    // Welcome message
    term.writeln('\x1b[1;32m╔══════════════════════════════════════╗\x1b[0m');
    term.writeln('\x1b[1;32m║    Sentinel Core Terminal Access    ║\x1b[0m');
    term.writeln('\x1b[1;32m╚══════════════════════════════════════╝\x1b[0m');
    term.writeln('');
    term.writeln(`Connected to: \x1b[1;36m${ipAddress}\x1b[0m`);
    term.writeln(`Device ID: \x1b[1;33m${deviceId}\x1b[0m`);
    term.writeln('');
    term.writeln('\x1b[33m⚠ WARNING: This is a simulated terminal for demonstration.\x1b[0m');
    term.writeln('\x1b[33m⚠ In production, use proper SSH/WinRM connections.\x1b[0m');
    term.writeln('');
    writePrompt(term);

    // Handle input
    term.onData((data) => {
      const code = data.charCodeAt(0);

      // Enter key
      if (code === 13) {
        term.writeln('');
        if (currentLine.current.trim()) {
          executeCommand(term, currentLine.current.trim());
          commandHistory.current.push(currentLine.current);
          historyIndex.current = commandHistory.current.length;
        }
        currentLine.current = '';
        writePrompt(term);
        return;
      }

      // Backspace
      if (code === 127) {
        if (currentLine.current.length > 0) {
          currentLine.current = currentLine.current.slice(0, -1);
          term.write('\b \b');
        }
        return;
      }

      // Arrow up (previous command)
      if (data === '\x1b[A') {
        if (historyIndex.current > 0) {
          historyIndex.current--;
          replaceCurrentLine(term, commandHistory.current[historyIndex.current]);
        }
        return;
      }

      // Arrow down (next command)
      if (data === '\x1b[B') {
        if (historyIndex.current < commandHistory.current.length - 1) {
          historyIndex.current++;
          replaceCurrentLine(term, commandHistory.current[historyIndex.current]);
        } else {
          historyIndex.current = commandHistory.current.length;
          replaceCurrentLine(term, '');
        }
        return;
      }

      // Regular character
      if (code >= 32 && code <= 126) {
        currentLine.current += data;
        term.write(data);
      }
    });

    xtermRef.current = term;
    fitAddonRef.current = fitAddon;

    // Resize handler
    const handleResize = () => {
      fitAddon.fit();
    };
    window.addEventListener('resize', handleResize);

    return () => {
      window.removeEventListener('resize', handleResize);
      term.dispose();
    };
  }, [deviceId, ipAddress]);

  const writePrompt = (term: Terminal) => {
    term.write('\x1b[1;32msentinel@' + ipAddress + '\x1b[0m:\x1b[1;34m~\x1b[0m$ ');
  };

  const replaceCurrentLine = (term: Terminal, newLine: string) => {
    // Clear current line
    term.write('\r\x1b[K');
    writePrompt(term);
    term.write(newLine);
    currentLine.current = newLine;
  };

  const executeCommand = async (term: Terminal, command: string) => {
    const parts = command.split(' ');
    const cmd = parts[0];

    // Simulated commands (in production, send to backend via WebSocket)
    switch (cmd) {
      case 'help':
        term.writeln('Available commands:');
        term.writeln('  help          - Show this help message');
        term.writeln('  clear         - Clear the terminal');
        term.writeln('  whoami        - Display current user');
        term.writeln('  hostname      - Display hostname');
        term.writeln('  ip            - Display IP address');
        term.writeln('  ping <host>   - Ping a host');
        term.writeln('  scan          - Run vulnerability scan');
        term.writeln('  fix           - Apply automatic remediation');
        break;

      case 'clear':
        term.clear();
        break;

      case 'whoami':
        term.writeln('root');
        break;

      case 'hostname':
        term.writeln(ipAddress);
        break;

      case 'ip':
        term.writeln(`inet ${ipAddress}/24`);
        break;

      case 'ping':
        if (parts.length < 2) {
          term.writeln('Usage: ping <host>');
        } else {
          term.writeln(`PING ${parts[1]} (${parts[1]}) 56(84) bytes of data.`);
          term.writeln(`64 bytes from ${parts[1]}: icmp_seq=1 ttl=64 time=0.5 ms`);
          term.writeln(`64 bytes from ${parts[1]}: icmp_seq=2 ttl=64 time=0.6 ms`);
          term.writeln(`64 bytes from ${parts[1]}: icmp_seq=3 ttl=64 time=0.4 ms`);
        }
        break;

      case 'scan':
        term.writeln('Starting vulnerability scan...');
        term.writeln('\x1b[33m[+] Scanning ports...\x1b[0m');
        await simulateDelay(500);
        term.writeln('\x1b[32m[+] Found 5 open ports\x1b[0m');
        await simulateDelay(500);
        term.writeln('\x1b[33m[+] Checking for known vulnerabilities...\x1b[0m');
        await simulateDelay(1000);
        term.writeln('\x1b[31m[!] Found 3 vulnerabilities\x1b[0m');
        term.writeln('    - CVE-2023-1234 (Critical)');
        term.writeln('    - CVE-2023-5678 (High)');
        term.writeln('    - CVE-2023-9012 (Medium)');
        break;

      case 'fix':
        term.writeln('Applying automatic remediation...');
        term.writeln('\x1b[33m[+] Updating system packages...\x1b[0m');
        await simulateDelay(1000);
        term.writeln('\x1b[32m[+] Packages updated\x1b[0m');
        term.writeln('\x1b[33m[+] Applying security patches...\x1b[0m');
        await simulateDelay(1000);
        term.writeln('\x1b[32m[+] Patches applied\x1b[0m');
        term.writeln('\x1b[32m[✓] Remediation completed successfully\x1b[0m');
        break;

      case '':
        // Empty command
        break;

      default:
        term.writeln(`\x1b[31mbash: ${cmd}: command not found\x1b[0m`);
        term.writeln('Type "help" for available commands.');
        break;
    }
  };

  const simulateDelay = (ms: number) =>
    new Promise((resolve) => setTimeout(resolve, ms));

  return (
    <Box sx={{ height: '100%', width: '100%' }}>
      <Alert severity="info" sx={{ mb: 1 }}>
        This is a simulated terminal. In production, connect via SSH/WinRM for real command execution.
      </Alert>
      <Box
        ref={terminalRef}
        sx={{
          height: 'calc(100% - 60px)',
          width: '100%',
          borderRadius: 1,
          overflow: 'hidden',
        }}
      />
    </Box>
  );
};

export default TerminalEmulator;
