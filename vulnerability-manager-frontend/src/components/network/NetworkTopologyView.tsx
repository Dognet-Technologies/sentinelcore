// src/components/network/NetworkTopologyView.tsx
// Network Topology Visualization con Cytoscape.js

import React, { useEffect, useRef, useState } from 'react';
import cytoscape, { Core, NodeSingular } from 'cytoscape';
import {
  Box,
  Paper,
  Toolbar,
  Button,
  Typography,
  CircularProgress,
  Tooltip,
  IconButton,
} from '@mui/material';
import {
  PlayArrow,
  Stop,
  Refresh,
  ZoomIn,
  ZoomOut,
  CenterFocusStrong,
} from '@mui/icons-material';
import DeviceContextMenu from './DeviceContextMenu';
import RemediationPanel from './RemediationPanel';

interface NetworkDevice {
  id: string;
  ip_address: string;
  hostname?: string;
  device_type: string;
  device_status: string;
  os_name?: string;
  vulnerabilities?: number;
}

interface NetworkLink {
  id: string;
  source: string;
  target: string;
  link_type: string;
}

interface NetworkTopology {
  devices: NetworkDevice[];
  links: NetworkLink[];
}

const NetworkTopologyView: React.FC = () => {
  const cyRef = useRef<Core | null>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const [loading, setLoading] = useState(false);
  const [scanning, setScanning] = useState(false);
  const [topology, setTopology] = useState<NetworkTopology | null>(null);
  const [contextMenu, setContextMenu] = useState<{
    x: number;
    y: number;
    device: NetworkDevice | null;
  } | null>(null);
  const [selectedDevice, setSelectedDevice] = useState<NetworkDevice | null>(null);
  const [showRemediation, setShowRemediation] = useState(false);

  // Inizializza Cytoscape
  useEffect(() => {
    if (!containerRef.current || cyRef.current) return;

    const cy = cytoscape({
      container: containerRef.current,
      style: [
        {
          selector: 'node',
          style: {
            'background-color': (ele) => getNodeColor(ele.data('device_type')),
            'border-width': 3,
            'border-color': (ele) =>
              ele.data('device_status') === 'online' ? '#4caf50' : '#f44336',
            label: 'data(label)',
            'text-valign': 'bottom',
            'text-halign': 'center',
            'font-size': '12px',
            width: (ele) => {
              const vulnCount = ele.data('vulnerabilities') || 0;
              return 30 + vulnCount * 2;
            },
            height: (ele) => {
              const vulnCount = ele.data('vulnerabilities') || 0;
              return 30 + vulnCount * 2;
            },
          },
        },
        {
          selector: 'node[vulnerabilities > 0]',
          style: {
            'border-width': 5,
            'border-color': (ele) => {
              const vulnCount = ele.data('vulnerabilities');
              if (vulnCount >= 10) return '#d32f2f'; // Critical
              if (vulnCount >= 5) return '#ff9800'; // High
              return '#ffc107'; // Medium
            },
          },
        },
        {
          selector: 'edge',
          style: {
            width: 2,
            'line-color': '#ccc',
            'target-arrow-color': '#ccc',
            'target-arrow-shape': 'triangle',
            'curve-style': 'bezier',
          },
        },
        {
          selector: ':selected',
          style: {
            'background-color': '#2196f3',
            'border-color': '#1976d2',
            'border-width': 5,
          },
        },
      ],
      layout: {
        name: 'cose', // Force-directed layout
        animate: true,
        animationDuration: 1000,
        idealEdgeLength: 100,
        nodeRepulsion: 8000,
      },
    });

    // Event handlers
    cy.on('tap', 'node', (evt) => {
      const node = evt.target;
      const device: NetworkDevice = {
        id: node.data('id'),
        ip_address: node.data('ip_address'),
        hostname: node.data('hostname'),
        device_type: node.data('device_type'),
        device_status: node.data('device_status'),
        os_name: node.data('os_name'),
        vulnerabilities: node.data('vulnerabilities'),
      };
      setSelectedDevice(device);
    });

    cy.on('cxttap', 'node', (evt) => {
      evt.preventDefault();
      const node = evt.target;
      const position = evt.renderedPosition || evt.position;

      const device: NetworkDevice = {
        id: node.data('id'),
        ip_address: node.data('ip_address'),
        hostname: node.data('hostname'),
        device_type: node.data('device_type'),
        device_status: node.data('device_status'),
        os_name: node.data('os_name'),
        vulnerabilities: node.data('vulnerabilities'),
      };

      setContextMenu({
        x: position.x,
        y: position.y,
        device,
      });
    });

    cy.on('tap', (evt) => {
      if (evt.target === cy) {
        setContextMenu(null);
        setSelectedDevice(null);
      }
    });

    cyRef.current = cy;

    return () => {
      cy.destroy();
    };
  }, []);

  // Carica topologia dal server
  const loadTopology = async () => {
    setLoading(true);
    try {
      const response = await fetch('/api/network/topology');
      const data: NetworkTopology = await response.json();
      setTopology(data);
      updateCytoscape(data);
    } catch (error) {
      console.error('Failed to load topology:', error);
    } finally {
      setLoading(false);
    }
  };

  // Avvia network scan
  const startScan = async () => {
    setScanning(true);
    try {
      const response = await fetch('/api/network/scan', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          scan_name: `Scan ${new Date().toISOString()}`,
          scan_type: 'arp-scan',
          target_range: '192.168.1.0/24',
          include_port_scan: true,
          include_os_detection: true,
        }),
      });

      const result = await response.json();
      console.log('Scan started:', result);

      // Poll for updates
      const pollInterval = setInterval(async () => {
        const statusResponse = await fetch(`/api/network/scan/${result.scan_id}`);
        const status = await statusResponse.json();

        if (status.status === 'completed') {
          clearInterval(pollInterval);
          setScanning(false);
          loadTopology();
        } else if (status.status === 'failed') {
          clearInterval(pollInterval);
          setScanning(false);
        }
      }, 2000);
    } catch (error) {
      console.error('Failed to start scan:', error);
      setScanning(false);
    }
  };

  // Aggiorna grafo Cytoscape
  const updateCytoscape = (data: NetworkTopology) => {
    if (!cyRef.current) return;

    const cy = cyRef.current;
    cy.elements().remove();

    // Aggiungi nodi
    data.devices.forEach((device) => {
      cy.add({
        group: 'nodes',
        data: {
          id: device.id,
          label: device.hostname || device.ip_address,
          ip_address: device.ip_address,
          hostname: device.hostname,
          device_type: device.device_type,
          device_status: device.device_status,
          os_name: device.os_name,
          vulnerabilities: device.vulnerabilities || 0,
        },
      });
    });

    // Aggiungi edges
    data.links.forEach((link) => {
      cy.add({
        group: 'edges',
        data: {
          id: link.id,
          source: link.source,
          target: link.target,
          link_type: link.link_type,
        },
      });
    });

    // Re-run layout
    cy.layout({ name: 'cose', animate: true }).run();
  };

  const getNodeColor = (deviceType: string): string => {
    const colors: Record<string, string> = {
      router: '#1976d2',
      switch: '#388e3c',
      firewall: '#d32f2f',
      server: '#7b1fa2',
      workstation: '#f57c00',
      iot: '#0097a7',
      printer: '#5d4037',
      unknown: '#757575',
    };
    return colors[deviceType] || colors.unknown;
  };

  const handleZoomIn = () => cyRef.current?.zoom(cyRef.current.zoom() * 1.2);
  const handleZoomOut = () => cyRef.current?.zoom(cyRef.current.zoom() * 0.8);
  const handleCenter = () => cyRef.current?.fit();

  const handleContextMenuAction = (action: string) => {
    if (!contextMenu?.device) return;

    switch (action) {
      case 'view':
        setSelectedDevice(contextMenu.device);
        break;
      case 'fix':
        setSelectedDevice(contextMenu.device);
        setShowRemediation(true);
        break;
      case 'scan':
        console.log('Scan device:', contextMenu.device.ip_address);
        break;
    }

    setContextMenu(null);
  };

  useEffect(() => {
    loadTopology();
  }, []);

  return (
    <Box sx={{ height: '100vh', display: 'flex', flexDirection: 'column' }}>
      <Paper sx={{ mb: 1 }}>
        <Toolbar variant="dense">
          <Typography variant="h6" sx={{ flexGrow: 1 }}>
            Network Topology
          </Typography>

          <Tooltip title="Start Scan">
            <span>
              <IconButton
                onClick={startScan}
                disabled={scanning}
                color="primary"
              >
                {scanning ? <CircularProgress size={24} /> : <PlayArrow />}
              </IconButton>
            </span>
          </Tooltip>

          <Tooltip title="Refresh">
            <IconButton onClick={loadTopology} disabled={loading}>
              <Refresh />
            </IconButton>
          </Tooltip>

          <Tooltip title="Zoom In">
            <IconButton onClick={handleZoomIn}>
              <ZoomIn />
            </IconButton>
          </Tooltip>

          <Tooltip title="Zoom Out">
            <IconButton onClick={handleZoomOut}>
              <ZoomOut />
            </IconButton>
          </Tooltip>

          <Tooltip title="Center">
            <IconButton onClick={handleCenter}>
              <CenterFocusStrong />
            </IconButton>
          </Tooltip>
        </Toolbar>
      </Paper>

      <Box sx={{ flex: 1, position: 'relative' }}>
        <div
          ref={containerRef}
          style={{
            width: '100%',
            height: '100%',
            backgroundColor: '#fafafa',
          }}
        />

        {loading && (
          <Box
            sx={{
              position: 'absolute',
              top: '50%',
              left: '50%',
              transform: 'translate(-50%, -50%)',
            }}
          >
            <CircularProgress />
          </Box>
        )}

        {contextMenu && (
          <DeviceContextMenu
            x={contextMenu.x}
            y={contextMenu.y}
            device={contextMenu.device}
            onAction={handleContextMenuAction}
            onClose={() => setContextMenu(null)}
          />
        )}

        {selectedDevice && showRemediation && (
          <RemediationPanel
            device={selectedDevice}
            onClose={() => {
              setShowRemediation(false);
              setSelectedDevice(null);
            }}
          />
        )}
      </Box>
    </Box>
  );
};

export default NetworkTopologyView;
