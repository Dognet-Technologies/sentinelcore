// src/components/notifications/NotificationBell.tsx
import React, { useState, useEffect } from 'react';
import {
  IconButton,
  Badge,
  Menu,
  MenuItem,
  Typography,
  Box,
  Divider,
  ListItemText,
  Tooltip,
  Chip,
  CircularProgress,
  Button,
} from '@mui/material';
import {
  Notifications as NotificationsIcon,
  CheckCircle as CheckCircleIcon,
  Error as ErrorIcon,
  Warning as WarningIcon,
  Info as InfoIcon,
} from '@mui/icons-material';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import axios from 'axios';
import { useNavigate } from 'react-router-dom';
import { formatDistanceToNow } from 'date-fns';
import { it } from 'date-fns/locale';
import { useAuth } from '../../contexts/AuthContext';
import { Alert, AlertTitle } from '@mui/material';
import { userNotificationsApi } from '../../api/userNotifications';

const API_URL = process.env.REACT_APP_API_URL || 'http://localhost:8000';

export const NotificationBell: React.FC = () => {
  const navigate = useNavigate();
  const queryClient = useQueryClient();
  const { user } = useAuth();
  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);
  const open = Boolean(anchorEl);

  const isAdminOrTeamLeader = user?.role === 'admin' || user?.role === 'team_leader';

  // Fetch unread count (poll every 30 seconds)
  const { data: unreadCountData } = useQuery({
    queryKey: ['notifications', 'unread-count'],
    queryFn: userNotificationsApi.getUnreadCount,
    refetchInterval: 30000, // Poll every 30 seconds
  });

  // Fetch unassigned users (admin and team_leader only)
  const { data: unassignedUsersData } = useQuery({
    queryKey: ['users', 'unassigned'],
    queryFn: async () => {
      const response = await axios.get(`${API_URL}/api/users/unassigned`);
      return response.data;
    },
    enabled: isAdminOrTeamLeader && open, // Only fetch when menu is open and user is admin/team_leader
    refetchInterval: 60000, // Poll every minute
  });

  // Fetch notifications list when menu is open
  const { data: notificationsData, isLoading } = useQuery({
    queryKey: ['notifications', 'list'],
    queryFn: () => userNotificationsApi.listNotifications({ limit: 20 }),
    enabled: open, // Only fetch when menu is open
  });

  // Mark notification as read
  const markAsReadMutation = useMutation({
    mutationFn: userNotificationsApi.markAsRead,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['notifications'] });
    },
  });

  // Mark all as read
  const markAllAsReadMutation = useMutation({
    mutationFn: userNotificationsApi.markAllAsRead,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['notifications'] });
    },
  });

  // Dismiss notification
  const dismissMutation = useMutation({
    mutationFn: userNotificationsApi.dismiss,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['notifications'] });
    },
  });

  const handleClick = (event: React.MouseEvent<HTMLElement>) => {
    setAnchorEl(event.currentTarget);
  };

  const handleClose = () => {
    setAnchorEl(null);
  };

  const handleNotificationClick = (notification: UserNotification) => {
    // Mark as read
    if (!notification.is_read) {
      markAsReadMutation.mutate(notification.id);
    }

    // Navigate to action URL if exists
    if (notification.action_url) {
      navigate(notification.action_url);
    }

    handleClose();
  };

  const handleMarkAllRead = () => {
    markAllAsReadMutation.mutate();
  };

  const getPriorityColor = (priority: string) => {
    switch (priority) {
      case 'urgent':
        return 'error';
      case 'high':
        return 'warning';
      case 'medium':
        return 'info';
      case 'low':
      default:
        return 'default';
    }
  };

  const getNotificationIcon = (type: string, priority: string) => {
    if (priority === 'urgent' || type.includes('breached')) {
      return <ErrorIcon color="error" fontSize="small" />;
    }
    if (priority === 'high' || type.includes('warning')) {
      return <WarningIcon color="warning" fontSize="small" />;
    }
    if (type.includes('assigned') || type.includes('closed')) {
      return <CheckCircleIcon color="success" fontSize="small" />;
    }
    return <InfoIcon color="info" fontSize="small" />;
  };

  const unreadCount = unreadCountData?.unread_count || 0;
  const notifications = notificationsData?.notifications || [];
  const unassignedUsers = unassignedUsersData || [];
  const hasUnassignedUsers = isAdminOrTeamLeader && unassignedUsers.length > 0;

  // Total badge count: notifications + unassigned users alert (if admin/team_leader)
  const totalBadgeCount = hasUnassignedUsers ? unreadCount + 1 : unreadCount;
  const tooltipText = hasUnassignedUsers
    ? `${unreadCount} notifiche non lette • ${unassignedUsers.length} utenti non assegnati`
    : `${unreadCount} notifiche non lette`;

  return (
    <>
      <Tooltip title={tooltipText}>
        <IconButton color="inherit" onClick={handleClick}>
          <Badge badgeContent={totalBadgeCount} color="error">
            <NotificationsIcon />
          </Badge>
        </IconButton>
      </Tooltip>

      <Menu
        anchorEl={anchorEl}
        open={open}
        onClose={handleClose}
        PaperProps={{
          sx: {
            width: 400,
            maxHeight: 600,
          },
        }}
        transformOrigin={{ horizontal: 'right', vertical: 'top' }}
        anchorOrigin={{ horizontal: 'right', vertical: 'bottom' }}
      >
        <Box sx={{ px: 2, py: 1.5, display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
          <Typography variant="h6">Notifiche</Typography>
          {unreadCount > 0 && (
            <Button size="small" onClick={handleMarkAllRead}>
              Segna tutte lette
            </Button>
          )}
        </Box>
        <Divider />

        {/* Alert for unassigned users (admin and team_leader only) */}
        {hasUnassignedUsers && (
          <Box sx={{ px: 2, py: 2 }}>
            <Alert
              severity="warning"
              sx={{ cursor: 'pointer' }}
              onClick={() => {
                navigate('/users');
                handleClose();
              }}
            >
              <AlertTitle>⚠️ Utenti non assegnati</AlertTitle>
              Ci sono <strong>{unassignedUsers.length} utenti</strong> che non sono assegnati a nessun team.
              <br />
              <Typography variant="caption">
                Clicca per andare alla pagina Utenti e assegnarli a un team.
              </Typography>
            </Alert>
          </Box>
        )}

        {isLoading && (
          <Box sx={{ display: 'flex', justifyContent: 'center', py: 4 }}>
            <CircularProgress size={24} />
          </Box>
        )}

        {!isLoading && notifications.length === 0 && (
          <Box sx={{ px: 2, py: 4, textAlign: 'center' }}>
            <Typography color="text.secondary">Nessuna notifica</Typography>
          </Box>
        )}

        {!isLoading && notifications.length > 0 && (
          <Box sx={{ maxHeight: 500, overflow: 'auto' }}>
            {notifications.map((notification) => (
              <MenuItem
                key={notification.id}
                onClick={() => handleNotificationClick(notification)}
                sx={{
                  py: 1.5,
                  px: 2,
                  backgroundColor: notification.is_read ? 'transparent' : 'action.hover',
                  '&:hover': {
                    backgroundColor: notification.is_read ? 'action.hover' : 'action.selected',
                  },
                  borderLeft: !notification.is_read ? 4 : 0,
                  borderColor: `${getPriorityColor(notification.priority)}.main`,
                }}
              >
                <Box sx={{ display: 'flex', gap: 1.5, width: '100%', alignItems: 'flex-start' }}>
                  <Box sx={{ pt: 0.5 }}>
                    {getNotificationIcon(notification.notification_type, notification.priority)}
                  </Box>
                  <Box sx={{ flex: 1, minWidth: 0 }}>
                    <Typography variant="subtitle2" sx={{ fontWeight: notification.is_read ? 'normal' : 'bold' }}>
                      {notification.title}
                    </Typography>
                    <Typography variant="body2" color="text.secondary" sx={{ mt: 0.5, mb: 1 }}>
                      {notification.message}
                    </Typography>
                    <Box sx={{ display: 'flex', gap: 1, alignItems: 'center' }}>
                      <Typography variant="caption" color="text.secondary">
                        {formatDistanceToNow(new Date(notification.created_at), { addSuffix: true, locale: it })}
                      </Typography>
                      {notification.priority !== 'medium' && notification.priority !== 'low' && (
                        <Chip
                          label={notification.priority.toUpperCase()}
                          size="small"
                          color={getPriorityColor(notification.priority) as any}
                          sx={{ height: 20, fontSize: '0.65rem' }}
                        />
                      )}
                    </Box>
                  </Box>
                </Box>
              </MenuItem>
            ))}
          </Box>
        )}

        {notifications.length > 0 && (
          <>
            <Divider />
            <Box sx={{ px: 2, py: 1, textAlign: 'center' }}>
              <Button size="small" onClick={() => {
                navigate('/notifications');
                handleClose();
              }}>
                Vedi tutte le notifiche
              </Button>
            </Box>
          </>
        )}
      </Menu>
    </>
  );
};
