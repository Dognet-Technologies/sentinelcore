// src/components/notifications/NotificationBell.tsx
import React, { useState, useEffect } from 'react';
import {
  IconButton,
  Badge,
  Menu,
  MenuItem,
  Typography,
  Box,
  Divider,
  ListItemText,
  Tooltip,
  Chip,
  CircularProgress,
  Button,
} from '@mui/material';
import {
  Notifications as NotificationsIcon,
  CheckCircle as CheckCircleIcon,
  Error as ErrorIcon,
  Warning as WarningIcon,
  Info as InfoIcon,
} from '@mui/icons-material';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import axios from 'axios';
import { useNavigate } from 'react-router-dom';
import { formatDistanceToNow } from 'date-fns';
import { it } from 'date-fns/locale';

interface UserNotification {
  id: string;
  notification_type: string;
  priority: 'low' | 'normal' | 'high' | 'urgent';
  title: string;
  message: string;
  action_url?: string;
  vulnerability_id?: string;
  team_id?: string;
  actor_name?: string;
  metadata?: any;
  is_read: boolean;
  read_at?: string;
  created_at: string;
}

interface NotificationListResponse {
  notifications: UserNotification[];
  total_count: number;
  unread_count: number;
}

const API_URL = process.env.REACT_APP_API_URL || 'http://localhost:8000';

export const NotificationBell: React.FC = () => {
  const navigate = useNavigate();
  const queryClient = useQueryClient();
  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);
  const open = Boolean(anchorEl);

  // Fetch unread count (poll every 30 seconds)
  const { data: unreadCountData } = useQuery({
    queryKey: ['notifications', 'unread-count'],
    queryFn: async () => {
      const response = await axios.get(`${API_URL}/api/notifications/unread-count`);
      return response.data;
    },
    refetchInterval: 30000, // Poll every 30 seconds
  });

  // Fetch notifications list when menu is open
  const { data: notificationsData, isLoading } = useQuery({
    queryKey: ['notifications', 'list'],
    queryFn: async () => {
      const response = await axios.get<NotificationListResponse>(`${API_URL}/api/notifications`, {
        params: { limit: 20 },
      });
      return response.data;
    },
    enabled: open, // Only fetch when menu is open
  });

  // Mark notification as read
  const markAsReadMutation = useMutation({
    mutationFn: async (notificationId: string) => {
      await axios.put(`${API_URL}/api/notifications/${notificationId}/read`);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['notifications'] });
    },
  });

  // Mark all as read
  const markAllAsReadMutation = useMutation({
    mutationFn: async () => {
      await axios.put(`${API_URL}/api/notifications/read-all`);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['notifications'] });
    },
  });

  // Dismiss notification
  const dismissMutation = useMutation({
    mutationFn: async (notificationId: string) => {
      await axios.delete(`${API_URL}/api/notifications/${notificationId}`);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['notifications'] });
    },
  });

  const handleClick = (event: React.MouseEvent<HTMLElement>) => {
    setAnchorEl(event.currentTarget);
  };

  const handleClose = () => {
    setAnchorEl(null);
  };

  const handleNotificationClick = (notification: UserNotification) => {
    // Mark as read
    if (!notification.is_read) {
      markAsReadMutation.mutate(notification.id);
    }

    // Navigate to action URL if exists
    if (notification.action_url) {
      navigate(notification.action_url);
    }

    handleClose();
  };

  const handleMarkAllRead = () => {
    markAllAsReadMutation.mutate();
  };

  const getPriorityColor = (priority: string) => {
    switch (priority) {
      case 'urgent':
        return 'error';
      case 'high':
        return 'warning';
      case 'normal':
        return 'primary';
      case 'low':
      default:
        return 'default';
    }
  };

  const getNotificationIcon = (type: string, priority: string) => {
    if (priority === 'urgent' || type.includes('breached')) {
      return <ErrorIcon color="error" fontSize="small" />;
    }
    if (priority === 'high' || type.includes('warning')) {
      return <WarningIcon color="warning" fontSize="small" />;
    }
    if (type.includes('assigned') || type.includes('closed')) {
      return <CheckCircleIcon color="success" fontSize="small" />;
    }
    return <InfoIcon color="info" fontSize="small" />;
  };

  const unreadCount = unreadCountData?.unread_count || 0;
  const notifications = notificationsData?.notifications || [];

  return (
    <>
      <Tooltip title={`${unreadCount} notifiche non lette`}>
        <IconButton color="inherit" onClick={handleClick}>
          <Badge badgeContent={unreadCount} color="error">
            <NotificationsIcon />
          </Badge>
        </IconButton>
      </Tooltip>

      <Menu
        anchorEl={anchorEl}
        open={open}
        onClose={handleClose}
        PaperProps={{
          sx: {
            width: 400,
            maxHeight: 600,
          },
        }}
        transformOrigin={{ horizontal: 'right', vertical: 'top' }}
        anchorOrigin={{ horizontal: 'right', vertical: 'bottom' }}
      >
        <Box sx={{ px: 2, py: 1.5, display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
          <Typography variant="h6">Notifiche</Typography>
          {unreadCount > 0 && (
            <Button size="small" onClick={handleMarkAllRead}>
              Segna tutte lette
            </Button>
          )}
        </Box>
        <Divider />

        {isLoading && (
          <Box sx={{ display: 'flex', justifyContent: 'center', py: 4 }}>
            <CircularProgress size={24} />
          </Box>
        )}

        {!isLoading && notifications.length === 0 && (
          <Box sx={{ px: 2, py: 4, textAlign: 'center' }}>
            <Typography color="text.secondary">Nessuna notifica</Typography>
          </Box>
        )}

        {!isLoading && notifications.length > 0 && (
          <Box sx={{ maxHeight: 500, overflow: 'auto' }}>
            {notifications.map((notification) => (
              <MenuItem
                key={notification.id}
                onClick={() => handleNotificationClick(notification)}
                sx={{
                  py: 1.5,
                  px: 2,
                  backgroundColor: notification.is_read ? 'transparent' : 'action.hover',
                  '&:hover': {
                    backgroundColor: notification.is_read ? 'action.hover' : 'action.selected',
                  },
                  borderLeft: !notification.is_read ? 4 : 0,
                  borderColor: `${getPriorityColor(notification.priority)}.main`,
                }}
              >
                <Box sx={{ display: 'flex', gap: 1.5, width: '100%', alignItems: 'flex-start' }}>
                  <Box sx={{ pt: 0.5 }}>
                    {getNotificationIcon(notification.notification_type, notification.priority)}
                  </Box>
                  <Box sx={{ flex: 1, minWidth: 0 }}>
                    <Typography variant="subtitle2" sx={{ fontWeight: notification.is_read ? 'normal' : 'bold' }}>
                      {notification.title}
                    </Typography>
                    <Typography variant="body2" color="text.secondary" sx={{ mt: 0.5, mb: 1 }}>
                      {notification.message}
                    </Typography>
                    <Box sx={{ display: 'flex', gap: 1, alignItems: 'center' }}>
                      <Typography variant="caption" color="text.secondary">
                        {formatDistanceToNow(new Date(notification.created_at), { addSuffix: true, locale: it })}
                      </Typography>
                      {notification.priority !== 'normal' && notification.priority !== 'low' && (
                        <Chip
                          label={notification.priority.toUpperCase()}
                          size="small"
                          color={getPriorityColor(notification.priority) as any}
                          sx={{ height: 20, fontSize: '0.65rem' }}
                        />
                      )}
                    </Box>
                  </Box>
                </Box>
              </MenuItem>
            ))}
          </Box>
        )}

        {notifications.length > 0 && (
          <>
            <Divider />
            <Box sx={{ px: 2, py: 1, textAlign: 'center' }}>
              <Button size="small" onClick={() => {
                navigate('/notifications');
                handleClose();
              }}>
                Vedi tutte le notifiche
              </Button>
            </Box>
          </>
        )}
      </Menu>
    </>
  );
};
