// TableDashlet.tsx - Entuity-style Table dashlet
// Lists and details components like network adapters, ports, etc.

import React, { useState } from 'react';
import {
  Card,
  CardHeader,
  CardContent,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  TablePagination,
  TableSortLabel,
  Box,
  Typography,
  Chip,
  IconButton,
  Tooltip,
  TextField,
  InputAdornment,
  Stack,
} from '@mui/material';
import {
  Refresh as RefreshIcon,
  Download as DownloadIcon,
  Search as SearchIcon,
  FilterList as FilterListIcon,
} from '@mui/icons-material';
import { entuityColors, getSeverityColor, getDeviceStatusColor } from '../../theme/entuityTheme';

export interface TableColumn {
  id: string;
  label: string;
  numeric?: boolean;
  format?: (value: any) => string | React.ReactNode;
  sortable?: boolean;
}

export interface TableRowData {
  id: string;
  [key: string]: any;
  status?: 'online' | 'offline' | 'warning' | 'maintenance' | 'up' | 'down';
  severity?: 'critical' | 'high' | 'medium' | 'low' | 'info' | 'none';
}

export interface TableDashletProps {
  title: string;
  subtitle?: string;
  columns: TableColumn[];
  rows: TableRowData[];
  onRowClick?: (row: TableRowData) => void;
  onRefresh?: () => void;
  onExport?: () => void;
  searchable?: boolean;
  sortable?: boolean;
  dense?: boolean;
}

type Order = 'asc' | 'desc';

const TableDashlet: React.FC<TableDashletProps> = ({
  title,
  subtitle,
  columns,
  rows,
  onRowClick,
  onRefresh,
  onExport,
  searchable = true,
  sortable = true,
  dense = false,
}) => {
  const [page, setPage] = useState(0);
  const [rowsPerPage, setRowsPerPage] = useState(10);
  const [order, setOrder] = useState<Order>('asc');
  const [orderBy, setOrderBy] = useState<string>(columns[0]?.id || '');
  const [searchQuery, setSearchQuery] = useState('');

  // Handle sort
  const handleRequestSort = (property: string) => {
    if (!sortable) return;

    const isAsc = orderBy === property && order === 'asc';
    setOrder(isAsc ? 'desc' : 'asc');
    setOrderBy(property);
  };

  // Handle pagination
  const handleChangePage = (_: unknown, newPage: number) => {
    setPage(newPage);
  };

  const handleChangeRowsPerPage = (event: React.ChangeEvent<HTMLInputElement>) => {
    setRowsPerPage(parseInt(event.target.value, 10));
    setPage(0);
  };

  // Filter rows based on search
  const filteredRows = React.useMemo(() => {
    if (!searchQuery) return rows;

    return rows.filter((row) =>
      Object.values(row).some((value) =>
        String(value).toLowerCase().includes(searchQuery.toLowerCase())
      )
    );
  }, [rows, searchQuery]);

  // Sort rows
  const sortedRows = React.useMemo(() => {
    if (!sortable || !orderBy) return filteredRows;

    return [...filteredRows].sort((a, b) => {
      const aValue = a[orderBy];
      const bValue = b[orderBy];

      if (aValue == null) return 1;
      if (bValue == null) return -1;

      const comparison = aValue < bValue ? -1 : aValue > bValue ? 1 : 0;
      return order === 'asc' ? comparison : -comparison;
    });
  }, [filteredRows, order, orderBy, sortable]);

  // Paginate rows
  const paginatedRows = sortedRows.slice(
    page * rowsPerPage,
    page * rowsPerPage + rowsPerPage
  );

  // Format cell value
  const formatCellValue = (row: TableRowData, column: TableColumn) => {
    const value = row[column.id];

    if (column.format) {
      return column.format(value);
    }

    // Auto-format status
    if (column.id === 'status' && value) {
      const color = getDeviceStatusColor(value);
      return (
        <Chip
          label={String(value).toUpperCase()}
          size="small"
          sx={{
            backgroundColor: color,
            color: 'white',
            fontWeight: 600,
          }}
        />
      );
    }

    // Auto-format severity
    if (column.id === 'severity' && value && value !== 'none') {
      const color = getSeverityColor(value);
      return (
        <Chip
          label={String(value).toUpperCase()}
          size="small"
          sx={{
            backgroundColor: color,
            color: 'white',
            fontWeight: 600,
          }}
        />
      );
    }

    return value;
  };

  return (
    <Card sx={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
      <CardHeader
        title={
          <Box>
            <Typography variant="h6">{title}</Typography>
            {subtitle && (
              <Typography variant="caption" sx={{ color: entuityColors.text.secondary }}>
                {subtitle}
              </Typography>
            )}
          </Box>
        }
        action={
          <Stack direction="row" spacing={1} alignItems="center">
            {searchable && (
              <TextField
                size="small"
                placeholder="Search..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                sx={{ minWidth: 200 }}
                InputProps={{
                  startAdornment: (
                    <InputAdornment position="start">
                      <SearchIcon fontSize="small" />
                    </InputAdornment>
                  ),
                }}
              />
            )}
            {onRefresh && (
              <Tooltip title="Refresh">
                <IconButton size="small" onClick={onRefresh}>
                  <RefreshIcon />
                </IconButton>
              </Tooltip>
            )}
            {onExport && (
              <Tooltip title="Export">
                <IconButton size="small" onClick={onExport}>
                  <DownloadIcon />
                </IconButton>
              </Tooltip>
            )}
          </Stack>
        }
      />

      <CardContent sx={{ flex: 1, overflow: 'auto', p: 0 }}>
        <TableContainer>
          <Table size={dense ? 'small' : 'medium'} stickyHeader>
            <TableHead>
              <TableRow>
                {columns.map((column) => (
                  <TableCell
                    key={column.id}
                    align={column.numeric ? 'right' : 'left'}
                    sortDirection={orderBy === column.id ? order : false}
                    sx={{
                      backgroundColor: entuityColors.background.default,
                      fontWeight: 600,
                    }}
                  >
                    {sortable && column.sortable !== false ? (
                      <TableSortLabel
                        active={orderBy === column.id}
                        direction={orderBy === column.id ? order : 'asc'}
                        onClick={() => handleRequestSort(column.id)}
                      >
                        {column.label}
                      </TableSortLabel>
                    ) : (
                      column.label
                    )}
                  </TableCell>
                ))}
              </TableRow>
            </TableHead>
            <TableBody>
              {paginatedRows.length === 0 ? (
                <TableRow>
                  <TableCell
                    colSpan={columns.length}
                    align="center"
                    sx={{ py: 4, color: entuityColors.text.secondary }}
                  >
                    <Typography>No data available</Typography>
                  </TableCell>
                </TableRow>
              ) : (
                paginatedRows.map((row) => {
                  const rowColor = row.severity && row.severity !== 'none'
                    ? getSeverityColor(row.severity)
                    : undefined;

                  return (
                    <TableRow
                      key={row.id}
                      hover
                      onClick={() => onRowClick?.(row)}
                      sx={{
                        cursor: onRowClick ? 'pointer' : 'default',
                        borderLeft: rowColor ? `4px solid ${rowColor}` : 'none',
                        '&:hover': {
                          backgroundColor: `${entuityColors.primary.main}10`,
                        },
                      }}
                    >
                      {columns.map((column) => (
                        <TableCell
                          key={column.id}
                          align={column.numeric ? 'right' : 'left'}
                        >
                          {formatCellValue(row, column)}
                        </TableCell>
                      ))}
                    </TableRow>
                  );
                })
              )}
            </TableBody>
          </Table>
        </TableContainer>

        <TablePagination
          rowsPerPageOptions={[5, 10, 25, 50]}
          component="div"
          count={filteredRows.length}
          rowsPerPage={rowsPerPage}
          page={page}
          onPageChange={handleChangePage}
          onRowsPerPageChange={handleChangeRowsPerPage}
          sx={{
            borderTop: `1px solid ${entuityColors.text.disabled}`,
            backgroundColor: entuityColors.background.paper,
          }}
        />
      </CardContent>
    </Card>
  );
};

export default TableDashlet;
