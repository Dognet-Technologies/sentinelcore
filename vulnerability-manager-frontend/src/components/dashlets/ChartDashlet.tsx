// ChartDashlet.tsx - Entuity-style Chart dashlet
// Displays current and historical data like CPU utilization

import React, { useMemo } from 'react';
import {
  Card,
  CardHeader,
  CardContent,
  Box,
  Typography,
  Stack,
  Chip,
  IconButton,
  Tooltip,
  MenuItem,
  Select,
} from '@mui/material';
import {
  Refresh as RefreshIcon,
  Download as DownloadIcon,
  MoreVert as MoreVertIcon,
} from '@mui/icons-material';
import {
  LineChart,
  Line,
  AreaChart,
  Area,
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip as RechartsTooltip,
  Legend,
  ResponsiveContainer,
} from 'recharts';
import { entuityColors } from '../../theme/entuityTheme';

export interface ChartDataPoint {
  timestamp: string;
  value: number;
  label?: string;
}

export interface ChartSeries {
  name: string;
  data: ChartDataPoint[];
  color: string;
  unit?: string;
}

export interface ChartDashletProps {
  title: string;
  subtitle?: string;
  chartType: 'line' | 'area' | 'bar';
  series: ChartSeries[];
  currentValue?: number;
  currentUnit?: string;
  threshold?: {
    warning: number;
    critical: number;
  };
  onRefresh?: () => void;
  onExport?: () => void;
  timeRange?: '1h' | '6h' | '24h' | '7d' | '30d';
  onTimeRangeChange?: (range: string) => void;
}

const ChartDashlet: React.FC<ChartDashletProps> = ({
  title,
  subtitle,
  chartType = 'line',
  series,
  currentValue,
  currentUnit = '%',
  threshold,
  onRefresh,
  onExport,
  timeRange = '24h',
  onTimeRangeChange,
}) => {
  // Combine all series data by timestamp
  const chartData = useMemo(() => {
    if (series.length === 0) return [];

    // Get all unique timestamps
    const timestamps = new Set<string>();
    series.forEach(s => s.data.forEach(d => timestamps.add(d.timestamp)));

    // Create combined data
    return Array.from(timestamps)
      .sort()
      .map(timestamp => {
        const point: any = { timestamp };
        series.forEach(s => {
          const dataPoint = s.data.find(d => d.timestamp === timestamp);
          point[s.name] = dataPoint?.value ?? null;
        });
        return point;
      });
  }, [series]);

  // Determine status color based on current value and threshold
  const getStatusColor = () => {
    if (!currentValue || !threshold) return entuityColors.info;
    if (currentValue >= threshold.critical) return entuityColors.critical;
    if (currentValue >= threshold.warning) return entuityColors.warning;
    return entuityColors.success;
  };

  // Format timestamp for display
  const formatXAxis = (timestamp: string) => {
    const date = new Date(timestamp);
    if (timeRange === '1h') {
      return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    } else if (timeRange === '24h') {
      return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    } else {
      return date.toLocaleDateString([], { month: 'short', day: 'numeric' });
    }
  };

  const renderChart = () => {
    const commonProps = {
      data: chartData,
      margin: { top: 10, right: 30, left: 0, bottom: 0 },
    };

    const xAxisProps = {
      dataKey: 'timestamp',
      tickFormatter: formatXAxis,
      stroke: entuityColors.text.secondary,
      style: { fontSize: 12 },
    };

    const yAxisProps = {
      stroke: entuityColors.text.secondary,
      style: { fontSize: 12 },
    };

    switch (chartType) {
      case 'area':
        return (
          <AreaChart {...commonProps}>
            <defs>
              {series.map((s, i) => (
                <linearGradient key={i} id={`gradient-${i}`} x1="0" y1="0" x2="0" y2="1">
                  <stop offset="5%" stopColor={s.color} stopOpacity={0.8} />
                  <stop offset="95%" stopColor={s.color} stopOpacity={0.1} />
                </linearGradient>
              ))}
            </defs>
            <CartesianGrid strokeDasharray="3 3" stroke={entuityColors.text.disabled} opacity={0.3} />
            <XAxis {...xAxisProps} />
            <YAxis {...yAxisProps} />
            <RechartsTooltip
              contentStyle={{
                backgroundColor: 'white',
                border: `1px solid ${entuityColors.text.disabled}`,
                borderRadius: 4,
              }}
            />
            <Legend />
            {series.map((s, i) => (
              <Area
                key={i}
                type="monotone"
                dataKey={s.name}
                stroke={s.color}
                fillOpacity={1}
                fill={`url(#gradient-${i})`}
                strokeWidth={2}
              />
            ))}
          </AreaChart>
        );

      case 'bar':
        return (
          <BarChart {...commonProps}>
            <CartesianGrid strokeDasharray="3 3" stroke={entuityColors.text.disabled} opacity={0.3} />
            <XAxis {...xAxisProps} />
            <YAxis {...yAxisProps} />
            <RechartsTooltip
              contentStyle={{
                backgroundColor: 'white',
                border: `1px solid ${entuityColors.text.disabled}`,
                borderRadius: 4,
              }}
            />
            <Legend />
            {series.map((s, i) => (
              <Bar key={i} dataKey={s.name} fill={s.color} />
            ))}
          </BarChart>
        );

      case 'line':
      default:
        return (
          <LineChart {...commonProps}>
            <CartesianGrid strokeDasharray="3 3" stroke={entuityColors.text.disabled} opacity={0.3} />
            <XAxis {...xAxisProps} />
            <YAxis {...yAxisProps} />
            <RechartsTooltip
              contentStyle={{
                backgroundColor: 'white',
                border: `1px solid ${entuityColors.text.disabled}`,
                borderRadius: 4,
              }}
            />
            <Legend />
            {series.map((s, i) => (
              <Line
                key={i}
                type="monotone"
                dataKey={s.name}
                stroke={s.color}
                strokeWidth={2}
                dot={{ r: 3 }}
                activeDot={{ r: 5 }}
              />
            ))}
          </LineChart>
        );
    }
  };

  return (
    <Card sx={{ height: '100%' }}>
      <CardHeader
        title={
          <Stack direction="row" spacing={2} alignItems="center" justifyContent="space-between">
            <Box>
              <Typography variant="h6">{title}</Typography>
              {subtitle && (
                <Typography variant="caption" sx={{ color: entuityColors.text.secondary }}>
                  {subtitle}
                </Typography>
              )}
            </Box>
            {currentValue !== undefined && (
              <Chip
                label={`${currentValue.toFixed(1)}${currentUnit}`}
                sx={{
                  backgroundColor: getStatusColor(),
                  color: 'white',
                  fontWeight: 700,
                  fontSize: '1rem',
                  height: 36,
                }}
              />
            )}
          </Stack>
        }
        action={
          <Stack direction="row" spacing={0.5}>
            {onTimeRangeChange && (
              <Select
                value={timeRange}
                onChange={(e) => onTimeRangeChange(e.target.value)}
                size="small"
                sx={{ minWidth: 80 }}
              >
                <MenuItem value="1h">1h</MenuItem>
                <MenuItem value="6h">6h</MenuItem>
                <MenuItem value="24h">24h</MenuItem>
                <MenuItem value="7d">7d</MenuItem>
                <MenuItem value="30d">30d</MenuItem>
              </Select>
            )}
            {onRefresh && (
              <Tooltip title="Refresh">
                <IconButton size="small" onClick={onRefresh}>
                  <RefreshIcon />
                </IconButton>
              </Tooltip>
            )}
            {onExport && (
              <Tooltip title="Export">
                <IconButton size="small" onClick={onExport}>
                  <DownloadIcon />
                </IconButton>
              </Tooltip>
            )}
          </Stack>
        }
      />

      <CardContent sx={{ pt: 0 }}>
        <ResponsiveContainer width="100%" height={300}>
          {renderChart()}
        </ResponsiveContainer>

        {/* Threshold indicators */}
        {threshold && (
          <Stack direction="row" spacing={2} mt={2} justifyContent="center">
            <Stack direction="row" spacing={0.5} alignItems="center">
              <Box
                sx={{
                  width: 12,
                  height: 12,
                  backgroundColor: entuityColors.warning,
                  borderRadius: '50%',
                }}
              />
              <Typography variant="caption">Warning: {threshold.warning}{currentUnit}</Typography>
            </Stack>
            <Stack direction="row" spacing={0.5} alignItems="center">
              <Box
                sx={{
                  width: 12,
                  height: 12,
                  backgroundColor: entuityColors.critical,
                  borderRadius: '50%',
                }}
              />
              <Typography variant="caption">Critical: {threshold.critical}{currentUnit}</Typography>
            </Stack>
          </Stack>
        )}
      </CardContent>
    </Card>
  );
};

export default ChartDashlet;
