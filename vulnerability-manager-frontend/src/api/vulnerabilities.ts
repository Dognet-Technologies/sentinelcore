import apiClient from './client';
import { Vulnerability, VulnerabilityFilter } from '../types';
import { assetsApi } from './assets';
import { teamsApi } from './teams';

export const vulnerabilitiesApi = {
  // Helper: Validate input data before sending to backend
  async validateCorrelations(data: Partial<Vulnerability>): Promise<string[]> {
    const errors: string[] = [];

    // Validate asset_id if provided
    if (data.asset_id) {
      try {
        await assetsApi.get(data.asset_id);
      } catch (error) {
        errors.push(`Asset ${data.asset_id} not found or has been deleted`);
      }
    }

    // Validate assigned_team_id if provided
    if (data.assigned_team_id) {
      try {
        await teamsApi.get(data.assigned_team_id);
      } catch (error) {
        errors.push(`Team ${data.assigned_team_id} not found or has been deleted`);
      }
    }

    // Validate CVSS score
    if (data.cvss_score !== undefined && data.cvss_score !== null) {
      if (data.cvss_score < 0 || data.cvss_score > 10) {
        errors.push('CVSS score must be between 0 and 10');
      }
    }

    // Validate port if provided
    if (data.port !== undefined && data.port !== null) {
      if (data.port < 1 || data.port > 65535) {
        errors.push('Port must be between 1 and 65535');
      }
    }

    return errors;
  },

  list: async (filters?: VulnerabilityFilter): Promise<Vulnerability[]> => {
    const response = await apiClient.get('/api/vulnerabilities', { params: filters });
    return response.data;
  },

  get: async (id: string): Promise<Vulnerability> => {
    const response = await apiClient.get(`/vulnerabilities/${id}`);
    return response.data;
  },

  create: async (data: Partial<Vulnerability>): Promise<Vulnerability> => {
    // Validate correlations before sending
    const validationErrors = await vulnerabilitiesApi.validateCorrelations(data);
    if (validationErrors.length > 0) {
      throw new Error(`Validation failed: ${validationErrors.join(', ')}`);
    }

    const response = await apiClient.post('/api/vulnerabilities', data);
    return response.data;
  },

  update: async (id: string, data: Partial<Vulnerability>): Promise<Vulnerability> => {
    // Validate correlations before sending
    const validationErrors = await vulnerabilitiesApi.validateCorrelations(data);
    if (validationErrors.length > 0) {
      throw new Error(`Validation failed: ${validationErrors.join(', ')}`);
    }

    const response = await apiClient.put(`/vulnerabilities/${id}`, data);
    return response.data;
  },

  delete: async (id: string): Promise<void> => {
    await apiClient.delete(`/vulnerabilities/${id}`);
  },

  assignToTeam: async (vulnerabilityId: string, teamId: string): Promise<void> => {
    // Validate team exists before assignment
    try {
      await teamsApi.get(teamId);
    } catch (error) {
      throw new Error(`Team not found or has been deleted`);
    }

    await apiClient.post(`/vulnerabilities/${vulnerabilityId}/assign`, { team_id: teamId });
  },

  assignToUser: async (vulnerabilityId: string, userId: string): Promise<void> => {
    await apiClient.post(`/vulnerabilities/${vulnerabilityId}/assign-user`, { user_id: userId });
  },

  // Check for new vulnerabilities from scanners
  checkNew: async (): Promise<{ found: number; imported: number }> => {
    const response = await apiClient.post('/api/vulnerabilities/check');
    return response.data;
  },

  // Get vulnerabilities assigned to current user
  getMyAssigned: async (): Promise<Vulnerability[]> => {
    const response = await apiClient.get('/api/vulnerabilities/my-assigned');
    return response.data;
  },
};