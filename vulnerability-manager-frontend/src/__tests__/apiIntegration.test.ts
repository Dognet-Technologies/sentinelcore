/**
 * API Integration Tests
 *
 * Verifica che i dati fluiscano correttamente dal backend al frontend:
 * - Le API restituiscono i dati nel formato atteso
 * - I dati sono completi e utilizzabili dal frontend
 * - Le trasformazioni dei dati sono corrette
 * - I filtri funzionano come previsto
 */

import { vulnerabilitiesApi } from '../api/vulnerabilities';
import { assetsApi } from '../api/assets';
import { teamsApi } from '../api/teams';
import { VulnerabilityStatus, VulnerabilitySeverity } from '../types';

describe('API Integration Tests', () => {
  describe('Vulnerabilities API', () => {
    it('should fetch vulnerabilities successfully', async () => {
      const vulnerabilities = await vulnerabilitiesApi.list();

      expect(Array.isArray(vulnerabilities)).toBe(true);
      expect(vulnerabilities.length).toBeGreaterThan(0);

      console.log(`✓ Fetched ${vulnerabilities.length} vulnerabilities`);
    });

    it('should return vulnerabilities with all required fields', async () => {
      const vulnerabilities = await vulnerabilitiesApi.list();
      const sampleVuln = vulnerabilities[0];

      const requiredFields = [
        'id',
        'title',
        'description',
        'cvss_score',
        'ip_address',
        'status',
        'severity',
        'source',
        'discovered_at',
        'created_at',
        'updated_at',
      ];

      for (const field of requiredFields) {
        expect(sampleVuln).toHaveProperty(field);
        expect(sampleVuln[field as keyof typeof sampleVuln]).toBeDefined();
      }

      console.log('✓ All required fields present in vulnerability response');
    });

    it('should filter vulnerabilities by status', async () => {
      const openVulns = await vulnerabilitiesApi.list({
        status: VulnerabilityStatus.Open,
      });

      expect(Array.isArray(openVulns)).toBe(true);

      // Verify all returned vulnerabilities have 'open' status
      const allOpen = openVulns.every(v => v.status === 'open');
      expect(allOpen).toBe(true);

      console.log(`✓ Filtered ${openVulns.length} open vulnerabilities`);
    });

    it('should filter vulnerabilities by severity', async () => {
      const criticalVulns = await vulnerabilitiesApi.list({
        severity: VulnerabilitySeverity.Critical,
      });

      expect(Array.isArray(criticalVulns)).toBe(true);

      const allCritical = criticalVulns.every(v => v.severity === 'critical');
      expect(allCritical).toBe(true);

      console.log(`✓ Filtered ${criticalVulns.length} critical vulnerabilities`);
    });

    it('should fetch a single vulnerability by ID', async () => {
      const vulnerabilities = await vulnerabilitiesApi.list();
      if (vulnerabilities.length === 0) return;

      const firstId = vulnerabilities[0].id;
      const vulnerability = await vulnerabilitiesApi.get(firstId);

      expect(vulnerability).toBeDefined();
      expect(vulnerability.id).toBe(firstId);

      console.log(`✓ Fetched vulnerability: ${vulnerability.title}`);
    });

    it('should include relationship data (asset, team) when present', async () => {
      const vulnerabilities = await vulnerabilitiesApi.list();

      const withAsset = vulnerabilities.filter(v => v.asset_id);
      const withTeam = vulnerabilities.filter(v => v.assigned_team_id);

      console.log(`✓ ${withAsset.length}/${vulnerabilities.length} vulnerabilities have asset references`);
      console.log(`✓ ${withTeam.length}/${vulnerabilities.length} vulnerabilities have team assignments`);

      // Verify team names are populated when team_id is present
      const teamAssignedWithNames = withTeam.filter(v => v.assigned_team_name);
      expect(teamAssignedWithNames.length).toBe(withTeam.length);
    });
  });

  describe('Assets API', () => {
    it('should fetch assets successfully', async () => {
      const assets = await assetsApi.list();

      expect(Array.isArray(assets)).toBe(true);
      expect(assets.length).toBeGreaterThan(0);

      console.log(`✓ Fetched ${assets.length} assets`);
    });

    it('should return assets with vulnerability counts', async () => {
      const assets = await assetsApi.list();

      const withVulnCounts = assets.filter(a => a.vulnerability_count !== undefined);

      expect(withVulnCounts.length).toBeGreaterThan(0);

      console.log(`✓ ${withVulnCounts.length}/${assets.length} assets have vulnerability counts`);
    });

    it('should fetch a single asset by ID', async () => {
      const assets = await assetsApi.list();
      if (assets.length === 0) return;

      const firstId = assets[0].id;
      const asset = await assetsApi.get(firstId);

      expect(asset).toBeDefined();
      expect(asset.id).toBe(firstId);

      console.log(`✓ Fetched asset: ${asset.name}`);
    });

    it('should have consistent data types for asset fields', async () => {
      const assets = await assetsApi.list();
      const sampleAsset = assets[0];

      expect(typeof sampleAsset.id).toBe('string');
      expect(typeof sampleAsset.name).toBe('string');
      expect(typeof sampleAsset.asset_type).toBe('string');

      if (sampleAsset.vulnerability_count !== undefined) {
        expect(typeof sampleAsset.vulnerability_count).toBe('number');
      }

      console.log('✓ Asset field types are correct');
    });
  });

  describe('Teams API', () => {
    it('should fetch teams successfully', async () => {
      const teams = await teamsApi.list();

      expect(Array.isArray(teams)).toBe(true);
      expect(teams.length).toBeGreaterThan(0);

      console.log(`✓ Fetched ${teams.length} teams`);
    });

    it('should return teams with member counts', async () => {
      const teams = await teamsApi.list();

      const withMemberCounts = teams.filter(t => t.members_count !== undefined);

      expect(withMemberCounts.length).toBeGreaterThan(0);

      console.log(`✓ ${withMemberCounts.length}/${teams.length} teams have member counts`);
    });

    it('should fetch a single team by ID', async () => {
      const teams = await teamsApi.list();
      if (teams.length === 0) return;

      const firstId = teams[0].id;
      const team = await teamsApi.get(firstId);

      expect(team).toBeDefined();
      expect(team.id).toBe(firstId);

      console.log(`✓ Fetched team: ${team.name}`);
    });
  });

  describe('Data Transformation', () => {
    it('should handle date fields correctly', async () => {
      const vulnerabilities = await vulnerabilitiesApi.list();
      const sampleVuln = vulnerabilities[0];

      // Verify dates are valid
      const discoveredDate = new Date(sampleVuln.discovered_at);
      const createdDate = new Date(sampleVuln.created_at);

      expect(discoveredDate.toString()).not.toBe('Invalid Date');
      expect(createdDate.toString()).not.toBe('Invalid Date');

      console.log('✓ Date fields are valid and parseable');
    });

    it('should handle numeric fields correctly', async () => {
      const vulnerabilities = await vulnerabilitiesApi.list();
      const sampleVuln = vulnerabilities[0];

      expect(typeof sampleVuln.cvss_score).toBe('number');
      expect(sampleVuln.cvss_score).toBeGreaterThanOrEqual(0);
      expect(sampleVuln.cvss_score).toBeLessThanOrEqual(10);

      if (sampleVuln.epss_score !== undefined) {
        expect(typeof sampleVuln.epss_score).toBe('number');
        expect(sampleVuln.epss_score).toBeGreaterThanOrEqual(0);
        expect(sampleVuln.epss_score).toBeLessThanOrEqual(1);
      }

      console.log('✓ Numeric fields have correct types and ranges');
    });

    it('should handle optional fields gracefully', async () => {
      const vulnerabilities = await vulnerabilitiesApi.list();

      const optionalFields = [
        'hostname',
        'port',
        'protocol',
        'cve_id',
        'cwe_id',
        'remediation',
        'asset_id',
        'assigned_team_id',
        'assigned_user_id',
      ];

      // These fields should be present but may be null/undefined
      for (const vuln of vulnerabilities) {
        for (const field of optionalFields) {
          // Field can be present or absent, but if present and not null,
          // should have the correct type
          const value = vuln[field as keyof typeof vuln];
          if (value !== null && value !== undefined) {
            expect(value).toBeDefined();
          }
        }
      }

      console.log('✓ Optional fields handled correctly');
    });
  });

  describe('Error Handling', () => {
    it('should handle invalid vulnerability ID gracefully', async () => {
      const invalidId = '00000000-0000-0000-0000-000000000000';

      try {
        await vulnerabilitiesApi.get(invalidId);
        // If no error thrown, that's actually OK (might return null)
      } catch (error: any) {
        // Should get a 404 or similar
        expect(error.response?.status).toBeGreaterThanOrEqual(400);
        console.log('✓ Invalid ID handled with appropriate error');
      }
    });

    it('should handle network errors gracefully', async () => {
      // This test verifies error handling infrastructure is in place
      // Actual network errors would require mocking
      expect(vulnerabilitiesApi.list).toBeDefined();
      expect(assetsApi.list).toBeDefined();
      expect(teamsApi.list).toBeDefined();

      console.log('✓ API methods are properly defined');
    });
  });

  describe('Performance', () => {
    it('should fetch vulnerabilities in reasonable time', async () => {
      const startTime = Date.now();
      await vulnerabilitiesApi.list();
      const endTime = Date.now();

      const duration = endTime - startTime;

      // Should complete within 5 seconds
      expect(duration).toBeLessThan(5000);

      console.log(`✓ Vulnerabilities fetched in ${duration}ms`);
    });

    it('should fetch assets in reasonable time', async () => {
      const startTime = Date.now();
      await assetsApi.list();
      const endTime = Date.now();

      const duration = endTime - startTime;

      expect(duration).toBeLessThan(5000);

      console.log(`✓ Assets fetched in ${duration}ms`);
    });
  });
});
