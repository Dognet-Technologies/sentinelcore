#!/usr/bin/env ts-node
/**
 * Data Validation Test Runner
 *
 * Esegue tutti i test di validazione dati e genera un report completo
 * sulla coerenza, integrit√† e correttezza dei dati.
 *
 * Usage:
 *   npm run test:data-validation
 *
 * Or directly:
 *   ts-node src/__tests__/runDataValidation.ts
 */

import { vulnerabilitiesApi } from '../api/vulnerabilities';
import { assetsApi } from '../api/assets';
import { teamsApi } from '../api/teams';

interface ValidationResult {
  category: string;
  test: string;
  passed: boolean;
  errors: any[];
  warnings: any[];
  info: string;
}

class DataValidator {
  private results: ValidationResult[] = [];

  async runAll(): Promise<void> {
    console.log('üîç Starting Data Validation Tests...\n');
    console.log('='.repeat(80));

    await this.validateVulnerabilityAssetConsistency();
    await this.validateVulnerabilityTeamConsistency();
    await this.validateAssetVulnerabilityCounts();
    await this.validateDataCompleteness();
    await this.validateCrossReferences();
    await this.validateContextConsistency();

    this.printReport();
  }

  private async validateVulnerabilityAssetConsistency(): Promise<void> {
    console.log('\nüìä Validating Vulnerability-Asset Consistency...');

    try {
      const vulnerabilities = await vulnerabilitiesApi.list();
      const assets = await assetsApi.list();
      const assetIds = new Set(assets.map(a => a.id));

      const invalidRefs: any[] = [];
      const ipMismatches: any[] = [];

      for (const vuln of vulnerabilities) {
        // Check asset_id validity
        if (vuln.asset_id && !assetIds.has(vuln.asset_id)) {
          invalidRefs.push({
            vuln_id: vuln.id,
            vuln_title: vuln.title,
            asset_id: vuln.asset_id,
          });
        }

        // Check IP consistency
        if (vuln.asset_id) {
          const asset = assets.find(a => a.id === vuln.asset_id);
          if (asset && asset.ip_address) {
            const vulnIp = vuln.ip_address.replace(/\/\d+$/, '');
            const assetIp = asset.ip_address.replace(/\/\d+$/, '');

            if (vulnIp !== assetIp) {
              ipMismatches.push({
                vuln_id: vuln.id,
                vuln_ip: vulnIp,
                asset_name: asset.name,
                asset_ip: assetIp,
              });
            }
          }
        }
      }

      this.results.push({
        category: 'Vulnerability-Asset Consistency',
        test: 'Asset ID References',
        passed: invalidRefs.length === 0,
        errors: invalidRefs,
        warnings: [],
        info: `Checked ${vulnerabilities.length} vulnerabilities against ${assets.length} assets`,
      });

      this.results.push({
        category: 'Vulnerability-Asset Consistency',
        test: 'IP Address Matching',
        passed: ipMismatches.length === 0,
        errors: ipMismatches,
        warnings: [],
        info: `Validated IP addresses for ${vulnerabilities.filter(v => v.asset_id).length} vulnerabilities`,
      });
    } catch (error: any) {
      this.results.push({
        category: 'Vulnerability-Asset Consistency',
        test: 'General',
        passed: false,
        errors: [{ message: error.message }],
        warnings: [],
        info: 'Failed to complete validation',
      });
    }
  }

  private async validateVulnerabilityTeamConsistency(): Promise<void> {
    console.log('üë• Validating Vulnerability-Team Consistency...');

    try {
      const vulnerabilities = await vulnerabilitiesApi.list();
      const teams = await teamsApi.list();
      const teamIds = new Set(teams.map(t => t.id));
      const teamMap = new Map(teams.map(t => [t.id, t]));

      const invalidTeamRefs: any[] = [];
      const teamNameMismatches: any[] = [];

      for (const vuln of vulnerabilities) {
        if (vuln.assigned_team_id && !teamIds.has(vuln.assigned_team_id)) {
          invalidTeamRefs.push({
            vuln_id: vuln.id,
            vuln_title: vuln.title,
            team_id: vuln.assigned_team_id,
          });
        }

        if (vuln.assigned_team_id && vuln.assigned_team_name) {
          const team = teamMap.get(vuln.assigned_team_id);
          if (team && vuln.assigned_team_name !== team.name) {
            teamNameMismatches.push({
              vuln_id: vuln.id,
              team_id: vuln.assigned_team_id,
              vuln_shows: vuln.assigned_team_name,
              team_shows: team.name,
            });
          }
        }
      }

      this.results.push({
        category: 'Vulnerability-Team Consistency',
        test: 'Team ID References',
        passed: invalidTeamRefs.length === 0,
        errors: invalidTeamRefs,
        warnings: [],
        info: `Checked ${vulnerabilities.filter(v => v.assigned_team_id).length} team assignments`,
      });

      this.results.push({
        category: 'Vulnerability-Team Consistency',
        test: 'Team Name Matching',
        passed: teamNameMismatches.length === 0,
        errors: teamNameMismatches,
        warnings: [],
        info: `Validated team names for assigned vulnerabilities`,
      });
    } catch (error: any) {
      this.results.push({
        category: 'Vulnerability-Team Consistency',
        test: 'General',
        passed: false,
        errors: [{ message: error.message }],
        warnings: [],
        info: 'Failed to complete validation',
      });
    }
  }

  private async validateAssetVulnerabilityCounts(): Promise<void> {
    console.log('üî¢ Validating Asset Vulnerability Counts...');

    try {
      const assets = await assetsApi.list();
      const vulnerabilities = await vulnerabilitiesApi.list();

      const countMismatches: any[] = [];

      for (const asset of assets) {
        const actualCount = vulnerabilities.filter(v => v.asset_id === asset.id).length;
        const reportedCount = asset.vulnerability_count || 0;

        if (actualCount !== reportedCount) {
          countMismatches.push({
            asset_id: asset.id,
            asset_name: asset.name,
            reported_count: reportedCount,
            actual_count: actualCount,
            difference: actualCount - reportedCount,
          });
        }
      }

      this.results.push({
        category: 'Asset Data Integrity',
        test: 'Vulnerability Count Accuracy',
        passed: countMismatches.length === 0,
        errors: countMismatches,
        warnings: [],
        info: `Checked vulnerability counts for ${assets.length} assets`,
      });
    } catch (error: any) {
      this.results.push({
        category: 'Asset Data Integrity',
        test: 'Vulnerability Count',
        passed: false,
        errors: [{ message: error.message }],
        warnings: [],
        info: 'Failed to complete validation',
      });
    }
  }

  private async validateDataCompleteness(): Promise<void> {
    console.log('‚úÖ Validating Data Completeness...');

    try {
      const vulnerabilities = await vulnerabilitiesApi.list();

      const incomplete: any[] = [];
      const invalidCVSS: any[] = [];
      const severityMismatches: any[] = [];

      const requiredFields = [
        'id',
        'title',
        'description',
        'cvss_score',
        'ip_address',
        'status',
        'severity',
        'source',
        'discovered_at',
      ];

      const getSeverityFromCVSS = (score: number): string => {
        if (score >= 9.0) return 'critical';
        if (score >= 7.0) return 'high';
        if (score >= 4.0) return 'medium';
        if (score > 0.0) return 'low';
        return 'info';
      };

      for (const vuln of vulnerabilities) {
        // Check required fields
        const missing: string[] = [];
        for (const field of requiredFields) {
          const value = vuln[field as keyof typeof vuln];
          if (value === null || value === undefined || value === '') {
            missing.push(field);
          }
        }

        if (missing.length > 0) {
          incomplete.push({
            id: vuln.id,
            title: vuln.title,
            missing_fields: missing,
          });
        }

        // Check CVSS score range
        if (vuln.cvss_score < 0 || vuln.cvss_score > 10) {
          invalidCVSS.push({
            id: vuln.id,
            title: vuln.title,
            cvss_score: vuln.cvss_score,
          });
        }

        // Check severity-CVSS alignment
        const expectedSeverity = getSeverityFromCVSS(vuln.cvss_score);
        if (vuln.severity !== expectedSeverity) {
          severityMismatches.push({
            id: vuln.id,
            title: vuln.title,
            cvss_score: vuln.cvss_score,
            severity: vuln.severity,
            expected_severity: expectedSeverity,
          });
        }
      }

      this.results.push({
        category: 'Data Completeness',
        test: 'Required Fields',
        passed: incomplete.length === 0,
        errors: incomplete,
        warnings: [],
        info: `Checked ${vulnerabilities.length} vulnerabilities for required fields`,
      });

      this.results.push({
        category: 'Data Completeness',
        test: 'CVSS Score Range (0-10)',
        passed: invalidCVSS.length === 0,
        errors: invalidCVSS,
        warnings: [],
        info: 'Validated CVSS score ranges',
      });

      this.results.push({
        category: 'Data Completeness',
        test: 'Severity-CVSS Alignment',
        passed: severityMismatches.length === 0,
        errors: severityMismatches,
        warnings: [],
        info: 'Checked severity levels match CVSS scores',
      });
    } catch (error: any) {
      this.results.push({
        category: 'Data Completeness',
        test: 'General',
        passed: false,
        errors: [{ message: error.message }],
        warnings: [],
        info: 'Failed to complete validation',
      });
    }
  }

  private async validateCrossReferences(): Promise<void> {
    console.log('üîó Validating Cross-References...');

    try {
      const vulnerabilities = await vulnerabilitiesApi.list();
      const assets = await assetsApi.list();
      const teams = await teamsApi.list();

      const assetIds = new Set(assets.map(a => a.id));
      const teamIds = new Set(teams.map(t => t.id));

      const brokenRefs: any[] = [];

      for (const vuln of vulnerabilities) {
        if (vuln.asset_id && !assetIds.has(vuln.asset_id)) {
          brokenRefs.push({
            type: 'asset',
            vuln_id: vuln.id,
            vuln_title: vuln.title,
            reference_id: vuln.asset_id,
          });
        }

        if (vuln.assigned_team_id && !teamIds.has(vuln.assigned_team_id)) {
          brokenRefs.push({
            type: 'team',
            vuln_id: vuln.id,
            vuln_title: vuln.title,
            reference_id: vuln.assigned_team_id,
          });
        }
      }

      this.results.push({
        category: 'Cross-Reference Integrity',
        test: 'Foreign Key Validity',
        passed: brokenRefs.length === 0,
        errors: brokenRefs,
        warnings: [],
        info: `Validated ${vulnerabilities.length} vulnerabilities against ${assets.length} assets and ${teams.length} teams`,
      });
    } catch (error: any) {
      this.results.push({
        category: 'Cross-Reference Integrity',
        test: 'General',
        passed: false,
        errors: [{ message: error.message }],
        warnings: [],
        info: 'Failed to complete validation',
      });
    }
  }

  private async validateContextConsistency(): Promise<void> {
    console.log('üéØ Validating Context Consistency...');

    try {
      const vulnerabilities = await vulnerabilitiesApi.list();

      const contextIssues: any[] = [];

      for (const vuln of vulnerabilities) {
        // Critical open vulnerabilities should be assigned
        if (
          vuln.status === 'open' &&
          vuln.severity === 'critical' &&
          !vuln.assigned_team_id &&
          !vuln.assigned_user_id
        ) {
          contextIssues.push({
            vuln_id: vuln.id,
            title: vuln.title,
            issue: 'Critical vulnerability is open but not assigned',
          });
        }

        // In-progress vulnerabilities should be assigned
        if (
          vuln.status === 'in_progress' &&
          !vuln.assigned_team_id &&
          !vuln.assigned_user_id
        ) {
          contextIssues.push({
            vuln_id: vuln.id,
            title: vuln.title,
            issue: 'In-progress vulnerability is not assigned',
          });
        }
      }

      this.results.push({
        category: 'Context Consistency',
        test: 'Assignment Logic',
        passed: true, // These are warnings, not errors
        errors: [],
        warnings: contextIssues,
        info: `Checked assignment context for ${vulnerabilities.length} vulnerabilities`,
      });
    } catch (error: any) {
      this.results.push({
        category: 'Context Consistency',
        test: 'General',
        passed: false,
        errors: [{ message: error.message }],
        warnings: [],
        info: 'Failed to complete validation',
      });
    }
  }

  private printReport(): void {
    console.log('\n' + '='.repeat(80));
    console.log('üìã DATA VALIDATION REPORT');
    console.log('='.repeat(80) + '\n');

    const categories = new Map<string, ValidationResult[]>();
    for (const result of this.results) {
      if (!categories.has(result.category)) {
        categories.set(result.category, []);
      }
      categories.get(result.category)!.push(result);
    }

    let totalTests = 0;
    let passedTests = 0;
    let totalErrors = 0;
    let totalWarnings = 0;

    for (const [category, results] of Array.from(categories.entries())) {
      console.log(`\n${category}`);
      console.log('-'.repeat(80));

      for (const result of results) {
        totalTests++;
        if (result.passed) passedTests++;

        const status = result.passed ? '‚úÖ' : '‚ùå';
        console.log(`\n${status} ${result.test}`);
        console.log(`   ${result.info}`);

        if (result.errors.length > 0) {
          totalErrors += result.errors.length;
          console.log(`   ‚ö†Ô∏è  Errors: ${result.errors.length}`);
          if (result.errors.length <= 3) {
            for (const error of result.errors) {
              console.log(`      - ${JSON.stringify(error)}`);
            }
          } else {
            console.log(`      (showing first 3 of ${result.errors.length})`);
            for (let i = 0; i < 3; i++) {
              console.log(`      - ${JSON.stringify(result.errors[i])}`);
            }
          }
        }

        if (result.warnings.length > 0) {
          totalWarnings += result.warnings.length;
          console.log(`   ‚ö†Ô∏è  Warnings: ${result.warnings.length}`);
          if (result.warnings.length <= 3) {
            for (const warning of result.warnings) {
              console.log(`      - ${JSON.stringify(warning)}`);
            }
          }
        }
      }
    }

    console.log('\n' + '='.repeat(80));
    console.log('SUMMARY');
    console.log('='.repeat(80));
    console.log(`Total Tests:    ${totalTests}`);
    console.log(`Passed:         ${passedTests} (${Math.round((passedTests / totalTests) * 100)}%)`);
    console.log(`Failed:         ${totalTests - passedTests}`);
    console.log(`Total Errors:   ${totalErrors}`);
    console.log(`Total Warnings: ${totalWarnings}`);

    if (passedTests === totalTests && totalErrors === 0) {
      console.log('\nüéâ All data validation tests passed!');
    } else if (totalErrors === 0) {
      console.log('\n‚úÖ All tests passed (with warnings)');
    } else {
      console.log(`\n‚ö†Ô∏è  Found ${totalErrors} data integrity issues that need attention`);
    }

    console.log('='.repeat(80) + '\n');
  }
}

// Run validation if executed directly
const isMainModule = typeof require !== 'undefined' && typeof module !== 'undefined' && require.main === module;
if (isMainModule) {
  const validator = new DataValidator();
  validator.runAll().catch((error) => {
    console.error('Fatal error running validation:', error);
    if (typeof process !== 'undefined') {
      process.exit(1);
    }
  });
}

export default DataValidator;
