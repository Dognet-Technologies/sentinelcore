/**
 * Data Consistency Tests
 *
 * Verifica la coerenza e correttezza dei dati tra diverse entità:
 * - Vulnerabilità associate ad asset esistenti
 * - Conteggi (vulnerability_count, members_count) corretti
 * - Foreign key integrity (asset_id, team_id, user_id)
 * - Dati visualizzati nel contesto corretto
 */

import { vulnerabilitiesApi } from '../api/vulnerabilities';
import { assetsApi } from '../api/assets';
import { teamsApi } from '../api/teams';
import { Vulnerability, Asset, Team } from '../types';

describe('Data Consistency Tests', () => {
  describe('Vulnerability-Asset Consistency', () => {
    it('should have valid asset_id for all vulnerabilities with asset references', async () => {
      // Fetch all vulnerabilities
      const vulnerabilities = await vulnerabilitiesApi.list();

      // Fetch all assets for validation
      const assets = await assetsApi.list();
      const assetIds = new Set(assets.map(a => a.id));

      // Verify each vulnerability with asset_id has a valid reference
      const invalidRefs: Array<{ vuln_id: string; asset_id: string }> = [];

      for (const vuln of vulnerabilities) {
        if (vuln.asset_id && !assetIds.has(vuln.asset_id)) {
          invalidRefs.push({
            vuln_id: vuln.id,
            asset_id: vuln.asset_id
          });
        }
      }

      expect(invalidRefs).toEqual([]);

      if (invalidRefs.length > 0) {
        console.error('❌ Invalid asset references found:', invalidRefs);
      }
    });

    it('should have matching vulnerability counts on assets', async () => {
      const assets = await assetsApi.list();
      const vulnerabilities = await vulnerabilitiesApi.list();

      const errors: Array<{
        asset_id: string;
        asset_name: string;
        reported_count: number;
        actual_count: number;
      }> = [];

      for (const asset of assets) {
        // Count actual vulnerabilities for this asset
        const actualCount = vulnerabilities.filter(
          v => v.asset_id === asset.id
        ).length;

        const reportedCount = asset.vulnerability_count || 0;

        if (actualCount !== reportedCount) {
          errors.push({
            asset_id: asset.id,
            asset_name: asset.name,
            reported_count: reportedCount,
            actual_count: actualCount,
          });
        }
      }

      expect(errors).toEqual([]);

      if (errors.length > 0) {
        console.error('❌ Asset vulnerability count mismatches:', errors);
      }
    });

    it('should have consistent IP addresses between vulnerabilities and assets', async () => {
      const vulnerabilities = await vulnerabilitiesApi.list();
      const assets = await assetsApi.list();

      // Create a map of asset_id -> asset for quick lookup
      const assetMap = new Map(assets.map(a => [a.id, a]));

      const inconsistencies: Array<{
        vuln_id: string;
        vuln_title: string;
        vuln_ip: string;
        asset_name: string;
        asset_ip: string;
      }> = [];

      for (const vuln of vulnerabilities) {
        if (!vuln.asset_id) continue;

        const asset = assetMap.get(vuln.asset_id);
        if (!asset) continue;

        // Extract base IP (remove CIDR notation)
        const vulnIp = vuln.ip_address.replace(/\/\d+$/, '');
        const assetIp = asset.ip_address?.replace(/\/\d+$/, '');

        if (assetIp && vulnIp !== assetIp) {
          inconsistencies.push({
            vuln_id: vuln.id,
            vuln_title: vuln.title,
            vuln_ip: vulnIp,
            asset_name: asset.name,
            asset_ip: assetIp,
          });
        }
      }

      expect(inconsistencies).toEqual([]);

      if (inconsistencies.length > 0) {
        console.error('❌ IP address inconsistencies found:', inconsistencies);
      }
    });
  });

  describe('Vulnerability-Team Consistency', () => {
    it('should have valid team_id for all vulnerabilities with team assignments', async () => {
      const vulnerabilities = await vulnerabilitiesApi.list();
      const teams = await teamsApi.list();
      const teamIds = new Set(teams.map(t => t.id));

      const invalidRefs: Array<{ vuln_id: string; team_id: string }> = [];

      for (const vuln of vulnerabilities) {
        if (vuln.assigned_team_id && !teamIds.has(vuln.assigned_team_id)) {
          invalidRefs.push({
            vuln_id: vuln.id,
            team_id: vuln.assigned_team_id,
          });
        }
      }

      expect(invalidRefs).toEqual([]);

      if (invalidRefs.length > 0) {
        console.error('❌ Invalid team references found:', invalidRefs);
      }
    });

    it('should have consistent team names between vulnerabilities and teams', async () => {
      const vulnerabilities = await vulnerabilitiesApi.list();
      const teams = await teamsApi.list();
      const teamMap = new Map(teams.map(t => [t.id, t]));

      const inconsistencies: Array<{
        vuln_id: string;
        team_id: string;
        vuln_team_name: string;
        actual_team_name: string;
      }> = [];

      for (const vuln of vulnerabilities) {
        if (!vuln.assigned_team_id || !vuln.assigned_team_name) continue;

        const team = teamMap.get(vuln.assigned_team_id);
        if (!team) continue;

        if (vuln.assigned_team_name !== team.name) {
          inconsistencies.push({
            vuln_id: vuln.id,
            team_id: vuln.assigned_team_id,
            vuln_team_name: vuln.assigned_team_name,
            actual_team_name: team.name,
          });
        }
      }

      expect(inconsistencies).toEqual([]);

      if (inconsistencies.length > 0) {
        console.error('❌ Team name inconsistencies found:', inconsistencies);
      }
    });
  });

  describe('Data Completeness', () => {
    it('should have required fields populated for all vulnerabilities', async () => {
      const vulnerabilities = await vulnerabilitiesApi.list();

      const incomplete: Array<{
        id: string;
        missing_fields: string[];
      }> = [];

      const requiredFields: (keyof Vulnerability)[] = [
        'id',
        'title',
        'description',
        'cvss_score',
        'ip_address',
        'status',
        'severity',
        'source',
        'discovered_at',
      ];

      for (const vuln of vulnerabilities) {
        const missing: string[] = [];

        for (const field of requiredFields) {
          const value = vuln[field];
          if (value === null || value === undefined || value === '') {
            missing.push(field);
          }
        }

        if (missing.length > 0) {
          incomplete.push({
            id: vuln.id,
            missing_fields: missing,
          });
        }
      }

      expect(incomplete).toEqual([]);

      if (incomplete.length > 0) {
        console.error('❌ Incomplete vulnerability records:', incomplete);
      }
    });

    it('should have valid CVSS scores (0-10)', async () => {
      const vulnerabilities = await vulnerabilitiesApi.list();

      const invalid: Array<{
        id: string;
        title: string;
        cvss_score: number;
      }> = [];

      for (const vuln of vulnerabilities) {
        if (vuln.cvss_score < 0 || vuln.cvss_score > 10) {
          invalid.push({
            id: vuln.id,
            title: vuln.title,
            cvss_score: vuln.cvss_score,
          });
        }
      }

      expect(invalid).toEqual([]);

      if (invalid.length > 0) {
        console.error('❌ Invalid CVSS scores found:', invalid);
      }
    });

    it('should have valid severity levels matching CVSS scores', async () => {
      const vulnerabilities = await vulnerabilitiesApi.list();

      const mismatches: Array<{
        id: string;
        title: string;
        cvss_score: number;
        severity: string;
        expected_severity: string;
      }> = [];

      const getSeverityFromCVSS = (score: number): string => {
        if (score >= 9.0) return 'critical';
        if (score >= 7.0) return 'high';
        if (score >= 4.0) return 'medium';
        if (score > 0.0) return 'low';
        return 'info';
      };

      for (const vuln of vulnerabilities) {
        const expectedSeverity = getSeverityFromCVSS(vuln.cvss_score);

        if (vuln.severity !== expectedSeverity) {
          mismatches.push({
            id: vuln.id,
            title: vuln.title,
            cvss_score: vuln.cvss_score,
            severity: vuln.severity,
            expected_severity: expectedSeverity,
          });
        }
      }

      expect(mismatches).toEqual([]);

      if (mismatches.length > 0) {
        console.error('❌ Severity-CVSS mismatches found:', mismatches);
      }
    });
  });

  describe('Cross-Reference Integrity', () => {
    it('should maintain referential integrity across all entities', async () => {
      const vulnerabilities = await vulnerabilitiesApi.list();
      const assets = await assetsApi.list();
      const teams = await teamsApi.list();

      const assetIds = new Set(assets.map(a => a.id));
      const teamIds = new Set(teams.map(t => t.id));

      const errors: Array<{
        type: 'asset' | 'team';
        vuln_id: string;
        reference_id: string;
      }> = [];

      for (const vuln of vulnerabilities) {
        // Check asset reference
        if (vuln.asset_id && !assetIds.has(vuln.asset_id)) {
          errors.push({
            type: 'asset',
            vuln_id: vuln.id,
            reference_id: vuln.asset_id,
          });
        }

        // Check team reference
        if (vuln.assigned_team_id && !teamIds.has(vuln.assigned_team_id)) {
          errors.push({
            type: 'team',
            vuln_id: vuln.id,
            reference_id: vuln.assigned_team_id,
          });
        }
      }

      expect(errors).toEqual([]);

      if (errors.length > 0) {
        console.error('❌ Referential integrity violations:', errors);
      }
    });
  });
});
