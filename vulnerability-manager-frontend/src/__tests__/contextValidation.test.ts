/**
 * Context Validation Tests
 *
 * Verifica che i dati mostrati nelle diverse pagine siano appropriati
 * per il contesto e che non ci siano inconsistenze tra viste diverse
 * degli stessi dati (es. host nelle vulnerabilità vs host nei team).
 */

import { vulnerabilitiesApi } from '../api/vulnerabilities';
import { assetsApi } from '../api/assets';
import { teamsApi } from '../api/teams';

describe('Context Validation Tests', () => {
  describe('Host Consistency Across Contexts', () => {
    it('should show the same host data in vulnerability list and team assignments', async () => {
      const vulnerabilities = await vulnerabilitiesApi.list();
      const assets = await assetsApi.list();

      // Create a map of asset_id -> asset data
      const assetMap = new Map(
        assets.map(a => [
          a.id,
          {
            id: a.id,
            name: a.name,
            ip_address: a.ip_address,
            hostname: a.hostname,
            asset_type: a.asset_type,
          },
        ])
      );

      const inconsistencies: Array<{
        context: string;
        vuln_id: string;
        vuln_data: any;
        asset_data: any;
        mismatch: string;
      }> = [];

      for (const vuln of vulnerabilities) {
        if (!vuln.asset_id) continue;

        const asset = assetMap.get(vuln.asset_id);
        if (!asset) continue;

        // Verifica IP address consistency
        const vulnIp = vuln.ip_address.replace(/\/\d+$/, '');
        const assetIp = asset.ip_address?.replace(/\/\d+$/, '');

        if (assetIp && vulnIp !== assetIp) {
          inconsistencies.push({
            context: 'IP Address',
            vuln_id: vuln.id,
            vuln_data: { ip_address: vulnIp },
            asset_data: { ip_address: assetIp, name: asset.name },
            mismatch: `Vulnerability shows IP ${vulnIp} but asset has ${assetIp}`,
          });
        }

        // Verifica hostname consistency
        if (vuln.hostname && asset.hostname && vuln.hostname !== asset.hostname) {
          inconsistencies.push({
            context: 'Hostname',
            vuln_id: vuln.id,
            vuln_data: { hostname: vuln.hostname },
            asset_data: { hostname: asset.hostname, name: asset.name },
            mismatch: `Vulnerability shows hostname ${vuln.hostname} but asset has ${asset.hostname}`,
          });
        }
      }

      expect(inconsistencies).toEqual([]);

      if (inconsistencies.length > 0) {
        console.error('❌ Host data inconsistencies across contexts:', inconsistencies);
      }
    });

    it('should have the same assets referenced in vulnerabilities and asset list', async () => {
      const vulnerabilities = await vulnerabilitiesApi.list();
      const assets = await assetsApi.list();

      // Get unique asset IDs from vulnerabilities
      const vulnAssetIds = new Set(
        vulnerabilities
          .filter(v => v.asset_id)
          .map(v => v.asset_id!)
      );

      // Get asset IDs from asset list
      const assetListIds = new Set(assets.map(a => a.id));

      // Find assets in vulnerabilities but not in asset list
      const missingInAssetList = Array.from(vulnAssetIds).filter(
        id => !assetListIds.has(id)
      );

      // Find orphaned assets (in asset list but never referenced by vulnerabilities)
      const orphanedAssets = assets.filter(
        a => !vulnAssetIds.has(a.id) && a.vulnerability_count && a.vulnerability_count > 0
      );

      expect(missingInAssetList).toEqual([]);
      expect(orphanedAssets).toEqual([]);

      if (missingInAssetList.length > 0) {
        console.error('❌ Assets referenced in vulnerabilities but missing from asset list:', missingInAssetList);
      }

      if (orphanedAssets.length > 0) {
        console.error(
          '❌ Assets with vulnerability_count > 0 but no actual vulnerabilities:',
          orphanedAssets.map(a => ({ id: a.id, name: a.name, count: a.vulnerability_count }))
        );
      }
    });
  });

  describe('Team Assignment Context', () => {
    it('should show consistent team data across vulnerability assignments and team pages', async () => {
      const vulnerabilities = await vulnerabilitiesApi.list();
      const teams = await teamsApi.list();

      // Group vulnerabilities by team
      const vulnsByTeam = new Map<string, number>();
      for (const vuln of vulnerabilities) {
        if (vuln.assigned_team_id) {
          vulnsByTeam.set(
            vuln.assigned_team_id,
            (vulnsByTeam.get(vuln.assigned_team_id) || 0) + 1
          );
        }
      }

      const inconsistencies: Array<{
        team_id: string;
        team_name: string;
        actual_assigned_vulns: number;
        context_note: string;
      }> = [];

      for (const team of teams) {
        const actualAssigned = vulnsByTeam.get(team.id) || 0;

        // Context validation: se un team ha membri, dovrebbe avere vulnerabilità assegnate
        // (a meno che non sia appena stato creato)
        if (team.members_count && team.members_count > 0 && actualAssigned === 0) {
          inconsistencies.push({
            team_id: team.id,
            team_name: team.name,
            actual_assigned_vulns: actualAssigned,
            context_note: `Team has ${team.members_count} members but no vulnerabilities assigned`,
          });
        }
      }

      // Questo è un warning, non un errore critico
      if (inconsistencies.length > 0) {
        console.warn('⚠️ Teams with members but no assigned vulnerabilities:', inconsistencies);
      }
    });

    it('should maintain team name consistency across all contexts', async () => {
      const vulnerabilities = await vulnerabilitiesApi.list();
      const teams = await teamsApi.list();

      const teamMap = new Map(teams.map(t => [t.id, t.name]));

      const nameInconsistencies: Array<{
        vuln_id: string;
        team_id: string;
        vuln_shows: string;
        team_list_shows: string;
      }> = [];

      for (const vuln of vulnerabilities) {
        if (!vuln.assigned_team_id || !vuln.assigned_team_name) continue;

        const actualTeamName = teamMap.get(vuln.assigned_team_id);
        if (!actualTeamName) continue;

        if (vuln.assigned_team_name !== actualTeamName) {
          nameInconsistencies.push({
            vuln_id: vuln.id,
            team_id: vuln.assigned_team_id,
            vuln_shows: vuln.assigned_team_name,
            team_list_shows: actualTeamName,
          });
        }
      }

      expect(nameInconsistencies).toEqual([]);

      if (nameInconsistencies.length > 0) {
        console.error('❌ Team name inconsistencies across contexts:', nameInconsistencies);
      }
    });
  });

  describe('Vulnerability Status Context', () => {
    it('should have appropriate status for vulnerabilities with different contexts', async () => {
      const vulnerabilities = await vulnerabilitiesApi.list();

      const contextIssues: Array<{
        vuln_id: string;
        title: string;
        status: string;
        issue: string;
      }> = [];

      for (const vuln of vulnerabilities) {
        // Resolved vulnerabilities should not be critical priority
        if (vuln.status === 'resolved' && vuln.severity === 'critical') {
          // Check if it was resolved recently (within 24h) - that's OK
          // Otherwise it's suspicious
          const now = new Date();
          const discovered = new Date(vuln.discovered_at);
          const daysSinceDiscovery = (now.getTime() - discovered.getTime()) / (1000 * 60 * 60 * 24);

          if (daysSinceDiscovery > 1) {
            // This is actually OK - critical vulnerabilities can be resolved
            // But we log for awareness
          }
        }

        // Open critical vulnerabilities should have assignments
        if (
          vuln.status === 'open' &&
          vuln.severity === 'critical' &&
          !vuln.assigned_team_id &&
          !vuln.assigned_user_id
        ) {
          contextIssues.push({
            vuln_id: vuln.id,
            title: vuln.title,
            status: vuln.status,
            issue: 'Critical vulnerability is open but not assigned to any team or user',
          });
        }

        // In-progress vulnerabilities should have assignments
        if (
          vuln.status === 'in_progress' &&
          !vuln.assigned_team_id &&
          !vuln.assigned_user_id
        ) {
          contextIssues.push({
            vuln_id: vuln.id,
            title: vuln.title,
            status: vuln.status,
            issue: 'Vulnerability is in progress but not assigned to anyone',
          });
        }
      }

      // Questi sono warning, non errori bloccanti
      if (contextIssues.length > 0) {
        console.warn('⚠️ Context issues found (may need attention):', contextIssues);
      }
    });
  });

  describe('Data Representation Context', () => {
    it('should have consistent data representation for the same entity across different views', async () => {
      const vulnerabilities = await vulnerabilitiesApi.list();
      const assets = await assetsApi.list();

      // Test che gli stessi dati vengano rappresentati allo stesso modo
      const representationIssues: Array<{
        entity_type: string;
        entity_id: string;
        field: string;
        representation1: any;
        representation2: any;
      }> = [];

      // Create asset representation map
      const assetRepresentations = new Map<string, Set<string>>();

      for (const vuln of vulnerabilities) {
        if (!vuln.asset_id) continue;

        // Collect how this asset is represented in vulnerability context
        const representation = `${vuln.ip_address}|${vuln.hostname || 'N/A'}`;

        if (!assetRepresentations.has(vuln.asset_id)) {
          assetRepresentations.set(vuln.asset_id, new Set());
        }
        assetRepresentations.get(vuln.asset_id)!.add(representation);
      }

      // Check for inconsistent representations
      for (const [assetId, representations] of assetRepresentations) {
        if (representations.size > 1) {
          const asset = assets.find(a => a.id === assetId);
          representationIssues.push({
            entity_type: 'asset',
            entity_id: assetId,
            field: 'ip_address|hostname',
            representation1: Array.from(representations)[0],
            representation2: Array.from(representations)[1],
          });
        }
      }

      expect(representationIssues).toEqual([]);

      if (representationIssues.length > 0) {
        console.error('❌ Same entity represented differently across contexts:', representationIssues);
      }
    });
  });
});
