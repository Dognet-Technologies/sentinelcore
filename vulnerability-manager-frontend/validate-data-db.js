#!/usr/bin/env node
/**
 * Data Validation Runner - Direct Database Access
 * Bypassa l'autenticazione interrogando direttamente il database
 */

const { Client } = require('pg');

const client = new Client({
  host: 'localhost',
  port: 5432,
  database: 'vulnerability_manager',
  user: 'vlnman',
  password: 'DogNET',
});

async function runValidation() {
  console.log('ðŸ” Starting Data Validation Tests (Direct DB Access)...\n');
  console.log('='.repeat(80));

  let totalTests = 0;
  let passedTests = 0;
  let errors = [];

  try {
    await client.connect();
    console.log('âœ… Connected to database\n');

    // Test 1: Fetch vulnerabilities
    console.log('ðŸ“Š Test 1: Fetching Vulnerabilities...');
    totalTests++;
    const vulnResult = await client.query('SELECT * FROM vulnerabilities WHERE deleted_at IS NULL');
    const vulnerabilities = vulnResult.rows;
    console.log(`  âœ… SUCCESS: Fetched ${vulnerabilities.length} vulnerabilities`);
    passedTests++;

    // Test 2: Fetch assets
    console.log('\nðŸ“¦ Test 2: Fetching Assets...');
    totalTests++;
    const assetResult = await client.query('SELECT * FROM assets WHERE deleted_at IS NULL');
    const assets = assetResult.rows;
    console.log(`  âœ… SUCCESS: Fetched ${assets.length} assets`);
    passedTests++;

    // Test 3: Fetch teams
    console.log('\nðŸ‘¥ Test 3: Fetching Teams...');
    totalTests++;
    const teamResult = await client.query('SELECT * FROM teams WHERE deleted_at IS NULL');
    const teams = teamResult.rows;
    console.log(`  âœ… SUCCESS: Fetched ${teams.length} teams`);
    passedTests++;

    // Test 4: Vulnerability-Asset Consistency
    console.log('\nðŸ”— Test 4: Checking Vulnerability-Asset References...');
    totalTests++;
    const assetIds = new Set(assets.map(a => a.id));
    const invalidAssetRefs = vulnerabilities.filter(v => v.asset_id && !assetIds.has(v.asset_id));

    if (invalidAssetRefs.length === 0) {
      console.log(`  âœ… SUCCESS: All ${vulnerabilities.filter(v => v.asset_id).length} asset references are valid`);
      passedTests++;
    } else {
      console.log(`  âŒ FAIL: Found ${invalidAssetRefs.length} invalid asset references`);
      errors.push({
        test: 'Vulnerability-Asset References',
        error: `${invalidAssetRefs.length} vulnerabilities reference non-existent assets`,
        details: invalidAssetRefs.slice(0, 3).map(v => ({ vuln_id: v.id, asset_id: v.asset_id }))
      });
    }

    // Test 5: Vulnerability-Team Consistency
    console.log('\nðŸ”— Test 5: Checking Vulnerability-Team References...');
    totalTests++;
    const teamIds = new Set(teams.map(t => t.id));
    const invalidTeamRefs = vulnerabilities.filter(v => v.assigned_team_id && !teamIds.has(v.assigned_team_id));

    if (invalidTeamRefs.length === 0) {
      console.log(`  âœ… SUCCESS: All ${vulnerabilities.filter(v => v.assigned_team_id).length} team references are valid`);
      passedTests++;
    } else {
      console.log(`  âŒ FAIL: Found ${invalidTeamRefs.length} invalid team references`);
      errors.push({
        test: 'Vulnerability-Team References',
        error: `${invalidTeamRefs.length} vulnerabilities reference non-existent teams`,
        details: invalidTeamRefs.slice(0, 3).map(v => ({ vuln_id: v.id, team_id: v.assigned_team_id }))
      });
    }

    // Test 6: IP Address Consistency
    console.log('\nðŸŒ Test 6: Checking IP Address Consistency...');
    totalTests++;
    const assetMap = new Map(assets.map(a => [a.id, a]));
    const ipMismatches = [];

    for (const vuln of vulnerabilities) {
      if (!vuln.asset_id) continue;
      const asset = assetMap.get(vuln.asset_id);
      if (!asset || !asset.ip_address) continue;

      const vulnIp = vuln.ip_address.replace(/\/\d+$/, '');
      const assetIp = asset.ip_address.replace(/\/\d+$/, '');

      if (vulnIp !== assetIp) {
        ipMismatches.push({
          vuln_id: vuln.id,
          vuln_ip: vulnIp,
          asset_name: asset.name,
          asset_ip: assetIp
        });
      }
    }

    if (ipMismatches.length === 0) {
      console.log(`  âœ… SUCCESS: All IP addresses consistent between vulnerabilities and assets`);
      passedTests++;
    } else {
      console.log(`  âŒ FAIL: Found ${ipMismatches.length} IP address mismatches`);
      errors.push({
        test: 'IP Address Consistency',
        error: `${ipMismatches.length} vulnerabilities have different IPs than their assets`,
        details: ipMismatches.slice(0, 3)
      });
    }

    // Test 7: Asset-Vulnerability Relationship Integrity
    console.log('\nðŸ”¢ Test 7: Checking Asset-Vulnerability Relationships...');
    totalTests++;

    // Verify each asset referenced by vulnerabilities actually exists
    const referencedAssetIds = new Set(vulnerabilities.filter(v => v.asset_id).map(v => v.asset_id));
    const orphanedReferences = [];

    for (const assetId of referencedAssetIds) {
      if (!assetIds.has(assetId)) {
        const vulnCount = vulnerabilities.filter(v => v.asset_id === assetId).length;
        orphanedReferences.push({
          asset_id: assetId,
          vulnerability_count: vulnCount
        });
      }
    }

    if (orphanedReferences.length === 0) {
      console.log(`  âœ… SUCCESS: All ${referencedAssetIds.size} referenced assets exist in database`);
      passedTests++;
    } else {
      console.log(`  âŒ FAIL: Found ${orphanedReferences.length} orphaned asset references`);
      errors.push({
        test: 'Asset-Vulnerability Relationships',
        error: `${orphanedReferences.length} asset IDs referenced by vulnerabilities don't exist`,
        details: orphanedReferences.slice(0, 5)
      });
    }

    // Test 8: CVSS Score Validation
    console.log('\nðŸ“Š Test 8: Validating CVSS Scores...');
    totalTests++;
    const invalidCVSS = vulnerabilities.filter(v => v.cvss_score < 0 || v.cvss_score > 10);

    if (invalidCVSS.length === 0) {
      console.log(`  âœ… SUCCESS: All ${vulnerabilities.length} CVSS scores are in valid range (0-10)`);
      passedTests++;
    } else {
      console.log(`  âŒ FAIL: Found ${invalidCVSS.length} invalid CVSS scores`);
      errors.push({
        test: 'CVSS Score Validation',
        error: `${invalidCVSS.length} vulnerabilities have invalid CVSS scores`,
        details: invalidCVSS.slice(0, 3).map(v => ({ id: v.id, title: v.title, cvss_score: v.cvss_score }))
      });
    }

    // Test 9: Severity-CVSS Alignment
    console.log('\nâš–ï¸  Test 9: Checking Severity-CVSS Alignment...');
    totalTests++;
    const severityMismatches = [];

    const getSeverityFromCVSS = (score) => {
      if (score >= 9.0) return 'critical';
      if (score >= 7.0) return 'high';
      if (score >= 4.0) return 'medium';
      if (score > 0.0) return 'low';
      return 'info';
    };

    for (const vuln of vulnerabilities) {
      const expectedSeverity = getSeverityFromCVSS(vuln.cvss_score);
      if (vuln.severity !== expectedSeverity) {
        severityMismatches.push({
          id: vuln.id,
          title: vuln.title,
          cvss_score: vuln.cvss_score,
          severity: vuln.severity,
          expected: expectedSeverity
        });
      }
    }

    if (severityMismatches.length === 0) {
      console.log(`  âœ… SUCCESS: All ${vulnerabilities.length} severity levels match CVSS scores`);
      passedTests++;
    } else {
      console.log(`  âŒ FAIL: Found ${severityMismatches.length} severity mismatches`);
      errors.push({
        test: 'Severity-CVSS Alignment',
        error: `${severityMismatches.length} vulnerabilities have severity not matching CVSS`,
        details: severityMismatches.slice(0, 5)
      });
    }

    // Test 10: Required Fields
    console.log('\nâœ… Test 10: Checking Required Fields...');
    totalTests++;
    const requiredFields = ['id', 'title', 'description', 'cvss_score', 'ip_address', 'status', 'severity', 'source'];
    const incompleteVulns = [];

    for (const vuln of vulnerabilities) {
      const missing = requiredFields.filter(field => !vuln[field] && vuln[field] !== 0 && vuln[field] !== false);
      if (missing.length > 0) {
        incompleteVulns.push({ id: vuln.id, missing });
      }
    }

    if (incompleteVulns.length === 0) {
      console.log(`  âœ… SUCCESS: All ${vulnerabilities.length} vulnerabilities have required fields`);
      passedTests++;
    } else {
      console.log(`  âŒ FAIL: Found ${incompleteVulns.length} vulnerabilities with missing fields`);
      errors.push({
        test: 'Required Fields',
        error: `${incompleteVulns.length} vulnerabilities missing required fields`,
        details: incompleteVulns.slice(0, 3)
      });
    }

  } catch (error) {
    console.log(`\nâŒ Fatal error: ${error.message}`);
    errors.push({ test: 'General', error: error.message });
  } finally {
    await client.end();
  }

  // Print summary
  console.log('\n' + '='.repeat(80));
  console.log('ðŸ“‹ SUMMARY');
  console.log('='.repeat(80));
  console.log(`Total Tests:    ${totalTests}`);
  console.log(`Passed:         ${passedTests} (${totalTests > 0 ? Math.round((passedTests / totalTests) * 100) : 0}%)`);
  console.log(`Failed:         ${totalTests - passedTests}`);
  console.log(`Total Errors:   ${errors.length}`);

  if (errors.length > 0) {
    console.log('\nâš ï¸  ERRORS FOUND:');
    console.log('='.repeat(80));
    errors.forEach((err, idx) => {
      console.log(`\n${idx + 1}. ${err.test}`);
      console.log(`   Error: ${err.error}`);
      if (err.details) {
        console.log(`   Details:`);
        err.details.forEach((detail, i) => {
          console.log(`     ${i + 1}. ${JSON.stringify(detail)}`);
        });
      }
    });
  }

  if (passedTests === totalTests && errors.length === 0) {
    console.log('\nðŸŽ‰ All data validation tests passed!');
  } else {
    console.log(`\nâš ï¸  Found ${errors.length} data integrity issues that need attention`);
  }

  console.log('='.repeat(80) + '\n');
}

// Run validation
runValidation().catch((error) => {
  console.error('Fatal error:', error);
  process.exit(1);
});
